
//
//  LineValidation.cpp
//  Windfall
//
//  Created by Patrick Questembert on 4/18/15.
//  Copyright (c) 2015 Windfall. All rights reserved.
//

#define CODE_CPP 1

#include "common.hh"
#include "ocr.hh"
#include "OCRClass.hh"
#include "LineValidation.hh"
#import "OCRPage.hh"
#import "OCRUtils.hh"
#import "RegexUtils.hh"

// Class to analyze character images
#include "single_letter/slcommon.h"
#include "single_letter/cimage.h"
#include "single_letter/SingleLetterTests.h"

namespace ocrparser {

#define ABS abs
#define MAX max
#define MIN min

// % by which a j is expected to dip below baseline (6/39)
#define RATIO_J_BELOW 0.15

// Ratio for how mych a regular below line letter dips (j, p, q, g, etc)
#define LETTER_BELOW_GAP_AS_PERCENT_OF_HEIGHT 0.21
#define LETTER_BELOW_GAP_AS_PERCENT_OF_HEIGHT_LOWHURDLE (LETTER_BELOW_GAP_AS_PERCENT_OF_HEIGHT * 0.90)

#define METRICS_ALMOSTTOUCHING 0.12

// Test if current r is the start of an element unique to URLs or emails
bool startURLorEmail (SmartPtr<OCRRect> r) {
    if (r != NULL) {
        // Test for http
        if ((toLower(r->ch) == 'h') && (r->next != NULL) && (toLower(r->next->ch) == 't') && (r->next->next != NULL) && (toLower(r->next->next->ch) == 't')
            && (r->next->next->next != NULL) && (toLower(r->next->next->next->ch) == 'p')) {
            return true;
        }
        // Test for www
        else if ((r->ch == 'w') && (r->next != NULL) && (r->next->ch == 'w') && (r->next->next != NULL) && (r->next->next->ch == 'w'))
        {
            return true;
        }
        // Test for .com
        // TODO need to test with other extensions. Consider just running the regex on the whole line.
        else if ((r->ch == '.') && (r->next != NULL) && (toLower(r->next->ch) == 'c') && (r->next->next != NULL) && (toLower(r->next->next->ch) == 'o') && (r->next->next->next != NULL) && (toLower(r->next->next->next->ch) == 'm'))
        {
            return true;
        }
        // Test for @
        else if (r->ch == '@')
        {
            return true;
        }
    }
    return false;
} // startURLorEmail

void OCRValidateCheckMissingSpaces(SmartPtr<OCRWord> line, OCRResults *results) {
	ReplacingLog("OCRValidateCheckMissingSpaces(): %s", toUTF8(line->text()).c_str());
    
    // Check for missing spaces we need to insert
    
    // Adding another pass for the case where first pass inserts space(s) which cause a reduction in the average spacing between letters, which in turn could cause us at round #2 to insert spaces where we had not previously.
    bool makeAnotherSpacingPass = true;
	for (int spaceRemovalRound=0; (spaceRemovalRound<2) && (makeAnotherSpacingPass); spaceRemovalRound++) {
		makeAnotherSpacingPass = false;

        SmartPtr<OCRRect> r = line->letters[0];
        r = r->next;
        while ((r != NULL) && (r->ch != '\n')) {
            // Fix confidence of outliers back
            if (r->confidence > 2000.0) {
                r->confidence -= 2000.0;
            } else if (r->confidence > 1000.0) {
                r->confidence -= 1000.0;
            }

        if ((r->ch == ' ') || (r->previous->ch == ' ') || (r->previous->ch == '\t')
            // NO_SPACE is our way to indicate we examined the letter and determined there can't be a space after it
            || (r->previous->flags2 & FLAGS2_NO_SPACE)) {
            // No need to insert a space, we are looking at one or there is one already just before current letter
            r = r->next;
            // Reset flag
            continue;
        }
        
//#if DEBUG
//        if ((r->ch =='J') && (r->previous != NULL) && (r->previous->ch == 'A') && (r->next != NULL) && (r->next->ch =='M')) {
//            SingleLetterTests *st = CreateSingleLetterTests(r->rect, results); if (st != NULL) delete st;
//            DebugLog("Found in [%s]", toUTF8(line->text()).c_str());
//            DebugLog("");
//        }
//#endif


        // 2015-10-03 inserting a space where none belongs in "$6.03" between 6 and . and between . and 0 - see
        // $ quality: 88 [410,55 - 422,76] w=12,h=22]
        // 6 [425,55 - 436,74] w=11,h=20]
        // . [443,71 - 446,74] w=3,h=4] (space=7)
        // 0 [452,56 - 464,74] w=12,h=19] (space=6)
        // 3 [466,56 - 478,74] w=12,h=19]
        // => using 7/19 = 0.37
        if ((line->averageHeightDigits.count > 0)
            // Current is a dot and previous was a digit
            && ((((r->ch == '.') || (r->ch == ',')) && (r->previous != NULL) && (isDigitLookalikeExtended(r->previous->ch)))
                // Current is a digit and previous was a dot
                || ((r->previous != NULL) && ((r->previous->ch == '.') || (r->previous->ch == ',')) && (isDigitLookalikeExtended(r->ch))))) {
            float referenceHeight = line->averageHeightDigits.average;
            float gap = rectSpaceBetweenRects(r->previous->rect, r->rect);
            // Because we are REALLY suspicious of spaces between dots and digits, try to cater for average digit height that is too low (yielding a gap / ref height too high, i.e. deemed a space)
            if (isDigit(r->previous->ch) && (r->previous->rect.size.height > referenceHeight))
                referenceHeight = r->previous->rect.size.height;
            if (isDigit(r->ch) && (r->rect.size.height > referenceHeight))
                referenceHeight = r->rect.size.height;
            if (gap / referenceHeight < 0.39) {
                // No space!
                r = r->next;
                continue;
            }
        }
        
        bool doit = false;
        
        // Handle commas
        if (r->previous->ch == ',') {
            // Example:
            // [, (0x2c)] at [763,185 - 768,194] [w=6,h=10]
            // [N (0x4e)] at [783,189 - 804,217] [w=22,h=29] (spacing = 14)
            // av. spacing = 4.7
            float spacing = rectSpaceBetweenRects(r->previous->rect, r->rect);
            if ((spacing > line->averageSpacing.average * 2)
                && (spacing > line->averageWidth.average * 0.75)) {
                doit = true;
            } else if ((line->averageWidthNormalLowercase.count > 3) && (spacing > line->averageWidthNormalLowercase.average * 0.40)) {
                // Examle: spacing = 6, averageWidthNormalLowercase = 13.4 => 0.448 x
                doit = true;
            }
        }
        
#if DEBUG
        // CJ072782CI81CJ0
        if ((r->ch == 'P') && (r->previous != NULL) && (r->previous->ch=='3')) {
            DebugLog("Found in [%s]", toUTF8(line->text()).c_str());
            DebugLog("");
        }
#endif        
        
        // Handle '&' - insert space if at end of line or if there is a space following
        if (((r->ch == '&') || (r->ch == 0xa3)) && ((r->next == NULL) || (r->next->ch == ' '))) {
            doit = true;
        }
        
        // Looking at a letter that's not a space, has a '&' before it (without space between) and that '&' has a space before it
        if (((r->previous->ch == '&') || (r->previous->ch == 0xa3)) && ((r->previous->previous == NULL) || (r->previous->previous->ch == ' '))) {
            doit = true;
        }
        
        // Handle '&' not surrounded by spaces
        // 0xa3 is the British pound sign, the special code we used when we are sure it's a '&', to prevent this character from being considered as a '8' (will ve replaced back later on)
        if (!doit) {
            float spacing = -1;
            if ((r->next != NULL) && ((r->next->ch == '&') || (r->next->ch == 0xa3))) {
                spacing = rectSpaceBetweenRects(r->rect, r->next->rect);
            } else if ((r->previous->ch == '&') || (r->previous->ch == 0xa3)) {
                spacing = rectSpaceBetweenRects(r->previous->rect, r->rect);
            }
            if (spacing > 0) {
                if (((line->averageWidthNormalLowercase.count > 3) && (spacing > line->averageWidthNormalLowercase.average * 0.50))
                    || ((line->averageWidthUppercase.count > 3) && (spacing > line->averageWidthUppercase.average * 0.40))) {
                    // Example: spacing = 7, averageWidthNormalLowercase = 12.33 => 0.568x x, average width uppercase = 15.125 => 0.46x
                    doit = true;
                }
            }
        }
    
        float gap = 0.0;
        float realGap = 0.0;
        float effectiveGap = 0.0;
        float gapDividedByPreviousCharWidth = 0.0;
        float gapDividedByAverageWidth = 0.0;
        float realGapDividedByAverageWidth = 0.0;
        float effectiveGapDividedByAverageWidth = 0.0;
        bool bothDigits = false;

        bool clearSpace = false;
        bool clearlyNoSpace = false; bool reallyClearSpace = false;
        
        if (!doit) {
            clearSpace = spacingAdjustCalculateValues(line, &results->retailerParams, r->previous, r, false, &gap, &realGap, &effectiveGap,
                    &gapDividedByPreviousCharWidth, &gapDividedByAverageWidth, &effectiveGapDividedByAverageWidth, &realGapDividedByAverageWidth, &bothDigits, &clearlyNoSpace, &reallyClearSpace, results);
        }
        
        // 2016-03-11 seems that for ANY retailer a gap that's more than the width of a digit IS a space. For example Kmart digit width is 14 and normal spacing is 14 - a wide marging of error!
        if (reallyClearSpace || ((results->globalStats.averageWidthDigits.average > 0) && (gap > results->globalStats.averageWidthDigits.average))) {
            doit = true;
        } else {
            // IMPORTANT: note how the above test supercedes the below, e.g. for Kmart actual spaces are 20, digit width is 7 and some gaps are found to be 10. These ARE spaces even though they exist because we missed a '.'. Still, it is fitting to make them a space so that our price checking code knows to look in the space for the missing '.'
            if (clearlyNoSpace || ((results->retailerParams.spaceWidthAsFunctionOfDigitWidth > 0) && (results->globalStats.averageWidthDigits.average > 0) && (gap < results->globalStats.averageWidthDigits.average * results->retailerParams.spaceWidthAsFunctionOfDigitWidth * 0.85))) {
                r = r->next;
                continue;
            }
        }
        
        if (!doit) {
            // Hard rules for inserting a space before or after any letter or digit NO MATTER what the other character may be
            OCRRectPtr refR;
            // Try to get a normal lowercase (not tall above or tall below)
            // First try left & right
            if (isLetterOrDigit(r->previous->ch)) {
                refR = r->previous;
                // If not a normal lowercase letter, try other side
                if ((!isLower(refR->ch) || isTallLowercase(refR->ch))
                    && (isLower(r->ch) && !isTallLowercase(r->ch))) {
                    refR = r;
                }
            } else if (isLetterOrDigit(r->ch)) {
                refR = r;
                // No need to inspect refR now, "previous" was already determined not to be a letter or digit
            }
            
            if ((refR == NULL) || !isLower(refR->ch) || isTallLowercase(refR->ch)) {
                // Try one letter removed on either side
                if ((r->previous->previous != NULL)
                    && (((refR == NULL) && isLetterOrDigit(r->previous->previous->ch))
                        || (isLower(r->previous->previous->ch) && !isTallLowercase(r->previous->previous->ch)))) {
                    refR = r->previous->previous;
                    // If not a normal lowercase letter, try other side
                    if ((!isLower(refR->ch) || isTallLowercase(refR->ch))
                        && ((r->next != NULL) && isLower(r->next->ch) && !isTallLowercase(r->next->ch))) {
                        refR = r->next;
                    }
                } else if ((r->next != NULL)
                           && (((refR == NULL) && isLetterOrDigit(r->next->ch))
                               || (isLower(r->next->ch) && !isTallLowercase(refR->next->ch)))) {
                    refR = r->next;
                    // No need to inspect refR now, "previous->previous" was already determined not to be a letter or digit
                }
            }
            
            float maxRelativeToHeight = 0.46;
            if (isLike1(r->previous->ch) || isLike1(r->ch))
                maxRelativeToHeight = 0.66;
            if ((refR != NULL) && (gap > refR->rect.size.height * maxRelativeToHeight)
                // Adding the below to prevent the addition of spaces everywhere where all letters are spaced
                && (effectiveGap > refR->rect.size.height * 0.15)
                && ((line->averageHeightUppercase.count < 1) || (effectiveGap > line->averageHeightUppercase.average * 0.15))
                && ((line->averageHeightNormalLowercase.count < 1) || (effectiveGap > line->averageHeightNormalLowercase.average * 0.20))) {
                doit = true;
            }
        }

            
        if (!doit
            // Accepting comma before
            && (isDigit(r->previous->ch) || isLetter(r->previous->ch) || (r->previous->ch == ','))
            && (isDigit(r->ch) || isLetter(r->ch))
            ) {

            doit = clearSpace;

            
            // It seems that if I don't stay away from '1', we added spaces everywhere for no reason => so test separately
            if (!doit && (isLike1(r->previous->ch) || isLike1(r->ch))) {
                if ((gapDividedByPreviousCharWidth > 1.4)
                    && (gapDividedByAverageWidth > 1.3)) {
                    doit = true;
                }
                else if (isLetter(r->previous->ch)
                    && (effectiveGapDividedByAverageWidth > 0.25)
                    && (realGapDividedByAverageWidth > 0.45)
                    && (effectiveGap > line->averageSpacing.average * (isLike1(r->previous->ch)? 1.14:1))) {
                    doit = true;
                }
                else {
                    r = r->next;
                    continue;
                }
            }

            if (!doit
                && (gapDividedByPreviousCharWidth > (isNarrow(r->previous->ch)? 0.88:0.35))
                && (gapDividedByAverageWidth > 0.36)
                && (effectiveGapDividedByAverageWidth > 0.29)
                && (realGapDividedByAverageWidth > 0.15)
                ) {

                // Assume we eliminating the space until proven otherwise
                doit = true;
                
                if (!line->isItalic()
                    && ((r->previous->ch == '1') || (r->previous->ch == 'l') || (r->previous->ch == '|') || (r->previous->ch == 'I'))
                    && (isDigit(r->ch) || (r->ch == 'l') || (r->ch == '|') || (r->ch == 'I'))) {
                    // '1' seems to be very special is what is perceived to be a space after it
                    if ((realGap < r->previous->rect.size.width * 1.05)
                        || ((line->averageWidthDigits.count >= 1) && (realGap < line->averageWidthDigits.average * 0.695))
                        )  {
                        doit = false;
                    }
                } else if (!line->isItalic()
                           && ((r->ch == '1') || (r->ch == 'l') || (r->ch == '|') || (r->ch == 'I'))
                           && (isDigit(r->previous->ch) || (r->previous->ch == 'l') || (r->previous->ch == '|') || (r->previous->ch == 'I') || (r->previous->ch == 'O'))) {
                    if ((realGap < r->rect.size.width * 1.05)
                        || ((line->averageWidthDigits.count >= 1) && (realGap < line->averageWidthDigits.average * 0.695))
                        )  {
                        doit = false;
                    }
                }
            }
        }
            
            if (doit) {
                DebugLog("Validate: rule 2000 spacing - inserting space between [%c] and [%c] in [%s]", (unsigned short)r->previous->ch, (unsigned short)r->ch, toUTF8(line->text()).c_str());
                char newCh = ' ';
                float newBottom = (rectTop(r->previous->rect) + rectTop(r->rect)) / 2;
                CGRect newRect(rectRight(r->previous->rect) + 1,
                               newBottom,
                               1,
                               1);
                line->addLetterWithRectConfidenceAfterRect(newCh, newRect, -1, r->previous);
                makeAnotherSpacingPass = true;
            }
                        
            if (r != NULL) r = r->next;
        } // check for missing spaces

    } // One or two rounds of checking for possibly inserting a space
} // OCRValidateCheckMissingSpaces

// This function is called once we are complely done with merging broken lines. Should contain all corrections which depend on looking at entire text lines. It's not yet the case, for example fixes for sequences of 11 digits + 1 non-digit in the middle (to fix into a valid UPC) should be here are aren't yet.
void OCRValidateFinalPass(SmartPtr<OCRWord> line, OCRResults *results) {
	ReplacingLog("OCRValidateFinalPass(): %s", toUTF8(line->text()).c_str());
	//for (int round=0; round<2; round++) {

        SmartPtr<OCRRect> r = line->letters[0];
        while ((r != NULL) && (r->ch != '\n')) {
        
            OCRWordPtr statsWithoutCurrent(new OCRWord(line));
            // Now remove current char
            statsWithoutCurrent->updateStatsAddOrRemoveLetterAddingSpacingOnly(r, false, false);
        
            // Check for missing dots in front of sub-$1.00 prices. Relevant in receipts only if retailer omits 0's in "0.XY" prices
            // TODO also do that in lines like "XYZ    60" (large space)
            // TODO also do that in lines like "1 60" (in case we just merged "1" with "60", after the missing dot rule)
            if ((results->retailerParams.noZeroBelowOneDollar)
                && (r->previous == NULL)
                && isDigitLookalikeExtended(r->ch)
                && ((r->next != NULL) && isDigitLookalikeExtended(r->next->ch))
                // We only seek to add a dot before the decimal part of a price, so can't have 3 digits
                && ((r->next->next == NULL) || !isDigitLookalikeExtended(r->next->next->ch))
                && !(r->flags & FLAGS_TESTED_DOT_BEFORE)) {
                r->flags |= FLAGS_TESTED_DOT_BEFORE;
                CGRect dotRect;
                if (findDotBetween(r->previous, r, line, dotRect, results)) {
                    r->word->addLetterWithRectConfidenceAfterRect(r->ch, r->rect, r->confidence, r);
                    r->word->updateLetterWithNewCharAndNewRect(r, '.', dotRect);
                }
            }
            
#if DEBUG
        if ((r->ch=='L') && (r->previous != NULL) && (r->previous->ch=='P') && (r->next != NULL) && (r->next->ch=='J') && (r->next->next != NULL) && (r->next->next->ch=='L')) {
//            CGRect newRect = computeCapturingRectRight(r, statsWithoutCurrent, results);
            SingleLetterTests *st = CreateSingleLetterTests(r->rect, results); if (st != NULL) delete st;
            DebugLog("Found it in [%s]", toUTF8(r->word->text()).c_str());
            DebugLog("");
        }
#endif
            
            // Narrow 'L' instead of '1'
            if ((r->ch == 'L') && (r->rect.size.width < results->globalStats.averageWidthDigits.average * 0.60)) {
                char newCh = '1';
                // Now so fast, could be a 'L'
                bool doit = true;
                CGRect actualRect = computeCapturingRectRight(r, statsWithoutCurrent, results);
                if (actualRect.size.width > 0) {
                    if (testAsL(r, actualRect, results, true)) {
                        doit = false;
                        r->word->updateLetterWithNewCharAndNewRect(r, r->ch, actualRect);
                    }
                }
                //  -------
                //0|       |
                //1| 1     |
                //2| 11    |
                //3| 11    |
                //4| 11    |
                //5| 11    |
                //6| 11    |
                //7| 11    |
                //8| 11    |
                //9| 11    |
                //a| 11    |
                //b| 11    |
                //c| 11    |
                //d| 1111  |
                //e|  1111 |
                //f|  1111 |
                //#|   1   |
                //#|       |
                //  -------
                // Also make sure middle is not aligned left as in the above
                if (doit) {
                    SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                    if (st != NULL) {
                        SegmentList slTop20 = st->getHorizontalSegments(0.20, 0.01);
                        SegmentList slTop40 = st->getHorizontalSegments(0.40, 0.01);
                        SegmentList slTop60 = st->getHorizontalSegments(0.60, 0.01);
                        if ((slTop20.size() == 1) && (slTop40.size() == 1) && (slTop60.size() == 1)) {
                            bool flushLeft20 = (slTop20[0].startPos <= results->globalStats.averageWidthDigits.average * 0.10) && (r->rect.size.width - slTop20[0].endPos > r->rect.size.width * 0.40);
                            bool flushLeft40 = (slTop40[0].startPos <= results->globalStats.averageWidthDigits.average * 0.10) && (r->rect.size.width - slTop40[0].endPos > r->rect.size.width * 0.40);
                            bool flushLeft60 = (slTop60[0].startPos <= results->globalStats.averageWidthDigits.average * 0.10) && (r->rect.size.width - slTop60[0].endPos > r->rect.size.width * 0.40);
                            int countFlush = (flushLeft20? 1:0) + (flushLeft40? 1:0) + (flushLeft60? 1:0);
                            if (countFlush >= 2)
                                doit = false;
                        } else {
                            doit = false;
                        }
                        delete st;
                    } else {
                        doit = false;
                    }
                }
                if (doit && (newCh != '\0')) {
                    ReplacingLog("OCRUtilsValidate: rule 0626 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                }
            }
        
            r = r->next;
        }
    //} // two rounds
} // OCRValidateFinalPass



#if OCR_ELIMINATE_NARROW_SPACES
void OCRValidateCheckSpuriousSpaces(SmartPtr<OCRWord> line, OCRResults *results) {
	ReplacingLog("OCRValidateCheckSpuriousSpaces(): %s", toUTF8(line->text()).c_str());
    
    SmartPtr<OCRRect> r;    // Used by code segments below
    
	// Test spaces which should be eliminated
	// Count spaces (used by next step)
	int numSpaces = 0;
	AverageWithCount spacesWidth = AverageWithCount();
	if (line->letters.size() < 1)
		return;
	r = line->letters[0];
	r = r->next;
	if ((line->averageWidth.count >= 3) && (line->averageWidth.average > 0)) {
		while ((r != NULL) && (r->ch != '\n')) {
        
#if DEBUG
        if ((r->ch == ' ') && (r->previous != NULL) && (r->previous->ch ==':') && (r->next != NULL) && (r->next->ch =='2')) {
            DebugLog("Found in [%s]", toUTF8(r->word->text()).c_str());
            SingleLetterTests *st = CreateSingleLetterTests(r->previous->rect, results);
            if (st != NULL) delete st;
            float minY = MIN(rectBottom(r->previous->rect), rectBottom(r->next->rect));
            float maxY = MAX(rectTop(r->previous->rect), rectTop(r->next->rect));
            CGRect spaceRect(rectRight(r->previous->rect)+1, minY, rectLeft(r->next->rect) - (rectRight(r->previous->rect)+1) + 1, maxY - minY + 1);
            st = CreateSingleLetterTests(spaceRect, results);
            if (st != NULL) delete st;
            st = CreateSingleLetterTests(r->next->rect, results);
            if (st != NULL) delete st;
            DebugLog("");
        }
#endif

			if (r->ch != ' ') {
                // Time for some tests which depend on correct spacing!
                // Replace 0'Malley with O'Malley
                if ((r->ch == '0') && ((r->previous == NULL) || (r->previous->ch == ' ')) && (r->next != NULL) && (r->next->ch == '\'')) 
                {
                    // Check if rest of word is all letters (and that there are at least 3
                    int countLettersInWord = 0;
                    SmartPtr<OCRRect> tmpR = r->next->next;
                    while ((tmpR != NULL) && isLetter(tmpR->ch)) {
                        countLettersInWord++;
                        tmpR = tmpR->next;
                    }
                    if (countLettersInWord >= 3) {
                        char newCh = 'O';
                        ReplacingLog("OCRUtilsValidate: rule 0527 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                        r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                    }
                }
            
				r = r->next;
				continue;
			}
            
            // Solid dot - don't worry about adding / removing spaces, we are splitting into two words later anyhow
            if ((r->previous != NULL) && (r->previous->ch == 0xa7)) {
                r = r->next;
                continue;
            } else if ((r->next != NULL) && (r->next->ch == 0xa7)) {
                r = r->next->next;
                continue;
            }
            
#if DEBUG
            // 20.33 :48
            if ((r->previous != NULL) && (r->previous->ch =='3') && (r->next != NULL) && (r->next->ch ==':')) {
                DebugLog("Found in [%s]", toUTF8(r->word->text()).c_str());
                DebugLog("");
            }
#endif
            
            if (r->next == NULL) {
                // Remove that space
                ReplacingLog("validateLine: spacing - eliminating space at the end of [%s]", toUTF8(r->word->text()).c_str());
                // We don't keep spaces in columns or lines I think, so just remove from page
                // Eliminate the spurious space
                // There is a space next, just remove
                SmartPtr<OCRRect> p = r->next; // Save r->next
                r->word->removeLetter(r);
                r = p;
                numSpaces--;
                // continue with next letter
                continue;
            }

			numSpaces++;
			spacesWidth = OCRStats::updateAverageWithValueAdding(spacesWidth, (rectLeft(r->next->rect)-rectRight(r->previous->rect)-1), true);

			// Handle spaces preceeded  by a non-delimiter and followed by a non-delimiter - test that space
			// In fact, one should probably remove spaces before '.' aggressively.
			// Note: could test for '&' because that one is usually meant to be surrounded by spaces
			if (r->confidence != -1) {
#if DEBUG
				if ((r->previous != NULL) && (r->previous->ch=='1') && (r->previous->previous != NULL) && (r->previous->previous->ch=='3')
					&& (r->next != NULL) && (r->next->ch =='7')) {
                    DebugLog("Found in [%s]", toUTF8(r->word->text()).c_str());
                    DebugLog("");
				}
				if ((r->previous != NULL) && (r->previous->ch=='0')
					&& (r->next != NULL) && (r->next->ch =='.') && (r->next->next != NULL) && (r->next->next->ch =='L')) {
                    DebugLog("Found in [%s]", toUTF8(r->word->text()).c_str());
					DebugLog("");
				}
#endif
				float gap;
				float realGap;
				float effectiveGap;
				float gapDividedByPreviousCharWidth;
				float gapDividedByAverageWidth;
				float realGapDividedByAverageWidth;
				float effectiveGapDividedByAverageWidth;
				bool bothDigits;
                bool clearlyNoSpace = false, reallyClearSpace = false;

                bool hadSpaceBetween = (r->ch == ' ');
				bool clearSpace = spacingAdjustCalculateValues(line, &results->retailerParams, r->previous, r->next, false, &gap, &realGap, &effectiveGap,
                    &gapDividedByPreviousCharWidth, &gapDividedByAverageWidth, &effectiveGapDividedByAverageWidth,
					&realGapDividedByAverageWidth, &bothDigits, &clearlyNoSpace, &reallyClearSpace, results);
                // Check for special case where we are testing a space and spacingAdjustCalculateValues instead chose to create a character in the intervening space
                if (hadSpaceBetween && (r->ch != ' ')) {
                    r = r->next;
                    continue;
                }
				bool doit = clearlyNoSpace;
                
                // 2015-09-27 missing price following quantity ("$7 . 49")whereby both spaces = 6 vs digit height 21 (using 7/20 = 0.35)
                // Actually using 7/19 = 0.37, see https://www.pivotaltracker.com/story/show/104739396 where gap between $6.03 was 7 with height 19 and still NOT a space
                if ((line->averageHeightDigits.count > 0)
                    && ((((r->previous->ch == '.') || (r->previous->ch == ',')) && (isDigitLookalikeExtended(r->next->ch)))
                        || (((r->next->ch == '.') || (r->next->ch == ',')) && (isDigitLookalikeExtended(r->previous->ch))))) {
                    float referenceHeight = line->averageHeightDigits.average;
                    // Because we are REALLY suspicious of spaces between dots and digits, try to cater for average digit height that is too low
                    if (isDigit(r->previous->ch) && (r->previous->rect.size.height > referenceHeight))
                        referenceHeight = r->previous->rect.size.height;
                    if (isDigit(r->ch) && (r->rect.size.height > referenceHeight))
                        referenceHeight = r->rect.size.height;
                    if (gap / referenceHeight < 0.39) {
                        ReplacingLog("validateLine: rule 1001 spacing - eliminating too narrow space between [%c] and [%c] in [%s] based on spacing around dot",
								 (unsigned short)r->previous->ch, (unsigned short)r->next->ch, toUTF8(r->word->text()).c_str());
#if DEBUG
                        if (r->word->text() == L"02$38846 7747") {
                            DebugLog("");
                        }
#endif
                        doit = true;
                    }
                }
                
                if (!doit && ((r->previous->ch == '.') || (r->previous->ch == ',')) && ((r->next->ch == '.') || (r->next->ch == ','))) {
                    // If not clearly not a space and delimiters, skip (because we are afraid to interfere ...)
                    r = r->next;
                    continue;
                }
                
                // This is a cop out, saying we are afraid to weigh in on spacing between non-letters ... we have to jump in the water at some point
                if (!doit && isDelimiter(r->previous->ch) && isDelimiter(r->next->ch)) {
					r = r->next;
					continue;
                }
                
                if (((r->previous->ch == '.') || (r->next->ch == '.'))
                    && (effectiveGapDividedByAverageWidth < 0.40)) {
                    doit = true;
                }
                
                if (clearSpace && !doit) {
					r = r->next;
					continue;
				}
				float maxRatioEffectiveGapToAverageWidth = 0.208;
				if ((r->next->ch == '.') || (r->next->ch == '_') || (r->next->ch == '-'))
					maxRatioEffectiveGapToAverageWidth = 0.22;

				float minValidSpaceRatioGapToAverageWidth = 0;
				if (bothDigits) {
					minValidSpaceRatioGapToAverageWidth = 0.51;
				}

				if (!doit && !line->isItalic()
                    && ((line->averageSpacing.count < 3) || (gap < line->averageSpacing.average * 3))
                    && (gapDividedByAverageWidth < minValidSpaceRatioGapToAverageWidth)) {
					doit = true;
				}
				else if (!doit && !line->isItalic()
					&& ((r->previous->ch == '1') || (r->previous->ch == 'l') || (r->previous->ch == '|') || (r->previous->ch == 'I'))
					    && (isDigit(r->next->ch) || (r->next->ch == 'l') || (r->next->ch == '|') || (r->next->ch == 'I'))) {
					if ((realGap < r->previous->rect.size.width * 1.05)
						|| ((line->averageWidthDigits.count >= 1) && (realGap < line->averageWidthDigits.average * 0.695))
						)  {
						doit = true;
					}
				}
                else if (!doit && !line->isItalic()
						   && ((r->next->ch == '1') || (r->next->ch == 'l') || (r->next->ch == '|') || (r->next->ch == 'I'))
						   && (isDigit(r->previous->ch) || (r->previous->ch == 'l') || (r->previous->ch == '|') || (r->previous->ch == 'I'))) {
					if ((realGap < r->next->rect.size.width * 1.05)
						|| ((line->averageWidthDigits.count >= 1) && (realGap < line->averageWidthDigits.average * 0.695))
						)  {
						doit = true;
					}
				}
				else if (!doit
                    // If the series of test does NOT hold true, this space is suspect. In other words, if all 3 'and' tests below are met, this must be a valid space and we should leave it alone
                    && !( ((line->averageSpacing.average <= 0) 
                               // We have expectations from the actual gap ONLY if not an italic line with negative average spacing, otherwise only the effective gap (adjusted for the av. spacing) should be examined)
                            || ((gapDividedByPreviousCharWidth > (isNarrow(r->previous->ch)? 0.88:0.35))
					            && (gapDividedByAverageWidth > 0.37)))
					      && (effectiveGapDividedByAverageWidth > 0.29)
					      && (realGapDividedByAverageWidth > 0.15)
					    )
				    // Effective gap is the actual gap minus the average spacing between adjacent letters
					// We expect a real space to show a spacing larger than the normal spacing on that line by a certain marging
					&& ( (effectiveGapDividedByAverageWidth < maxRatioEffectiveGapToAverageWidth)
                         || (gapDividedByAverageWidth < 0.39)
                         || ((gapDividedByAverageWidth < 0.446) && (effectiveGapDividedByAverageWidth < 0.345))
                         || ((r->previous != NULL) && (r->previous->ch == '1') && (r->next->ch == '1') && (effectiveGap < r->next->rect.size.width*0.92))
                       ) ) {
					doit = true;
				}

				if (doit) {
					// Remove that space
					ReplacingLog("validateLine: rule 1000 spacing - eliminating too narrow space between [%c] and [%c] in [%s] ratio=%.3f",
								 (unsigned short)r->previous->ch, (unsigned short)r->next->ch, toUTF8(r->word->text()).c_str(), effectiveGap/line->averageWidth.average);
					// We don't keep spaces in columns or lines I think, so just remove from page
					// Eliminate the spurious space
                    // There is a space next, just remove
                    SmartPtr<OCRRect> p = r->next; // Save r->next
                    r->word->removeLetter(r);
                    r = p;
					numSpaces--;
					// continue with next letter
					continue;
				} 
            }
			r = r->next;
		}
	}
    // End - eliminate spaces that are too narrow
} // OCRValidateCheckSpuriousSpaces
#endif // OCR_ELIMINATE_NARROW_SPACES

// Goes over a word and applies various corrections
void OCRValidate(SmartPtr<OCRWord> line, OCRResults *results) {
	ReplacingLog("OCRValidate(): %s", toUTF8(line->text()).c_str());
	
	if (line->count() == 0)
		return; // Nothing to do, empty input
		
	SmartPtr<OCRRect> r = line->letters[0];

	/* Preparations:
	 - Eliminate outliers to ignore large logo-type letters
	 - Detect all-uppercase or all-lowercase lines
	 - Calculate max height
	 */
    
     bool upsideDown = true;    // Simply states that lower Y values are on top of the image

	int numLowercase = 0; int numUppercase = 0; int numLowercaseLookingLikeUppercase = 0;
	float minHeight = 20000; float maxHeight = -1; float maxCharHeight = -1;
	bool sameHeightLowercase = false; bool sameHeightUppercase = false;
	bool allUpperCase = true; bool smallCap = true; bool uppercaseFirstLetters = true; bool sameHeightExceptFirst = true;
    float max7TopWidth = 0, max7Width = 0;
    AverageWithCount heightExceptFirst = AverageWithCount(); // Used to remember the height of all letters except first letter
	SmartPtr<OCRRect> tmpR;
	tmpR = r;
	int i=0;
    bool removedLeading = false;
	while ((tmpR != NULL) && (tmpR->ch != '\n')) {
        
        // Special check for space even though spacing is 0 ... yes, it happens
        if ((tmpR->next != NULL) && (tmpR->previous != NULL) && (tmpR->ch == ' ')) {
            float spaceB = rectLeft(tmpR->next->rect) - rectRight(tmpR->previous->rect) - 1;
            if (spaceB <= 0) {
                ReplacingLog("Validate: eliminating bogus zero-width space from line [%s] at index [%d]", toUTF8(line->text()).c_str(), i);
                SmartPtr<OCRRect> p = tmpR->next; // Save r->next
                tmpR->word->removeLetter(tmpR);
                tmpR = p;
                ReplacingLog("New text is [%s]", toUTF8(line->text()).c_str());
                i++;
                continue;
            }
        }
        
        OCRWordPtr statsWithoutCurrent(new OCRWord(line));
		// Now remove current char
		statsWithoutCurrent->updateStatsAddOrRemoveLetterAddingSpacingOnly(tmpR, false, false);

		// Special  check for single character at line start followed by a space that is many time the average letter width of the rest of the word
		// Just remove this char: probably N/A letter from a logo
        if (!results->retailerParams.hasDetachedLeadingChar) {
            if ((i == 0) && (tmpR->next != NULL) && (tmpR->next->ch == ' ') && (tmpR->next->next != NULL)) {
                float spaceWithNext = rectSpaceBetweenRects(tmpR->rect, tmpR->next->next->rect);
                if ( ((statsWithoutCurrent->averageWidthUppercase.count > 1) && (spaceWithNext > statsWithoutCurrent->averageWidthUppercase.average * 3))
                    || ((statsWithoutCurrent->averageWidthNormalLowercase.count > 1) && (spaceWithNext > statsWithoutCurrent->averageWidthNormalLowercase.average * 4)) ) {
                    // Remove current and next (space)
                    ReplacingLog("Validate: removing detached leading char [%lc] from line [%ls]", tmpR->ch, line->text().c_str());
                    tmpR = tmpR->next->next;
                    // Important to remove the large letter first and then the space otherwise it mistakenly account for spacing till next letters as a real space
                    tmpR->word->removeLetter(tmpR->previous->previous);
                    tmpR->word->removeLetter(tmpR->previous);
                    i++;
                    continue;
                    // Note: could recurse, I think we are OK with it
                }
            }
        } // not expecting isolated leading chars at line start
        
        if (sameHeightExceptFirst) {
            // If first letter, demand it be taller (or same height)
            if ((tmpR->previous != NULL) && (tmpR->previous->ch == ' ')) {
                if (tmpR->rect.size.height < heightExceptFirst.average * 0.95) {
                    sameHeightExceptFirst = false;
                }
            } // Don't do anything with the very first letter on the line 
            else if ((tmpR->previous != NULL) 
                // Ignore non-letters
                && isLetterOrDigit(tmpR->ch))
            {
                // We have stats
                if ((heightExceptFirst.count > 0)
                    && ((tmpR->rect.size.height < heightExceptFirst.average * 0.88) || (tmpR->rect.size.height > heightExceptFirst.average * 1.12))) {
                    sameHeightExceptFirst = false;
                } else {
                    // Update stats
                    heightExceptFirst.sum += tmpR->rect.size.height;
                    heightExceptFirst.count ++;
                    heightExceptFirst.average = (heightExceptFirst.sum / heightExceptFirst.count);
                }
            }
        }
		
        // We assume uppercaseFirstLetters unless proven otherwise
        if (uppercaseFirstLetters 
            && ((r->previous == NULL) || (r->previous->ch == ' '))
            && isLower(tmpR->ch)) {
            uppercaseFirstLetters = false; 
        }
            
		if (allUpperCase && (isLetter(tmpR->ch) && !isUpper(tmpR->ch))) {
			allUpperCase = false;
			smallCap = false;
		}
		if (smallCap) {
			if ((tmpR->previous != NULL) && isLetter(tmpR->previous->ch)
			    && ((tmpR->previous->previous == NULL) || (tmpR->previous->previous->ch == ' '))) {
				// We are the letter after a letter, and before that letter is start of line or blank: time to test smallcap
				if (tmpR->rect.size.height > tmpR->previous->rect.size.height * 0.88) {
					smallCap = false;
				}
			}
		}

		if ((tmpR->ch != ' ') && (tmpR->ch != '\t')) {
#define MIN_COUNT_AV 4
			// Find the maximum average values among those that match the min count requirement
			float maxHeightAverage = 0; int maxHeightAverageCount = 0; float maxWidthAverage = 0; int maxWidthAverageCount = 0;

			if (statsWithoutCurrent->averageHeightUppercase.count > MIN_COUNT_AV) {
				maxHeightAverage = MAX(maxHeightAverage, statsWithoutCurrent->averageHeightUppercase.average);
			}
			if (statsWithoutCurrent->averageHeightDigits.count > MIN_COUNT_AV) {
				maxHeightAverage = MAX(maxHeightAverage, statsWithoutCurrent->averageHeightDigits.average);
			}
			if (statsWithoutCurrent->averageHeightTallLowercase.count > MIN_COUNT_AV) {
				maxHeightAverage = MAX(maxHeightAverage, statsWithoutCurrent->averageHeightTallLowercase.average);
			}
			if (statsWithoutCurrent->averageHeightNormalLowercase.count > MIN_COUNT_AV) {
				maxHeightAverage = MAX(maxHeightAverage, statsWithoutCurrent->averageHeightNormalLowercase.average);
			}
			if (statsWithoutCurrent->averageWidthUppercase.count > MIN_COUNT_AV) {
				maxWidthAverage = MAX(maxWidthAverage, statsWithoutCurrent->averageWidthUppercase.average);
                maxWidthAverageCount += statsWithoutCurrent->averageWidthUppercase.count;
			}
			if (statsWithoutCurrent->averageWidthDigits.count > MIN_COUNT_AV) {
				maxWidthAverage = MAX(maxWidthAverage, statsWithoutCurrent->averageWidthDigits.average);
                maxWidthAverageCount += statsWithoutCurrent->averageWidthDigits.count;
			}
			if (statsWithoutCurrent->averageWidthLowercase.count > MIN_COUNT_AV) {
				maxWidthAverage = MAX(maxWidthAverage, statsWithoutCurrent->averageWidthLowercase.average);
                maxWidthAverageCount += statsWithoutCurrent->averageWidthLowercase.count;
			}
            
#if DEBUG
            if ((tmpR->previous == NULL) && (tmpR->next != NULL) && (tmpR->next->ch == ' ') && (tmpR->next->next != NULL) && (tmpR->next->next->ch =='1')) {
                DebugLog("Found it");
            }
#endif       
            
            // eliminate tall leading letter
            // Only for first char (that's where we tend to have spurious stuff from non-text elements)
            if ((tmpR->previous == NULL) && !removedLeading
                // Plenty of digits or uppercase letters
                && (statsWithoutCurrent->averageHeightDigits.count + statsWithoutCurrent->averageHeightUppercase.count >= 4)
                && (tmpR->rect.size.height > statsWithoutCurrent->averageHeightDigits.average * 1.8) && (tmpR->rect.size.height > statsWithoutCurrent->averageHeightUppercase.average * 1.8)) {
                // Also test that the space after is significant
                float spaceBetween = -1;
                if (tmpR->next != NULL) {
                    if (tmpR->next->ch != ' ')
                        spaceBetween = rectSpaceBetweenRects(tmpR->rect, tmpR->next->rect);
                    else if (tmpR->next->next != NULL) {
                        spaceBetween = rectSpaceBetweenRects(tmpR->rect, tmpR->next->next->rect);
                    }
                }
                float relevantHeight = (statsWithoutCurrent->averageHeightDigits.average + statsWithoutCurrent->averageHeightUppercase.average) / 2;
                float gapBelowLine = gapBelow(tmpR, 2, statsWithoutCurrent);
                if ((spaceBetween > relevantHeight * 0.75)
                    || ((spaceBetween > relevantHeight * 0.50) && ((isLetter(tmpR->ch) && !isTallBelow(tmpR->ch)) || isDash(tmpR->ch)) && (gapBelowLine > relevantHeight * 0.33))) {
                    // Remove alltogether!
                    ReplacingLog("Validate: rule 0059 replacing - eliminating leading [%c] in word [%s], way too tall (%d pixels)", (unsigned short)r->ch, toUTF8(r->word->text()).c_str(), (unsigned int)r->rect.size.height);
                    SmartPtr<OCRRect> p = tmpR->next;
                    tmpR->word->removeLetter(tmpR);
                    tmpR = p;
                    removedLeading = true;
                    continue;
                }
            }
            
            // Silly to treat as "outlier" a lone tall lowercase within a line with only low lowercase!
            if (!(isTallLowercase(tmpR->ch)
                  // Plenty of reference normal (e.g. low) lowercase letters
                  && (statsWithoutCurrent->averageHeightNormalLowercase.count > 2)
                  // 1.75 is a tad above the normal ration between lowercase and tall lowercase (usually 1.5)
                  && (tmpR->rect.size.height < statsWithoutCurrent->averageHeightNormalLowercase.average * 1.75)))
            {
                float outlierHeightRatio;
                if ((line->nTallLettersInLine - line->nUppercaseLookingLikeLowercase) >= 2) {
                    outlierHeightRatio = 1.20;
                    maxHeightAverage = MAX(statsWithoutCurrent->averageHeightUppercase.average, statsWithoutCurrent->averageHeightDigits.average);
                    maxHeightAverage = MAX(maxHeightAverage, statsWithoutCurrent->averageHeightTallLowercase.average);

                    maxHeightAverageCount = statsWithoutCurrent->averageHeightUppercase.count + statsWithoutCurrent->averageHeightDigits.count + statsWithoutCurrent->averageHeightTallLowercase.count;
                } else {
                    outlierHeightRatio = 2.0;
                }
                if (((maxHeightAverage > 0) && (tmpR->rect.size.height > maxHeightAverage * outlierHeightRatio))
                        || ((maxWidthAverage > 0) && ((tmpR->rect.size.width > maxWidthAverage * 2.0)
                                                      // Also remove leading letter if 1.8x taller than upper & digits, with a real space after it
                                                      || ((statsWithoutCurrent->averageHeightDigits.count + statsWithoutCurrent->averageHeightUppercase.count >= 4) && (tmpR->rect.size.height > statsWithoutCurrent->averageHeightDigits.average * 1.8) && (tmpR->rect.size.height > statsWithoutCurrent->averageHeightUppercase.average * 1.8)))))
                {
                    if ((tmpR->previous == NULL) && !removedLeading
                        && ( ((maxHeightAverageCount >= 5) && ((tmpR->rect.size.height > maxHeightAverage * 3) || (tmpR->rect.size.width > maxHeightAverage * 3)))
                             || ((maxWidthAverageCount >= 5) && ((tmpR->rect.size.width > maxWidthAverage * 3) || (tmpR->rect.size.width > maxWidthAverage * 3)))
                           )) {
                            // Remove alltogether!
                            ReplacingLog("Validate: rule 0059 replacing - eliminating leading [%c] in word [%s], way too wide (%d pixels)", (unsigned short)r->ch, toUTF8(r->word->text()).c_str(), (unsigned int)r->rect.size.width);
                            SmartPtr<OCRRect> p = tmpR->next;
                            tmpR->word->removeLetter(tmpR);
                            tmpR = p;
                            removedLeading = true;
                            continue;
                    } else {
                        ReplacingLog("Removing outlier [%c] from stats in [%s] at index [%d]", (unsigned short)tmpR->ch, toUTF8(line->text()).c_str(), i);
                        // Undo space stats with next character
                        if (tmpR->next != NULL)
                            tmpR->word->updateStatsAddOrRemoveLetterAddingSpacingOnly(tmpR->next, false, true);
                        tmpR->word->updateStatsAddOrRemoveLetterAddingSpacingOnly(tmpR, false, false);
                        tmpR->flags |= FLAGS_OUTLIER;
                        if (outlierHeightRatio < 2.0) {
                            tmpR->confidence += 1000.0;	// Remember that we already excluded this one from stats when it comes time to calculate statsWithoutCurrent!
                        } else {
                            tmpR->confidence += 2000.0;	// Exclude from stats - BUT still validate it
                        }
                    }
                }
            }
        }
        
        // Ignore outliers for stats below
        if (tmpR->confidence < 1000) {
            if (tmpR->rect.size.height > maxCharHeight)
                maxCharHeight = tmpR->rect.size.height;
            if (isLetter(tmpR->ch)) {
                if (tmpR->rect.size.height < minHeight)
                    minHeight = tmpR->rect.size.height;
                if (tmpR->rect.size.height > maxHeight)
                    maxHeight = tmpR->rect.size.height;
                if (isupper(tmpR->ch))
                    numUppercase++;
                else {
                    numLowercase++;
                    if (looksSameAsUppercase(tmpR->ch, results)) {
                        numLowercaseLookingLikeUppercase++;
                    }
                }
            }
        }

        statsWithoutCurrent.setNull();
		tmpR = tmpR->next;
		i++;
	}
    
    // Determine if we are at the start of a digits sequence, as defined by 2 or more digits in the current word

	if (maxHeight/minHeight < 1.08) {
		if ((numLowercase - numUppercase) > 1) {
			sameHeightLowercase = true;
			ReplacingLog("Validate: got all-lowercase line [%ls]", line->text().c_str());
		} else if ((numUppercase - numLowercase) > 1) {
			sameHeightUppercase = true;
			ReplacingLog("Validate: got all-uppercase line [%ls]", line->text().c_str());
		}
	}
	
	// Set referenceHeight here in case we need to call suggestLetterReplacement within the validate loop
	float maxHeightForSingleLetter = maxCharHeight;
	float referenceHeight = maxApplicableHeight(line);
	if (referenceHeight != 0) {
		maxHeightForSingleLetter = MIN(referenceHeight, maxHeightForSingleLetter);
	}

	// We are doing (up to) two passes, because sometimes one subst adjusts average and helps a PREVIOUS letter, or we create 2 V's and need to go back to convert them to W
	bool makeAnotherPass = true;
    
    // Make a first pass for replacements that must be done early. For example, "--" to '-' needs to be done early, befofe a rule tries to analyze "C-" in a "C--" pattern
    // Iterate over all rects
    r = line->letters[0];
    while ((r != NULL) && (r->ch != '\n')) {
        // "--" instead of '-'
        if ((r->ch == '-') && (r->next != NULL) && (r->next->ch == '-') && (rectSpaceBetweenRects(r->rect, r->next->rect) <= 0)) {
            replaceTwo(r, '-', "rule 0613");
            continue;
        }
        if (r != NULL) r = r->next;
    }
    
    bool lineHasRealAs = false;
    int numGluedDots = 0;           // How many dots on this line are glued to the letter just before them? For rule 0498
    int numDisconnectedDots = 0;    // How many dots on this line are NOT glued to the letter just before them? For rule 0498
    bool digitsOnly = false;
    bool startPrice = false;
    int countCharsInCurrentWord = 0;    // Only used in digitsOnly sequences, to determine for example if two chars combined make up one digits (if which case we would expect 10 chars instead of 9 expected in a product number)
    int countDigitLookAlikesInCurrentWord = 0;
    int countLastDigitsSequence = 0;
	for (int round=0; (round<2) && (makeAnotherPass); round++) {
        bool testUAnyhow = false;
		makeAnotherPass = false;
		float spaceBetween;	// Just a tmp variable so it's defined in entire scope
        float gapBelowBaseline = -1000;	// Just a tmp variable so it's defined in entire scope
        digitsOnly = false;
        countCharsInCurrentWord = countDigitLookAlikesInCurrentWord = 0;
        countLastDigitsSequence = 0;
        //float newHeight;    // Just a tmp variable so it's defined in entire scope
		// Iterate over all rects
		r = line->letters[0];
		if (r == NULL)
			return;
		
        float maxHeightLettersCurrentWord = 0;
		SmartPtr<OCRWord> statsWithoutCurrent;
        SmartPtr<OCRWord> statsWithoutCurrentAndNext;
		SmartPtr<OCRWord> statsWithoutCurrentAndNextTwo;
		while ((r != NULL) && (r->ch != '\n')) {
        
            // Eliminate spurious spaces between touching letters!
            if ((r->ch == ' ') && (r->next != NULL) && (r->next->ch != ' ') && (r->previous != NULL) && (r->previous->ch != ' ')) {
                if (rectSpaceBetweenRects(r->previous->rect, r->next->rect) <= 0) {
                    ReplacingLog("Validate: rule 0540 replacing - eliminating zero-width space after [%c] in word [%s]", (unsigned short)r->previous->ch, toUTF8(r->word->text()).c_str());
                    SmartPtr<OCRRect> tmpR = r->next;
                    r->word->removeLetter(r);
                    r = tmpR;
                    continue;
                }
            }
            
            // Space indicates we are ending a possible digits only sequence
            if ((r->ch == ' ') || (r->ch == '\t') || (r->ch == '\n')) {
                digitsOnly = false;
                countCharsInCurrentWord = countDigitLookAlikesInCurrentWord = 0;
                countLastDigitsSequence = 0;
            }
        
			if ((r->confidence == 0) || (r->ch == ' ') || (r->rect.size.width < 2)) {
#if DEBUG
				if ((r->confidence == 0) && (r->ch != ' '))
					ReplacingLog("Not validating [%c], protected by cost=0", r->ch);
#endif

                // End of a word - reset maxHeightLettersCurrentWord
                maxHeightLettersCurrentWord = 0;
				r = r->next;
				continue;
			}

//#if DEBUG
//			if ((r->previous != NULL) && (r->previous->ch=='r') &&  (r->previous->previous != NULL) && (r->previous->previous->ch == 'e')) {
//				DebugLog("Found it");
//			}
//#endif

			if (statsWithoutCurrent != NULL)
				statsWithoutCurrent.setNull();

			statsWithoutCurrent = SmartPtr<OCRWord>(new OCRWord(line));
			// Now remove current char
			if ((r->confidence < 1000) && (!(r->flags & FLAGS_OUTLIER))) {
				// Not a outlier we already removed
				statsWithoutCurrent->updateStatsAddOrRemoveLetterAddingSpacingOnly(r, false, false);
			}

			if (statsWithoutCurrentAndNext != NULL)
				statsWithoutCurrentAndNext.setNull();
			statsWithoutCurrentAndNext = OCRWordPtr(new OCRWord(statsWithoutCurrent));
			// Now remove next char (if not an ignored outlier)
			if ((r->next != NULL) && (r->next->confidence < 1000) && (!(r->next->flags & FLAGS_OUTLIER)))
				statsWithoutCurrentAndNext->updateStatsAddOrRemoveLetterAddingSpacingOnly(r->next, false, false);

			if (statsWithoutCurrentAndNextTwo != NULL)
				statsWithoutCurrentAndNextTwo.setNull();

			statsWithoutCurrentAndNextTwo = OCRWordPtr(new OCRWord(statsWithoutCurrentAndNext));

			// Now remove next next char (if not already an ignored outlier)
			if ((r->next != NULL) && (r->next->next != NULL) && (r->next->next->confidence < 1000))
				statsWithoutCurrentAndNextTwo->updateStatsAddOrRemoveLetterAddingSpacingOnly(r->next->next, false, false);
            
//#if DEBUG
//            if (r->ch =='_') {
//                DebugLog("Found");
//            }
//#endif    

            OCRVerboseLog("OCRValidate: about to remove very large letters");
            // Remove very large letter anywhere
            if (((statsWithoutCurrent->averageWidth.count >= 5) && (r->rect.size.width > statsWithoutCurrent->averageWidth.average * 5))
                || ((statsWithoutCurrent->averageHeight.count >= 5) && (r->rect.size.height > statsWithoutCurrent->averageWidth.average * 5))) {
                ReplacingLog("Validate: rule 0186 replacing - eliminating huge letter [%c] in word [%s], way too wide (%d pixels) or tall (%d pixels)", (unsigned short)r->ch, toUTF8(r->word->text()).c_str(), (unsigned int)r->rect.size.width, (unsigned int)r->rect.size.height);
                SmartPtr<OCRRect> tmpR = r->next;
                r->word->removeLetter(r);
                r = tmpR;
                continue;
            }
            
            // Remove very large trailing letter, often glued there for no reason
            if ((r->next == NULL)
                && (((statsWithoutCurrent->averageWidth.count > 3) && (r->rect.size.width > statsWithoutCurrent->averageWidth.average * 5))
                    || ((statsWithoutCurrent->averageWidthNormalLowercase.count > 3) && (r->rect.size.width > statsWithoutCurrent->averageWidthNormalLowercase.average * 4))
                    || ((statsWithoutCurrent->averageWidthDigits.count > 2) && (r->rect.size.width > statsWithoutCurrent->averageWidthDigits.average * 6))
                    || ((statsWithoutCurrent->averageWidthUppercase.count > 2) && (r->rect.size.width > statsWithoutCurrent->averageWidthUppercase.average * 4))
                    )
                ) {
                ReplacingLog("Validate: rule 0056 replacing - eliminating trailing [%c] in word [%s], way too wide (%d pixels)", (unsigned short)r->ch, toUTF8(r->word->text()).c_str(), (unsigned int)r->rect.size.width);
                SmartPtr<OCRRect> tmpR = r->next;
                r->word->removeLetter(r);
                r = tmpR;
                continue;
            }
            
            // Don't validate the more extreme case of outliers (2x larger)
			if (r->confidence > 2000.0) {
				ReplacingLog("Not validating [%c], outlier", (unsigned short)r->ch);
				r = r->next;
				continue;
			}
            
#if DEBUG
            wstring text = r->word->text();
            if (text == L"3.19") {
                DebugLog("Found in [%s]", toUTF8(r->word->text()).c_str());
                DebugLog("");
            }
#endif

//#if DEBUG
//            if ((r->next != NULL) && (r->next->ch =='1') && (r->previous != 0) && (r->previous->ch == '$') && (r->next->next != NULL) && (r->next->next->ch == '.')) {
//                DebugLog("Found in word [%s]", toUTF8(r->word->text()).c_str());
//                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
//                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results, SINGLE_LETTER_VALIDATE_SINGLE_COMP);
//                delete st;
//                DebugLog("");
//            }
//#endif
            
            // Look ahead to determine if we are in a digits sequence, as determined by at least 4 consecutive digits
            // Also determine if current char is the start of a price (xx.yy)
            if (!digitsOnly && ((r->previous == NULL) || ((r->previous->ch == ' ') || (r->previous->ch == '\t') || (r->previous->ch == '\n')))) {
                SmartPtr<OCRRect> p = r;
                int countDigits = 0;
                countCharsInCurrentWord = countDigitLookAlikesInCurrentWord = countLastDigitsSequence = 0;
                startPrice = false;
                int numDots = 0;
                int countDigitsBeforeDot = 0, countDigitsAfterDot = 0;
                while ((p != NULL) && (p->ch != ' ') && (p->ch != '\t') && (p->ch != '\n')) {
                    if (isDigitLookalikeExtended(p->ch))
                        countDigitLookAlikesInCurrentWord++;
                    if (isDigit(p->ch) || (p->ch == 'I') || (p->ch == 'O')) {
                        countDigits++;
                        if (numDots == 0) {
                            countDigitsBeforeDot++;
                        } else {
                            countDigitsAfterDot++;
                        }
                    } else {
                        countDigits = 0;
                        if (p->ch == '.')
                            numDots++;
                    }
                    countCharsInCurrentWord++;
                    p = p->next;
                }
                if (countDigits >= 4) {
                    //ReplacingLog("Validate: declaring digits only sequence in word [%s] starting at [%c]", toUTF8(r->word->text()).c_str(), (unsigned short)r->ch);
                    digitsOnly = true;
                    countLastDigitsSequence = countDigits;
                } else
                    digitsOnly = false;
                if ((numDots == 1) && (countDigitsBeforeDot > 0) && (countDigitsAfterDot == 2)) {
                    // Start of a price!
                    // Check if OCR missed a dollar sign to the left
                    CGRect rect = r->rect;
                    if ((results->retailerParams.pricesHaveDollar) && (r->ch != '$') && ((r->next == NULL) || (r->next->ch != '$')) && (line->averageSpacingDigits.count > 0) && (line->averageHeightDigits.count > 0) && (line->averageWidthDigits.count > 0)) {
                        rect.origin.x -= (line->averageWidthDigits.average + line->averageSpacingDigits.average * 2);
                        rect.size.width = line->averageWidthDigits.average + line->averageSpacingDigits.average * 2;
                        if (rect.origin.x > 0) {
                            r->flags5 |= FLAGS5_TESTED_DOLLAR_BEFORE;
                            SingleLetterTests *stDollar = CreateSingleLetterTests(rect, results);
                            if (stDollar != NULL) {
                                ConnectedComponentList cpl = stDollar->getConnectedComponents();
                                int totalPixels = 0;
                                float minX = 10000, maxX = -1;
                                for (int i=1; i<cpl.size(); i++) {
                                    totalPixels += cpl[i].area;
                                    if (cpl[i].xmin < minX)
                                        minX = cpl[i].xmin;
                                    if (cpl[i].xmax > maxX)
                                        maxX = cpl[i].xmax;
                                }
                                // Valid $ is around 35% of the encompassing rect
                                if (totalPixels > rect.size.width * rect.size.height * 0.25) {
                                    // Significant! Assume it's a $ sign
                                    CGRect newRect = rect;
                                    newRect.origin.x = rect.origin.x + minX;
                                    newRect.size.width = maxX - minX + 1;
                                    ReplacingLog("Validate: replacing rule 0550 inserting [$] before [%c] in word [%s]", (unsigned short)r->ch, toUTF8(r->word->text()).c_str());
                                    r->word->addLetterWithRectConfidenceAfterRect(r->ch, r->rect, r->confidence, r);
                                    r->word->updateLetterWithNewCharAndNewRect(r, '$', newRect);
                                }
                                delete stDollar;
                            }
                        }
                    }
                    
                }
            }
            
            // Remove letters entirely below the line
            // Careful with '_' which CAN be entirely below
            // Careful! Sometimes the next letter is entirely above and that caused us to eliminate the current letter - NOT good
            if (isLetterOrDigit(r->ch)) {
                bool entirelyBelowPrevious = ((r->previous != NULL) && isLetterOrDigit(r->previous->ch) && (rectBottom(r->rect) > rectTop(r->previous->rect)));
                bool entirelyBelowPreviousPrevious = ((r->previous != NULL) && (r->previous->previous != NULL) && isLetterOrDigit(r->previous->previous->ch) && (rectBottom(r->rect) > rectTop(r->previous->previous->rect)));
                
                bool entirelyBelowNext = ((r->next != NULL) && isLetterOrDigit(r->next->ch) && (rectBottom(r->rect) >rectTop(r->next->rect)));
                bool entirelyBelowNextNext = ((r->next != NULL) && (r->next->next != NULL) && isLetterOrDigit(r->next->next->ch) && (rectBottom(r->rect) >rectTop(r->next->next->rect)));

                bool doit = (entirelyBelowPrevious && (entirelyBelowNext || entirelyBelowNextNext))
                || (entirelyBelowNext && (entirelyBelowPrevious || entirelyBelowPreviousPrevious))
                || (entirelyBelowPrevious && entirelyBelowPreviousPrevious && ((r->next == NULL) || (!isLetterOrDigit(r->next->ch) && ((r->next->next == NULL) || !isLetterOrDigit(r->next->next->ch)))))
                || (entirelyBelowNext && entirelyBelowNextNext && ((r->previous == NULL) || (!isLetterOrDigit(r->previous->ch) && ((r->previous->previous == NULL) || !isLetterOrDigit(r->previous->previous->ch)))));
                
                if (!doit) {
                    bool entirelyAbovePrevious = ((r->previous != NULL) && isLetterOrDigit(r->previous->ch) && (rectBottom(r->previous->rect) - rectTop(r->rect) > r->rect.size.height * 0.30));
                    bool entirelyAbovePreviousPrevious = ((r->previous != NULL) && (r->previous->previous != NULL) && isLetterOrDigit(r->previous->previous->ch) && (rectBottom(r->previous->previous->rect) - rectTop(r->rect) > r->rect.size.height * 0.30));
                
                    bool entirelyAboveNext = ((r->next != NULL) && isLetterOrDigit(r->next->ch) && (rectBottom(r->next->rect) - rectTop(r->rect) > r->rect.size.height * 0.30));
                    bool entirelyAboveNextNext = ((r->next != NULL) && (r->next->next != NULL) && isLetterOrDigit(r->next->next->ch) && (rectBottom(r->next->next->rect) - rectTop(r->rect) > r->rect.size.height * 0.30));
                
                    doit = (entirelyAbovePrevious && (entirelyAboveNext || entirelyAboveNextNext))
                            || (entirelyAboveNext && (entirelyAbovePrevious || entirelyAbovePreviousPrevious))
                            || (entirelyAbovePrevious && entirelyAbovePreviousPrevious && ((r->next == NULL) || (!isLetterOrDigit(r->next->ch) && ((r->next->next == NULL) || !isLetterOrDigit(r->next->next->ch)))))
                            || (entirelyAboveNext && entirelyAboveNextNext && ((r->previous == NULL) || (!isLetterOrDigit(r->previous->ch) && ((r->previous->previous == NULL) || !isLetterOrDigit(r->previous->previous->ch)))));
                }

                if (doit) {
                    ReplacingLog("Validate: rule 0038 replacing - eliminating [%c] in word [%s] entirely below or above baseline", (unsigned short)r->ch, toUTF8(r->word->text()).c_str());
                    SmartPtr<OCRRect> tmpR = r->next;
                    r->word->removeLetter(r);
                    r = tmpR;
                    continue;
                }
            }
            // Remove ANY character (e.g. '.' or '_' but not only) significantly below line
            else { // Not a letter or digit
                float acceptableGap = 0;
                if (statsWithoutCurrent->averageHeightNormalLowercase.count > 1) {
                    // Be more liberal for _ when lots of space above it, i.e. it connects two letters
                    if ((r->ch == '_') && ((r->previous != NULL) && (rectSpaceBetweenRects(r->previous->rect, r->rect) < statsWithoutCurrent->averageHeightNormalLowercase.average * 0.25))
                        && ((r->next != NULL) && (rectSpaceBetweenRects(r->rect, r->next->rect) < statsWithoutCurrent->averageHeightNormalLowercase.average * 0.25)))
                        acceptableGap = statsWithoutCurrent->averageHeightNormalLowercase.average * 0.38;
                    else
                        acceptableGap = statsWithoutCurrent->averageHeightNormalLowercase.average * 0.33;
                }
                if ((acceptableGap == 0) || ((statsWithoutCurrent->averageHeightUppercase.count > 1) && (statsWithoutCurrent->averageHeightUppercase.count > statsWithoutCurrent->averageHeightNormalLowercase.count))) {
                    acceptableGap = statsWithoutCurrent->averageHeightUppercase.average * 0.22;
                }
                if ((acceptableGap == 0) && (r->previous != NULL) && isLower(r->previous->ch) && !isTallLowercase(r->previous->ch)) {
                    acceptableGap = r->previous->rect.size.height * 0.33;
                    if ((r->next != NULL) && isLower(r->next->ch) && !isTallLowercase(r->next->ch))
                        if (r->next->rect.size.height * 0.33 > acceptableGap)
                            acceptableGap = r->next->rect.size.height * 0.33;
                }
                if ((acceptableGap == 0) && (r->next != NULL) && isLower(r->next->ch) && !isTallLowercase(r->next->ch)) {
                    acceptableGap = r->next->rect.size.height * 0.33;
                }
                // Adding '@' as acceptable next/previous
                if ( (acceptableGap > 0) && (r->previous != NULL) && (isLetterOrDigit(r->previous->ch) || (r->previous->ch == '@')) && (rectBottom(r->rect) - rectTop(r->previous->rect) > acceptableGap) && (rectBottom(r->rect) - rectTop(r->previous->rect) >= r->rect.size.height)
                   && ((r->next != NULL) && (isLetterOrDigit(r->next->ch) || (r->next->ch == '@')) && (rectBottom(r->rect) - rectTop(r->next->rect) > acceptableGap))
                        && (rectBottom(r->rect) - rectTop(r->next->rect) >= r->rect.size.height) )
                {
                    ReplacingLog("Validate: rule 0039 replacing - eliminating [%c]] in word [%s] entirely below baseline", (unsigned short)r->ch, toUTF8(r->word->text()).c_str());
                    SmartPtr<OCRRect> tmpR = r->next;
                    r->word->removeLetter(r);
                    r = tmpR;
                    continue;
                }
            }
            
			// Note: test multi-char patterns first, to avoid having one of the chars interpreted within a shorter sequence

			// Matching: "<>" 
			// Replacing with: 'o'
			if (r->ch == 0x2039) {
				if ((r->next != NULL) && (r->next->ch == 0x203a)) {
                    replaceTwo(r, 'o', "rule 0451");
					makeAnotherPass = true;
				}
				// U+2039		e2 80 b9	SINGLE LEFT-POINTING ANGLE QUOTATION MARK 
				else {
					wchar_t newCh = 'c';
					ReplacingLog("Validate: rule 0452 replacing [0x%x] with [%c]", (unsigned short)r->ch, newCh);
					r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
					makeAnotherPass = true;
				}
			}
			else if ((r->ch == 0x203a) || (r->ch == 0x9b)) {
				// > sign, 0x203a found empirically, added 0x9b from Unicode table
				char newCh;
				if (tallHeightTest(statsWithoutCurrent.getPtr(), r->rect.size.height, '\0', false, 1, false) == 1) {
					newCh = ')';
				} else {
					newCh = '-';
				}
				ReplacingLog("Validate: rule 0062 replacing [%c] with [%c]", r->ch, newCh);
				r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
				makeAnotherPass = true;
			}
#if !TARGET_IPHONE   
            // $ now blacklisted
			// $ next to digits is usually a '5' unless perhaps at the start of a word
			else if ((r->ch == '$')
					 && (r->next != NULL) && isDigit(r->next->ch)
					 && (r->previous != NULL) && (r->previous->ch != ' ')) {
				char newCh = '5';
				ReplacingLog("Validate: rule 0522 replacing [%c] with [%c]", r->ch, newCh);
				r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
				r = r->next;
				continue;
			}
#endif
        
            // Case of quote (0x27) instead of comma
            if (isQuote(r->ch) && (r->previous != NULL) && isLetterOrDigit(r->previous->ch)) {
                float marginFromTop = 0.60; // If comma, can rise at most to be 80% from the top
                if (isTallBelow(r->previous->ch)) 
                    marginFromTop = 0.30;
                if (rectDeltaBetweenBottoms(r->previous->rect, r->rect) > r->previous->rect.size.height * marginFromTop) {
                    char newCh = ',';
                    ReplacingLog("Validate: rule 0519 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)newCh, toUTF8(r->word->text()).c_str());
					r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect); 
                }
            }
            
            // Tests done before any others, for example the test for low quote that's really a dot, because otherwise many other combinations with quotes will trigger!
            OCRRectPtr referenceR;
            if (isQuote(r->ch) 
                && ( (((referenceR = r->previous) != NULL) && isLetterOrDigitOrNormalHeight(referenceR->ch))
                    || (((referenceR = r->next) != NULL) && isLetterOrDigitOrNormalHeight(referenceR->ch))
                    || ((r->previous != NULL) && ((referenceR = r->previous->previous) != NULL) && isLetterOrDigitOrNormalHeight(referenceR->ch))
                    || ((r->next != NULL) && ((referenceR = r->next->next) != NULL) && isLetterOrDigitOrNormalHeight(referenceR->ch))
                   )
                ) {
                // Lowest point for it to be a . or ,
                float maxY = rectTop(referenceR->rect) - referenceR->rect.size.height * 0.30;
                if (rectBottom(r->rect) > maxY) {
                    // If it's actually a ',' there is a rule later that will convert
                    char newCh = '.';
                    if (r->rect.size.width > r->rect.size.height * OCR_RATIO_DASH_MIN_WIDTH_TO_HEIGHT) 
                        newCh = '-';
                    ReplacingLog("Validate: rule 0062 replacing [0x%x] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
					r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
					makeAnotherPass = true;
                }
            }
            
            // Test 'L' with suspicious thin width for the possibility of two very disjoint components (due to noise)
            // Do only if width is suspect for performance reason
            if ((r->ch == 'L') && (r->rect.size.width < statsWithoutCurrent->averageWidthUppercase.average * 0.50) && (results->imageTests) && (round == 0)) {
                SingleLetterTests* st = CreateSingleLetterTests(r->rect, results);
            
                if (st != NULL) {
                    ConnectedComponentList cpl = st->getConnectedComponents();
                    // Check that we have two main components
                    if (cpl.size() > 2) {
                        ConnectedComponent mainComp = cpl[1];
                        float mainCompHeight = mainComp.getHeight(), mainCompWidth = mainComp.getWidth();
                        ConnectedComponent minorComp = cpl[2];
                        if ((mainCompHeight * mainCompWidth < r->rect.size.height * r->rect.size.width * 0.50)
                            && ((mainCompHeight < statsWithoutCurrent->averageHeightUppercase.average * 0.80) || (mainCompHeight < statsWithoutCurrent->averageHeight.average * 0.80))) {
                            // Something is (very) wrong!
                            // . or : ?
                            CGRect mainRect(rectLeft(r->rect) + mainComp.xmin,
                                rectBottom(r->rect) + mainComp.ymin,
                                mainCompWidth,
                                mainCompHeight);
                            OCRRectPtr refR;
                            float gapBelowTop;
                            // Eliminate if just too small
                            if ((mainCompHeight > statsWithoutCurrent->averageHeight.average * 0.10)
                                && ((((refR = r->previous) != NULL) && (isLetterOrDigit(refR->ch) && ((gapBelowTop=rectBottom(mainRect) - rectBottom(refR->rect) > refR->rect.size.height * 0.60) && (gapBelowTop < refR->rect.size.height)))) 
                                  || (((refR = r->next) != NULL) && (isLetterOrDigit(refR->ch) && ((gapBelowTop=rectBottom(mainRect) - rectBottom(refR->rect) > refR->rect.size.height * 0.60) && (gapBelowTop < refR->rect.size.height)))))) {
                                char newCh = '.';
                                // Could be '-'
                                if (mainCompWidth >= mainCompHeight * 2)
                                    newCh = '-';
                                // Other comp not too small, above main by at least 30% of height of main
                                else if ((minorComp.area > mainComp.area * 0.60) && (minorComp.ymax < mainComp.ymin) && (mainComp.ymin - minorComp.ymax - 1 > mainCompHeight * 0.30)) {
                                    newCh = ':';
                                }
                                ReplacingLog("Validate: rule 0063 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                                r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                                makeAnotherPass = true;
                            } else {
                                // Just eliminate (assume it's noise)
                                ReplacingLog("Validate: rule 0064 replacing, eliminating %c] in word [%s]", (unsigned short)r->ch, toUTF8(r->word->text()).c_str());
                                OCRRectPtr tmpR = r->next;
                                r->word->removeLetter(r);
                                r = tmpR;
                                makeAnotherPass = true;
                                continue;
                            }
                        }
                    }
                    delete st;
                } // st != NULL
            }
        
            
            // Test ':' that is actually a 'r'
            // No idea why this test is only done at round 0
            if ((r->ch == ':') && (round == 0) && (results->imageTests)) {
        
                SingleLetterTests* st = CreateSingleLetterTests(r->rect, results);
            
                if (st != NULL) {
                    ConnectedComponentList cpl = st->getConnectedComponents();
                    // Check that we have only 1 main component!
                    if ((cpl.size() == 2) || ((cpl.size() >= 3) && (cpl[2].area < cpl[1].area * 0.05))) {
                        char newCh = '\0';
                        int tallTestResults = tallHeightTest(statsWithoutCurrent.getPtr(), r->rect.size.height, '\0', false, 2, false);
                        bool isTall = (tallTestResults == 1);
                        bool isShort = (tallTestResults == 0);
                        // First test 'c'
                        OpeningsTestResults resRight;
                        bool success = st->getOpenings(resRight, SingleLetterTests::Right,
                                                       0.10,      // Start of range to search (top/left)
                                                       0.90,      // End of range to search (bottom/right)
                                                       SingleLetterTests::Bound,   // Require start (top/left) bound
                                                       SingleLetterTests::Bound  // Require end (bottom/right) bound
                                                       );
                        // Reva Culpher" depth=5 out of width 10 (50%)
                        if (success && resRight.maxDepth > r->rect.size.width * 0.35) {
                            // Don't perform more tests because we already know 'c' is better than ':' and we don't have a better idea
                            newCh = (isTall? 'C':'c');
                        }
                        
                        if ((newCh == '\0') && !isTall) {
                            OpeningsTestResults resRight;
                            bool success = st->getOpenings(resRight, SingleLetterTests::Right, 
                                0,      // Start of range to search (top/left)
                                1,      // End of range to search (bottom/right)
                                SingleLetterTests::Bound,   // Require start (top/left) bound
                                SingleLetterTests::Unbound  // Require end (bottom/right) bound
                                );
                                
                            if (success && resRight.maxDepth > r->rect.size.width * 0.20) {
                                newCh = 'r';
                            }
                        }

                        if ((newCh == '\0') && !isShort) {
                            newCh = 'l';
                            r->confidence += 500; // Force single letter test
                        }
                        if (newCh != '\0') {
                            ReplacingLog("Validate: rule 0048 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                            r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                            makeAnotherPass = true;
                        }
                    }
                    delete st;
                }
            }
            
            wchar_t newCh = '\0';
            
            // 4 vertical letters instead of 'M'
            if (!(r->flags5 & FLAGS5_TESTED_AS_M) && isVerticalLine(r->ch) && (r->next != NULL) && isVerticalLine(r->next->ch) && (r->next->next != NULL) && isVerticalLine(r->next->next->ch) && (r->next->next->next != NULL) && isVerticalLine(r->next->next->next->ch)
                && (rectSpaceBetweenRects(r->rect, r->next->rect) <= 0) && (rectSpaceBetweenRects(r->next->rect, r->next->next->rect) <= 0) && (rectSpaceBetweenRects(r->next->next->rect, r->next->next->next->rect) <= 0)) {
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect, r->next->next->rect, r->next->next->next->rect);
                int res = SingleLetterTestAsM(r, combinedRect, results);
                r->flags5 |= FLAGS5_TESTED_AS_M;
                if (res == 1) {
                    char newCh = 'M';
                    replaceFourWithRect(r, newCh, combinedRect, "rule 0123");
                    makeAnotherPass = true;
                }
            }


            // Handle early on cases of digits or uppercase with abnormally tall rects by adjusting the rect to the dimension and position of the main component
            if ((results->imageTests) && (r->rect.size.height > results->globalStats.averageHeightUppercase.average * 1.30)) {
                // Is rect aligned with bottom of neighboring letters (in which case excessive height is above the letter) or the reverse?
                float referenceHeight = -1;
                if (statsWithoutCurrent->averageHeightDigits.count > 2) {
                    referenceHeight = statsWithoutCurrent->averageHeightDigits.average;
                }
                if ((referenceHeight < 0) && (statsWithoutCurrent->averageHeightUppercase.count > 2)) {
                    referenceHeight = statsWithoutCurrent->averageHeightUppercase.average;
                }
                if ((referenceHeight < 0) && (results->globalStats.averageHeightDigits.count > 2)) {
                    referenceHeight = results->globalStats.averageHeightDigits.average;
                }
                if ((referenceHeight < 0) && (results->globalStats.averageHeightUppercase.count > 2)) {
                    referenceHeight = results->globalStats.averageHeightUppercase.average;
                }
                if (referenceHeight > 0) {
                    // Test if we have only connected components smaller than 25% of digit height, one of them aligned with the baseline (our dot)
                    bool doit = true, foundDot = false;
                    CGRect dotRect;
                    SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                    if (st != NULL) {
                        ConnectedComponentList cpl = st->getConnectedComponents();
                        if (cpl.size() > 1) {
                            for (int i=1; i<cpl.size(); i++) {
                                ConnectedComponent cc = cpl[i];
                                CGRect subRect = r->rect;
                                subRect.origin.y += cc.ymin;
                                subRect.size.height = (cc.ymax - cc.ymin) + 1;
                                subRect.origin.x += cc.xmin;
                                subRect.size.width = (cc.xmax - cc.xmin) + 1;
                                // Ignore it?
                                bool alignedBaseline = (gapRectAboveBaselineOfNeighborsLessThanLimit(r, subRect, referenceHeight * 0.15, true) == 1);
                                bool alignedTopline = (gapRectAboveToplineOfNeighborsLessThanLimit(r, subRect, referenceHeight * 0.15, true) == 1);
                                if (alignedBaseline || alignedTopline) {
                                    if (foundDot) {
                                        // Can't have two dots (ignore ':'), abort
                                        doit = false;
                                        break;
                                    }
                                    // Small enough?
                                    // OK to compare width with digit height, no biggie
                                    if ((subRect.size.height > referenceHeight * 0.35) || (subRect.size.width > referenceHeight * 0.35)) {
                                        doit = false;
                                        break;
                                    }
                                    foundDot = true;
                                    dotRect = subRect;
                                } else {
                                    // Ignore this cc
                                    continue;
                                }
                            }
                            if (doit && foundDot) {
                                wchar_t newCh = '.';
                                ReplacingLog("Validate: rule 0556 replacing adjusting rect of [%c] from [%.0f,%.0f - %.0f,%.0f] w=%.0f,h=%.0f to [%.0f,%.0f - %.0f,%.0f] w=%.0f,h=%.0f and replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, rectLeft(r->rect), rectBottom(r->rect), rectRight(r->rect), rectTop(r->rect), r->rect.size.width, r->rect.size.height, rectLeft(dotRect), rectBottom(dotRect), rectRight(dotRect), rectTop(dotRect), dotRect.size.width, dotRect.size.height, (unsigned char)r->ch, (unsigned char)newCh, toUTF8(r->word->text()).c_str());
                                r->word->updateLetterWithNewCharAndNewRect(r, newCh, dotRect);
                            }
                        } // 2+ connected comps
                        delete st;
                    }
                } // got reference height
            }

            
            // Handle early on cases of digits or uppercase with abnormally tall rects by adjusting the rect to the dimension and position of the main component
            if ((results->imageTests) && (results->globalStats.averageHeightUppercase.count > 10) && (r->rect.size.height > results->globalStats.averageHeightUppercase.average * 1.30)) {
                // Is rect aligned with bottom of neighboring letters (in which case excessive height is above the letter) or the reverse?
                float limit = results->globalStats.averageHeightUppercase.average * 0.15;
                bool alignedBaseline = (gapAboveBaselineOfNeighborsLessThanLimit(r, limit, true) == 1);
                bool alignedTopline = (gapAboveToplineOfNeighborsLessThanLimit(r, limit, true) == 1);
                if ((alignedBaseline && !alignedTopline) || (alignedTopline && !alignedBaseline)) {
                    SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                    if (st != NULL) {
                        ConnectedComponentList cpl = st->getConnectedComponents();
                        // Determine boundaries of the new rect by testing which connected component(s) are within the expected height range
                        if (cpl.size() >= 3) {
                            float minX = MAXFLOAT, maxX = -1000, minY = MAXFLOAT, maxY = -1000;
                            for (int i=1; i<cpl.size(); i++) {
                                ConnectedComponent currentCC = cpl[i];
                                if (alignedBaseline) {
                                    // Ignore if too much higher
                                    if (r->rect.size.height - currentCC.ymax > limit)
                                        continue;
                                } else {
                                    // Ignore if too far below
                                    if (currentCC.ymin > limit)
                                        continue;
                                }
                                if (currentCC.ymin < minY)
                                    minY = currentCC.ymin;
                                if (currentCC.ymax > maxY)
                                    maxY = currentCC.ymax;
                                if (currentCC.xmin < minX)
                                    minX = currentCC.xmin;
                                if (currentCC.xmax > maxX)
                                    maxX = currentCC.xmax;
                            }
                            // We finally have the rect we need to set, do it!
                            CGRect finalRect = r->rect;
                            finalRect.origin.x += minX;
                            finalRect.size.width = maxX - minX + 1;
                            finalRect.origin.y += minY;
                            finalRect.size.height = maxY - minY + 1;
                            // If resulting rect is really tiny, make it a dot!
                            wchar_t newCh = r->ch;
                            if ((statsWithoutCurrent->averageHeightDigits.count > 1) && alignedBaseline && (finalRect.size.height < statsWithoutCurrent->averageHeightDigits.average * 0.25))
                                newCh = '.';
#if DEBUG
                            ReplacingLog("Validate: rule 0521 replacing adjusting rect of [%c] from [%.0f,%.0f - %.0f,%.0f] w=%.0f,h=%.0f to [%.0f,%.0f - %.0f,%.0f] w=%.0f,h=%.0f in word [%s]", (unsigned short)r->ch, rectLeft(r->rect), rectBottom(r->rect), rectRight(r->rect), rectTop(r->rect), r->rect.size.width, r->rect.size.height, rectLeft(finalRect), rectBottom(finalRect), rectRight(finalRect), rectTop(finalRect), finalRect.size.width, finalRect.size.height, toUTF8(r->word->text()).c_str());
                            SingleLetterTests *st1 = CreateSingleLetterTests(finalRect, results);
                            delete st1;
#endif
                            r->word->updateLetterWithNewCharAndNewRect(r, r->ch, finalRect);
                        }
                        delete st;
                    }
                }
            }
            
			// ==================== STAGE WITH 3 LETTER SEQUENCES ========================
            
            
#if DEBUG
// CKJ
            if ((r->ch=='I') && (r->next != NULL) && (r->next->ch =='X') && (r->next->next != NULL) && (r->next->next->ch == 'J')) {
                DebugLog("Found in word [%s]", toUTF8(r->word->text()).c_str());
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->next->rect);
                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results, SINGLE_LETTER_VALIDATE_SINGLE_COMP);
                delete st;
                DebugLog("");
            }
#endif
            
            //  ---------------------------
            //0|                           |
            //1|     1111        1111      |
            //2|   1111111      1111111    |
            //3|  111111111     11111111   |
            //4|  1111  1111    111111111  |
            //5| 1111    111   111    111  |
            //6| 111     111  1111     111 |
            //7| 111     111  111      111 |
            //8| 111     111  111      111 |
            //9| 111     111   111     111 |
            //a| 111     11    111     111 |
            //b| 111     11    111     111 |
            //c| 111     111   111     111 |
            //d| 111     111   111     111 |
            //e| 111     111  111      111 |
            //f| 111      11  111      111 |
            //#| 111      1111111      111 |
            //#| 111      1111111      111 |
            //#| 111     1111  111     111 |
            //#| 1111    111    111  1111  |
            //#|  111111111     111111111  |
            //#|   11111111     11111111   |
            //#|    111111       111111    |
            //#|                           |
            //  ---------------------------
            // "CKJ" instead of "00" - see Walgreens https://drive.google.com/open?id=0B4jSQhcYsC9VR0F4UWNya0M2Q1k
            // "IXJ" instead of "00" - see Walgreens https://drive.google.com/open?id=0B4jSQhcYsC9VR0F4UWNya0M2Q1k
            if (((r->ch == 'C') || (r->ch == 'I')) && (r->next != NULL) && ((r->next->ch == 'K') || (r->next->ch == 'X')) && (r->next->next != NULL) && (r->next->next->ch == 'J')
                && (results->imageTests)) {
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->next->rect);
                // Not wide enough for 3 chars
                if (combinedRect.size.width < results->globalStats.averageWidthDigits.average * 3 * 0.85) {
                    // Looks for two big inverted comps
                    SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
                    if (st != NULL) {
                        ConnectedComponentList invertCpl = st->getInverseConnectedComponents();
                        if (invertCpl.size() >= 3) {
                            bool foundLeftZero = false, foundRightZero = false;
                            for (int i=1; i<=3; i++) {
                                ConnectedComponent cc = invertCpl[i];
                                if ((cc.getHeight() > combinedRect.size.height * 0.55)
                                    && (cc.getWidth() > results->globalStats.averageWidthDigits.average * 0.20)) {
                                    if (!foundLeftZero && (cc.xmax < combinedRect.size.width * 0.50))
                                        foundLeftZero = true;
                                    else if (!foundRightZero && (cc.xmin > combinedRect.size.width * 0.50))
                                        foundRightZero = true;
                                }
                            }
                            if (foundLeftZero && foundRightZero) {
                                ReplacingLog("Validate: rule 0630 replacing [%c%c%c] with [00] in word [%s]", (unsigned short)r->ch, (unsigned short)r->next->ch, (unsigned short)r->next->next->ch, toUTF8(r->word->text()).c_str());
                                r->word->removeLetter(r->next->next);
                                CGRect rect1 (rectLeft(combinedRect), rectBottom(combinedRect), (combinedRect.size.width - 2)/2, combinedRect.size.height);
                                CGRect rect2 (rectRight(combinedRect) - (combinedRect.size.width - 2)/2, rectBottom(combinedRect), (combinedRect.size.width - 2)/2, combinedRect.size.height);
                                r->word->updateLetterWithNewCharAndNewRect(r, '0', rect1);
                                r->word->updateLetterWithNewCharAndNewRect(r->next, '0', rect2);
                                makeAnotherPass = true;
                            }
                        }
                        delete st;
                    }
                }
            }
            
            // "-i-" instead of '+'
            if (isDash(r->ch) && !(r->flags3 & FLAGS3_TESTED_AS_PLUS)
                && (r->next != NULL) && isVerticalLine(r->next->ch) && (rectSpaceBetweenRects(r->rect, r->next->rect) <= 0)
                && (r->next->next != NULL) && isDash(r->next->next->ch) && (rectSpaceBetweenRects(r->next->rect, r->next->next->rect) <= 0) ) {
                r->flags3 |= FLAGS3_TESTED_AS_PLUS;
                CGRect combinedRect;
                float maxY = MAX(rectTop(r->rect), rectTop(r->next->rect));
                maxY = MAX(maxY, rectTop(r->next->next->rect));
                float minY = MIN(rectBottom(r->rect), rectBottom(r->next->rect));
                minY = MIN(minY, rectBottom(r->next->next->rect));
                combinedRect.origin.x = rectLeft(r->rect);
                combinedRect.origin.y = minY;
                combinedRect.size.width = rectRight(r->next->next->rect) - combinedRect.origin.x + 1;
                combinedRect.size.height = maxY - minY + 1;
                
                // Check it's a single component
                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results, false, SINGLE_LETTER_VALIDATE_COMP_SIZE|SINGLE_LETTER_VALIDATE_SINGLE_COMP);
                if (st != NULL) {
                    char newCh = '+';
                    replaceThreeWithRect(r, newCh, combinedRect, "rule 0187");
                    makeAnotherPass = true;
                    delete st;
                }
            }
            
            // Vll instead of W
            // III instead of W
            if (((r->ch == 'V') || (r->ch == 'v') || (isVerticalLine(r->ch) && (r->ch != '/'))) && (r->next != NULL) && isVerticalLine(r->next->ch) && (r->next->ch != '/') && (r->next->next != NULL) && isVerticalLine(r->next->next->ch) && (r->next->next->ch != '\\')
                && (rectSpaceBetweenRects(r->rect, r->next->rect) <= 0)
                && (rectSpaceBetweenRects(r->next->rect, r->next->next->rect) <= 0)
                && !(r->flags2 & FLAGS2_TESTED))
            {
                bool doit = true;
                float minY = MIN(rectBottom(r->rect), rectBottom(r->next->rect));
                minY = MIN(minY, rectBottom(r->next->next->rect));
                float maxY = MAX(rectTop(r->rect), rectTop(r->next->rect));
                maxY = MAX(maxY, rectTop(r->next->next->rect));
                CGRect combinedRect(rectLeft(r->rect), minY, rectRight(r->next->next->rect) - rectLeft(r->rect) + 1, maxY - minY + 1); 
                if (results->imageTests) {
                    r->flags2 |= FLAGS2_TESTED;
                    SingleLetterTests *st = CreateSingleLetterTests(combinedRect,results);
                    if (st != NULL) {
                        ConnectedComponentList cpl = st->getConnectedComponents();
                        if ((cpl.size() < 2) 
                            || ((cpl.size() > 2) && (cpl[2].area > cpl[1].area * 0.05))) {
                            doit = false;
                        } else {
                            ConnectedComponent mainComp = cpl[1];
                            // Expect opening in the middle of bottom
                            OpeningsTestResults bottom;
                            bool success = st->getOpenings(bottom, 
                                SingleLetterTests::Bottom, 
                                0.20,      // Start of range to search (top/left)
                                0.80,      // End of range to search (bottom/right)
                                SingleLetterTests::Bound,   // Require start (top/left) bound
                                SingleLetterTests::Bound);  // Require end (bottom/right) bound
                            if (!success || (bottom.maxDepth < mainComp.getHeight() * 0.05)) 
                            {
                                doit = false;
                            }
                            SegmentList slTop;
                            if (doit) {
                                slTop= st->getHorizontalSegments(0.10, 0.10);
                                if ((slTop.size() != 3)
                                    || (slTop[0].endPos > combinedRect.size.width * 0.35)
                                    || (slTop[1].endPos > combinedRect.size.width * 0.70)
                                    || (slTop[2].startPos < combinedRect.size.width * 0.75))
                                {
                                    doit = false;
                                }
                            }
                            if (doit) {
                                // Expect opening top left
                                OpeningsTestResults topLeft;
                                bool success = st->getOpenings(topLeft, 
                                    SingleLetterTests::Top, 
                                    slTop[0].endPos/combinedRect.size.width,      // Start of range to search (top/left)
                                    slTop[1].startPos/combinedRect.size.width,      // End of range to search (bottom/right)
                                    SingleLetterTests::Bound,   // Require start (top/left) bound
                                    SingleLetterTests::Bound);  // Require end (bottom/right) bound
                                if (!success || (topLeft.maxDepth < mainComp.getHeight() * 0.20)) 
                                {
                                    doit = false;
                                }
                            }
                            if (doit) {
                                // Expect opening top right
                                OpeningsTestResults topRight;
                                bool success = st->getOpenings(topRight, 
                                    SingleLetterTests::Top, 
                                    slTop[1].endPos/combinedRect.size.width,      // Start of range to search (top/left)
                                    slTop[2].startPos/combinedRect.size.width,      // End of range to search (bottom/right)
                                    SingleLetterTests::Bound,   // Require start (top/left) bound
                                    SingleLetterTests::Bound);  // Require end (bottom/right) bound
                                if (!success || (topRight.maxDepth < mainComp.getHeight() * 0.20)) 
                                {
                                    doit = false;
                                } else {
                                    // Adjust rect
                                    combinedRect.origin.x += mainComp.xmin;
                                    combinedRect.origin.y += mainComp.ymin;
                                    combinedRect.size.width = mainComp.getWidth();
                                    combinedRect.size.height = mainComp.getHeight();
                                }
                            }        
                        }
                        delete st;
                    } // st != NULL
                } // single-letter
                if (doit) {
                    char newCh = 'W';
                    if (r->ch == 'v')
                        newCh = 'w';
                    ReplacingLog("Validate: rule 0107 replacing [%c%c%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)r->next->ch, (unsigned short)r->next->next->ch, newCh, toUTF8(r->word->text()).c_str());
                    r->word->removeLetter(r->next);
                    r->word->removeLetter(r->next);
                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, combinedRect);
                    makeAnotherPass = true;
                }
            }
            
            // :-: instead of '3'
            if (!(r->flags2 & FLAGS2_TESTED_AS_DIGIT) && (r->ch == ':') && (r->next != NULL) && isDash(r->next->ch) && (r->next->next != NULL) && (r->next->next->ch == ':') && (((r->previous != NULL) && isDigit(r->previous->ch)) || (((r->next->next->next != NULL) && isDigit(r->next->next->next->ch))))
                && (rectSpaceBetweenRects(r->rect, r->next->rect) <= 0) && (rectSpaceBetweenRects(r->next->rect, r->next->next->rect) <= 0)) 
            {
                float minY = MIN(rectBottom(r->rect), rectBottom(r->next->next->rect));
                float maxY = MAX(rectTop(r->rect), rectTop(r->next->next->rect));
                float newHeight = maxY - minY + 1;
                if (newHeight > statsWithoutCurrentAndNext->averageHeightDigits.average * (1 - OCR_ACCEPTABLE_ERROR)) {
                    CGRect newRect (rectLeft(r->rect), minY, rectRight(r->next->next->rect) - rectLeft(r->rect) + 1, newHeight);
                    // Start with assumption it's a '3', then perhaps correct
                    r->word->removeLetter(r->next);
                    r->word->removeLetter(r->next);
                    r->word->updateLetterWithNewCharAndNewRect(r, '3', newRect);
                    char newCh = SingleLetterTestSAsDigit(r, r->rect, 1, results, true);
                    r->flags2 |= FLAGS2_TESTED_AS_DIGIT;
                    if ((newCh != '\0') && (newCh != '3')) {
                        r->word->updateLetterWithNewCharAndNewRect(r, newCh, newRect);
                    }
                    ReplacingLog("Validate: rule 0093 replacing [:-:] with [%c] in word [%s]", (unsigned short)r->ch, toUTF8(r->word->text()).c_str());
                    makeAnotherPass = true;
                }
            }
            
            // .-. instead of A
            if ((r->ch == '.') && (r->next != NULL) && ((r->next->ch == '-') || (r->next->ch == '~')) && (r->next->next != NULL) && (r->next->next->ch == '.')) {
                float space1 = rectLeft(r->next->rect) - rectRight(r->rect) - 1;
                float space2 = rectLeft(r->next->next->rect) - rectRight(r->next->rect) - 1;
                if ((space1 <= 0) && (space2 <= 0)) {
                    float maxTop = MAX(rectTop(r->rect), rectTop(r->next->rect));
                    maxTop = MAX(maxTop, rectTop(r->next->next->rect));
                    float minBottom = MIN(rectBottom(r->rect), rectBottom(r->next->rect));
                    minBottom = MIN(minBottom, rectBottom(r->next->next->rect));                                 
                    float newHeight = maxTop - minBottom + 1;
                    float doit = false;
                    if (tallHeightTest(statsWithoutCurrent.getPtr(), newHeight, 'A', false, 0, true) == 1) {
                        doit = true;
                    }
                    bool isAccented = false;
                    if (!doit && (r->previous != NULL)) {
                        if ((r->previous != NULL) && isUpper(r->previous->ch) && (newHeight > r->previous->rect.size.height * (1-OCR_ACCEPTABLE_ERROR))) {
                            doit = true;
                        } else if (looksSameAsUppercase(r->previous->ch, results, &isAccented) && (newHeight > r->previous->rect.size.height * (isAccented? (1 + OCR_ACCENT_ADDITION):(1-OCR_ACCEPTABLE_ERROR)))) {
                            doit = true;
                            wchar_t newCh = toUpper(r->previous->ch);
                            // Also replace previous with uppercase version
                            ReplacingLog("Validate: rule 0517 replacing [%c] with [%c] in word [%s]", (unsigned short)r->previous->ch, (unsigned short)newCh, toUTF8(r->word->text()).c_str());
                            r->word->updateLetterWithNewCharAndNewRect(r->previous, newCh, r->previous->rect);
                        }
                    }
                    if (!doit && (r->next != NULL)) {
                        if ((r->next != NULL) && isUpper(r->next->ch) && (newHeight > r->next->rect.size.height * (1-OCR_ACCEPTABLE_ERROR))) {
                            doit = true;
                        } else if (looksSameAsUppercase(r->next->ch, results, &isAccented) && (newHeight > r->next->rect.size.height * (isAccented? (1 + OCR_ACCENT_ADDITION):(1-OCR_ACCEPTABLE_ERROR)))) {
                            doit = true;
                            wchar_t newCh = toUpper(r->next->ch);
                            // Also replace previous with uppercase version
                            ReplacingLog("Validate: rule 0516 replacing [%c] with [%c] in word [%s]", (unsigned short)r->next->ch, (unsigned short)newCh, toUTF8(r->word->text()).c_str());
                            r->word->updateLetterWithNewCharAndNewRect(r->next, newCh, r->next->rect);
                        }
                    }
                    if (doit) {
  						char newCh = 'A';
						float newWidth = rectRight(r->next->next->rect) - rectLeft(r->rect)  + 1;
						Rect newRect(rectLeft(r->rect), minBottom, newWidth, newHeight);
						ReplacingLog("Validate: replacing [%c%c%c] with [%c]", (unsigned short)r->ch, (unsigned short)r->next->ch, (unsigned short)r->next->next->ch, newCh);
						r->word->removeLetter(r->next->next);
						r->word->removeLetter(r->next);
						r->word->updateLetterWithNewCharAndNewRect(r, newCh, newRect);
						makeAnotherPass = true;                      
                    }
                }
            }
            
			if ( isVerticalLine(r->ch) && (r->next != NULL)) 
			{ 
				// "|-|", replacing with: 'H'
				if (!(r->flags4 & FLAGS4_TESTED_AS_h)
                 && (isDash(r->next->ch) || isQuote(r->next->ch) || (r->next->ch == '.') || (r->next->ch == ',')) && (r->next->next != NULL)
				 && isVerticalLine(r->next->next->ch) ) 
                 {
					float spacing1 = rectSpaceBetweenRects(r->rect, r->next->rect);
					float spacing2 = rectSpaceBetweenRects(r->next->rect, r->next->next->rect);
                    float minBottom = MIN(rectBottom(r->rect), rectBottom(r->next->next->rect));
                    float maxTop = MAX(rectTop(r->rect), rectTop(r->next->next->rect));
                    float newHeight = maxTop - minBottom + 1;
					if ((spacing1 <= 0) && (spacing2 <=0)
						&& ((statsWithoutCurrentAndNextTwo->averageSpacing.count == 0) || (MAX(spacing1,spacing2) < statsWithoutCurrentAndNextTwo->averageSpacing.average))
                        && (rectBottom(r->next->rect) - rectBottom(r->rect) > newHeight * 0.20)
                        && (rectTop(r->rect) - rectTop(r->next->rect) > newHeight * 0.20)
						&& (tallHeightTest(statsWithoutCurrentAndNextTwo.getPtr(), r->rect.size.height, 0, false, 0, true) == 1)
						&& (tallHeightTest(statsWithoutCurrentAndNextTwo.getPtr(), r->next->next->rect.size.height, 0, false, 0, true) == 1)
                        && (abs(r->rect.size.height - r->next->next->rect.size.height) < r->rect.size.height * 0.10)
						) 
                    {
                        // One more test - must be a single connected component!
                        r->flags4 |= FLAGS4_TESTED_AS_h;
                        CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect, r->next->next->rect);
                        SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results, true, SINGLE_LETTER_VALIDATE_COMP_SIZE|SINGLE_LETTER_VALIDATE_SINGLE_COMP);
                        if (st != NULL) 
                        {
                            char newCh = 'H';
                            replaceThreeWithRect(r, newCh, combinedRect);
                            makeAnotherPass = true;
                            delete st;
                        }
					}
				}
				// Matching |T\, mapping to 'M' or 'm'
                // |Y| -> M
				else if (((r->next->ch == 'T') || (r->next->ch == 'Y'))
					&& (r->next->next != NULL) && isVerticalLine(r->next->next->ch, results)
                    && (rectSpaceBetweenRects(r->rect, r->next->rect) <= 0)
                    && (rectSpaceBetweenRects(r->next->rect, r->next->next->rect) <= 0)
                    ) 
                {
                    CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect, r->next->next->rect);
                    if (CreateSingleLetterTests(combinedRect, results, true, SINGLE_LETTER_VALIDATE_COMP_SIZE|SINGLE_LETTER_VALIDATE_SINGLE_COMP) != NULL)
                    {
						char newCh = 'm'; 
						if (tallHeightTest(statsWithoutCurrentAndNextTwo.getPtr(), combinedRect.size.height, 'M', false, 0, false) == 1) {
							newCh = 'M';
						}
						ReplacingLog("Validate: replacing [%c%c%c] with [%c]", (unsigned short)r->ch, (unsigned short)r->next->ch, (unsigned short)r->next->next->ch, newCh);
						r->word->removeLetter(r->next->next);
						r->word->removeLetter(r->next);
						r->word->updateLetterWithNewCharAndNewRect(r, newCh, combinedRect);
						makeAnotherPass = true;
					}
				}
				// Matching "|'l1" to 'm'
				// [O (0x4f)] at [613,740 - 650,782] [w=38,h=43]
				// [| (0x7c)] at [656,741 - 667,781] [w=12,h=41]
				// [0x2019 - UTF8=e2 80 99] at [667,769 - 674,782] [w=8,h=14]
				// [l (0x6c)] at [675,742 - 688,782] [w=14,h=41]
				// [1 (0x31)] at [688,742 - 709,782] [w=22,h=41]				
				else if ((r->ch != '\\') && (r->next != NULL) && isQuote(r->next->ch) 
				   && (r->next->next != NULL) && isVerticalLine(r->next->next->ch)
				   && (r->next->next->next != NULL) && isVerticalLine(r->next->next->next->ch) && (r->next->next->next->ch != '/')
				   && (rectLeft(r->next->rect) - rectRight(r->rect) - 1 <= 0)
				   && (rectLeft(r->next->next->rect) - rectRight(r->next->rect) - 1 <= 0)
				   && (rectLeft(r->next->next->next->rect) - rectRight(r->next->next->rect) - 1 <= 0)
				   && ((statsWithoutCurrentAndNextTwo->averageSpacing.count == 0) || (statsWithoutCurrentAndNextTwo->averageSpacing.average > 0)))
				{
					char newCh = 'm';
					float newWidth = rectRight(r->next->next->next->rect) - rectLeft(r->rect) + 1;
					float minBottom = MIN(rectBottom(r->rect), rectBottom(r->next->next->next->rect));
					float maxTop = MAX(rectTop(r->rect), rectTop(r->next->next->next->rect));
					float newHeight = maxTop - minBottom + 1;
					if (tallHeightTest(statsWithoutCurrentAndNextTwo.getPtr(), newHeight, 'M', false, 0, false) == 1) {
						newCh = 'M';
					}
					Rect newRect(rectLeft(r->rect), minBottom, newWidth, newHeight);
					ReplacingLog("Validate: replacing [%c%c%c%c] with [%c]", (unsigned short)r->ch, (unsigned short)r->next->ch, (unsigned short)r->next->next->ch, (unsigned short)r->next->next->next->ch, newCh);
					r->word->removeLetter(r->next->next->next);
					r->word->removeLetter(r->next->next);
					r->word->removeLetter(r->next);
					r->word->updateLetterWithNewCharAndNewRect(r, newCh, newRect);
					r = r->next;
					makeAnotherPass = true;				
					continue;
				}
			} // isVerticalLine
			else if ((r->ch == '.') && (r->next != NULL) 
					&& (r->next->ch == 'n')
					&& (r->next->next != NULL) && (r->next->next->ch == '1') 
					&& ((r->next->next->next == NULL) || (r->next->next->next->ch == ' '))) 
			{
				char newCh;
				if (results->defaultCountryIndex == countryCodeNL) {
					newCh = 'l';
				} else if (results->defaultCountryIndex == countryCodeNZ) {
					newCh = 'z';
				} else {
					if (tallHeightTest(statsWithoutCurrentAndNextTwo.getPtr(), r->next->next->rect.size.height, 'l', false, 2, false) == 1) {
						newCh = 'l';
					} else {
						newCh = 'z';
					}
				}
				ReplacingLog("Validate: rule 0512 replacing [%c] with [%c]", (unsigned short)r->next->next->ch, newCh);
				r->word->updateLetterWithNewCharAndNewRect(r->next->next, newCh, r->next->next->rect);
				makeAnotherPass = true;
			}
			else if (((r->ch == 'v') || (r->ch == 'V'))
					&& (r->next != NULL))
			{
				// v\M/ -> ww
				if ((r->next->ch == '\\') 
					&& (r->next->next != NULL) && (r->next->next->ch == 'M') 
					&& (r->next->next->next != NULL) && (r->next->next->next->ch == '/'))
				{
					float totalWidth = rectRight(r->next->next->next->rect) - rectLeft(r->rect) + 1;
					float newWidth = (totalWidth - statsWithoutCurrentAndNextTwo->averageSpacing.average) / 2;
					if (newWidth < 1) {
						newWidth = (totalWidth/2) - 1;
					}
					float newHeight = r->rect.size.height;
					char newCh = ((r->ch == 'V')? 'W':'w');
					CGRect newRect1(rectLeft(r->rect), rectBottom(r->rect),
												 newWidth, newHeight);
					CGRect newRect2(rectRight(r->rect) - newWidth + 1,
												 rectBottom(r->rect),
												 newWidth,
												 newHeight);
					r->confidence = 0;
					ReplacingLog("ValidateLine: rule 0128 replacing [%c%c%c%c] with [ww] in word [%s]", (unsigned short)r->ch, (unsigned short)r->next->ch, (unsigned short)r->next->next->ch, (unsigned short)r->next->next->next->ch,
							toUTF8(r->word->text()).c_str());
					r->word->removeLetter(r->next->next->next);
					r->word->removeLetter(r->next->next);							
					r->word->updateLetterWithNewCharAndNewRect(r, newCh, newRect1);
					r->word->updateLetterWithNewCharAndNewRect(r->next, newCh, newRect1);
					r = r->next->next;
					makeAnotherPass = true;
					continue;				
				}
				// Matching: "vi/"
				// Replacing with: 'w'
				else if (isVerticalLine(r->next->ch)
					&& (r->next->next != NULL) && (r->next->next->ch == '/')) 
				{
					float spacing1 = rectLeft(r->next->rect) - rectRight(r->rect) - 1;
					float spacing2 = rectLeft(r->next->next->rect) - rectRight(r->next->rect) - 1;
					if ((spacing1 <= 0) && (spacing2 <=0)
						&& ((statsWithoutCurrentAndNextTwo->averageSpacing.count == 0) || (MAX(spacing1,spacing2) < statsWithoutCurrentAndNextTwo->averageSpacing.average))
						) {
						char newCh = 'w';
						float newWidth = rectRight(r->next->next->rect) - rectLeft(r->rect);
						float minBottom = MIN(rectBottom(r->rect), rectBottom(r->next->next->rect));
						float maxTop = MAX(rectTop(r->rect), rectTop(r->next->next->rect));
						float newHeight = maxTop - minBottom + 1;
						if (tallHeightTest(statsWithoutCurrentAndNextTwo.getPtr(), newHeight, 'W', false, 0, false) == 1) {
							newCh = 'W';
						}
						Rect newRect(rectLeft(r->rect), minBottom, newWidth, newHeight);
						ReplacingLog("Validate: rule 0108 replacing [%c%c%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)r->next->ch, (unsigned short)r->next->next->ch, newCh, toUTF8(r->word->text()).c_str());
						r->word->removeLetter(r->next->next);
						r->word->removeLetter(r->next);
						r->word->updateLetterWithNewCharAndNewRect(r, newCh, newRect); 
						makeAnotherPass = true;
					}
				}
			}

//#if DEBUG
//			if (r->ch =='|') {
//				DebugLog("Found it");
//			}
//#endif

			// Matching: "|>>{"
			// Replacing with: 'k'
			if ((r->ch == '|')
				&& (r->next != NULL) && isGreaterThanEquiv(r->next->ch) 
				&& (rectLeft(r->next->rect)-rectRight(r->rect)-1 <= 0)
				&& (r->next->next != NULL) && (r->next->next->ch == '{') && (rectLeft(r->next->next->rect)-rectRight(r->next->rect)-1 <= 0)) {
				wchar_t newCh = 'k';
				if ((r->previous == NULL) || (r->previous->ch == ' ')
					|| (!islower(r->previous->ch) && ((r->next->next->next != NULL) && isupper(r->next->next->next->ch)))) {
					newCh = 'K';
				}
				float newWidth = rectRight(r->next->next->rect) - rectLeft(r->rect);
				float minBottom = MIN(rectBottom(r->rect), rectBottom(r->next->next->rect));
				float maxTop = MAX(rectTop(r->rect), rectTop(r->next->next->rect));
				float newHeight = maxTop - minBottom + 1;
				CGRect newRect(rectLeft(r->rect), minBottom, newWidth, newHeight);
				ReplacingLog("Validate: replacing [%c%c%c] with [%c]", (unsigned short)r->ch, (unsigned short)r->next->ch, (unsigned short)r->next->next->ch, (unsigned short)newCh);
				r->word->removeLetter(r->next->next);
				r->word->removeLetter(r->next);
				r->word->updateLetterWithNewCharAndNewRect(r, newCh, newRect);
				makeAnotherPass = true;
			}
            
			// Matching: "IVI"
			// Replacing with: 'M'
			if (isVerticalLine(r->ch, results)
				&& (r->next != NULL) && ((r->next->ch == 'V') || (r->next->ch == 'v'))
				&& (r->next->next != NULL) && isVerticalLine(r->next->next->ch, results)
				)
			{
				float spacing1 = rectLeft(r->next->rect) - rectRight(r->rect) - 1;
				float spacing2 = rectLeft(r->next->next->rect) - rectRight(r->next->rect) - 1;
				if ((spacing1 <= 0) && (spacing2 <=0)) {
                    float doIt = false;
                    if ((statsWithoutCurrentAndNextTwo->averageSpacing.average > statsWithoutCurrentAndNextTwo->averageWidth.average * 0.19)) {
                        doIt = true;
                    }
					if (doIt || (( (((r->previous == NULL) || isUpper(r->previous->ch) || (r->previous->ch == ' '))
                           && ((r->next->next->next == NULL) || isUpper(r->next->next->next->ch) || (r->next->next->next->ch == ' ')
                               || (r->next->next->next->ch == ',') || (r->next->next->next->ch == '.')
                               )
                           )
                         || ((r->ch == '|') || (r->ch == '/') || (r->next->next->ch == '|'))
                         || ((r->previous != NULL) && (r->previous->ch == 'c') && (r->previous->previous != NULL) && (r->previous->previous->ch == 'M'))                    
                         )
                        && (((statsWithoutCurrentAndNextTwo->averageSpacing.count == 0) || (MAX(spacing1,spacing2) < statsWithoutCurrentAndNextTwo->averageSpacing.average))
					&& (tallHeightTest(statsWithoutCurrentAndNextTwo.getPtr(), r->rect.size.height, 0, false, 0, true) == 1)
					&& (tallHeightTest(statsWithoutCurrentAndNextTwo.getPtr(), r->next->next->rect.size.height, 0, false, 0, true) == 1)
					))) 
                    {
                        char newCh = 'M';
                        float newWidth = rectRight(r->next->next->rect) - rectLeft(r->rect);
                        float minBottom = MIN(rectBottom(r->rect), rectBottom(r->next->next->rect));
                        float maxTop = MAX(rectTop(r->rect), rectTop(r->next->next->rect));
                        float newHeight = maxTop - minBottom + 1;
                        if (doIt || ((statsWithoutCurrentAndNextTwo->averageHeightUppercase.count == 0)
                           || (newHeight > statsWithoutCurrentAndNextTwo->averageHeightUppercase.average * 0.90))) 
                        {
                            CGRect newRect(rectLeft(r->rect), minBottom, newWidth, newHeight);
                            ReplacingLog("Validate: replacing [%c%c%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)r->next->ch, (unsigned short)r->next->next->ch, newCh, toUTF8(r->word->text()).c_str());
                            r->word->removeLetter(r->next->next);
                            r->word->removeLetter(r->next);
                            r->word->updateLetterWithNewCharAndNewRect(r, newCh, newRect);
                            makeAnotherPass = true;
                        }
                    }
                }
			}
			
			// Matching: "I\/I"
			// Replacing with: 'M'
			if (isVerticalLine(r->ch)
				&& (r->next != NULL) && ((r->next->ch == '\\') || (r->next->ch == '1'))
				&& (r->next->next != NULL) && (r->next->next->ch == '/')
				&& (r->next->next->next != NULL) && isVerticalLine(r->next->next->next->ch)
                && results->imageTests && !(r->flags5 & FLAGS5_TESTED_AS_M))
			{
                r->flags5 |= FLAGS5_TESTED_AS_M;
				float spacing1 = rectLeft(r->next->rect) - rectRight(r->rect) - 1;
				float spacing2 = rectLeft(r->next->next->rect) - rectRight(r->next->rect) - 1;
				float spacing3 = rectLeft(r->next->next->next->rect) - rectRight(r->next->next->rect) - 1;
				if ((spacing1 <= 0) && (spacing2 <=0) && (spacing3 <=0)
					&& ((statsWithoutCurrentAndNextTwo->averageSpacing.count == 0) || (MAX(spacing1,spacing2) < statsWithoutCurrentAndNextTwo->averageSpacing.average))
					&& (tallHeightTest(statsWithoutCurrentAndNextTwo.getPtr(), r->rect.size.height, 0, false, 0, true) == 1)
					&& (tallHeightTest(statsWithoutCurrentAndNextTwo.getPtr(), r->next->next->next->rect.size.height, 0, false, 0, true) == 1)
					) {
					char newCh = 'M';
					float newWidth = rectRight(r->next->next->next->rect) - rectLeft(r->rect) + 1;
					float minBottom = MIN(rectBottom(r->next->next->next->rect),MIN(rectBottom(r->rect), rectBottom(r->next->next->rect)));
					float maxTop = MAX(rectTop(r->next->next->next->rect),MAX(rectTop(r->rect), rectTop(r->next->next->rect)));
					float newHeight = maxTop - minBottom + 1;
					CGRect newRect(rectLeft(r->rect), minBottom, newWidth, newHeight);
                    SingleLetterTests *st = CreateSingleLetterTests(newRect, results, false, SINGLE_LETTER_VALIDATE_COMP_SIZE | SINGLE_LETTER_VALIDATE_SINGLE_COMP);
                    if (st != NULL) {
                        ReplacingLog("Validate: replacing [%c%c%c%c] with [%c]", (unsigned short)r->ch, (unsigned short)r->next->ch, (unsigned short)r->next->next->ch, (unsigned short)r->next->next->next->ch, newCh);
                        r->word->removeLetter(r->next->next->next);
                        r->word->removeLetter(r->next->next);
                        r->word->removeLetter(r->next);
                        r->word->updateLetterWithNewCharAndNewRect(r, newCh, newRect);
                        makeAnotherPass = true;
                        delete st;
                    }
				}
			}

			// Matching: "|\|"
			// Replacing with: 'N'
			if (isVerticalLine(r->ch)
				&& (r->next != NULL) && (r->next->ch == '\\')
				&& (r->next->next != NULL) && isVerticalLine(r->next->next->ch))
			{
				float spacing1 = rectLeft(r->next->rect) - rectRight(r->rect) - 1;
				float spacing2 = rectLeft(r->next->next->rect) - rectRight(r->next->rect) - 1;
				if ((spacing1 <= 0) && (spacing2 <=0)
					&& ((statsWithoutCurrentAndNextTwo->averageSpacing.count == 0) || (MAX(spacing1,spacing2) < statsWithoutCurrentAndNextTwo->averageSpacing.average))
					&& (tallHeightTest(statsWithoutCurrentAndNextTwo.getPtr(), r->rect.size.height, 0, false, 0, true) == 1)
					&& (tallHeightTest(statsWithoutCurrentAndNextTwo.getPtr(), r->next->next->rect.size.height, 0, false, 0, true) == 1)
					) {
					char newCh = 'N';
					float newWidth = rectRight(r->next->next->rect) - rectLeft(r->rect);
					float minBottom = MIN(rectBottom(r->rect), rectBottom(r->next->next->rect));
					float maxTop = MAX(rectTop(r->rect), rectTop(r->next->next->rect));
					float newHeight = maxTop - minBottom + 1;
					CGRect newRect(rectLeft(r->rect), minBottom, newWidth, newHeight);
					ReplacingLog("Validate: replacing [%c%c%c] with [%c]", (unsigned short)r->ch, (unsigned short)r->next->ch, (unsigned short)r->next->next->ch, newCh);
					// Note: important to remove letters starting from the last letter otherwise backing spacing out will use new previous rect instead of orig
					r->word->removeLetter(r->next->next);
					r->word->removeLetter(r->next);
					r->word->updateLetterWithNewCharAndNewRect(r, newCh, newRect);
					makeAnotherPass = true;
				}
			}

//#if DEBUG
//			if ((r->ch=='0') && (r->next != NULL) && (r->next->ch =='7') && (r->previous != NULL) && (r->previous->ch=='7')) {
//                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
//                if (st != NULL) delete st;
//                DebugLog("Found in word [%s]", toUTF8(r->word->text()).c_str());
//				DebugLog("Got it");
//			}
//#endif
            
			// Matching: "'l""
			// Replacing with: 'T'
            // Matching ': instead of '7'. Note: sometimes it's a '1' where the quote is the tip of the 1 on the left (detached) - test for this.
				if (isQuote(r->ch)
				&& (r->next != NULL) && isVerticalLine(r->next->ch)
				&& (tallHeightTest(statsWithoutCurrent.getPtr(), r->next->rect.size.height, 'T', false, 0, true) == 1)) {
				bool replaceThree = false;
				if ((r->next->next != NULL) && ((r->next->next->ch == '\'') || (r->next->next->ch == '`') || (r->next->next->ch == '"')))
					replaceThree = true;
				float newWidth = (replaceThree? rectRight(r->next->next->rect) - rectLeft(r->rect) + 1
								  : rectRight(r->next->rect) - rectLeft(r->rect) + 1);
				if ((rectSpaceBetweenRects(r->rect, r->next->rect) <= 0) && (!replaceThree || (rectSpaceBetweenRects(r->next->rect, r->next->next->rect) <= 0))) {
					float minBottom = MIN(rectBottom(r->rect), rectBottom(r->next->rect));
					if (replaceThree)
						minBottom = MIN(minBottom, rectBottom(r->next->next->rect));
					float maxTop = MAX(rectTop(r->rect), rectTop(r->next->rect));
					if (replaceThree)
						maxTop = MAX(maxTop, rectTop(r->next->next->rect));
					float newHeight = maxTop - minBottom + 1;
                    CGRect newRect(rectLeft(r->rect), minBottom, newWidth, newHeight);
                    // Test case where it's "'1" and we just need to nuke the quote
                    if (!replaceThree && isVerticalLine(r->next->ch)) {
                        bool nukeQuote = false;
                        if (isNormalDigitWidth(r, newRect, statsWithoutCurrent, results, true) == 0)
                            nukeQuote = true;
                        else if ((isNormalDigitWidth(r, newRect, statsWithoutCurrent, results, false) == 0) && results->imageTests) {
                            // Width test passed only in strict mode, i.e. pattern is a tad wide. Need other criteria, namely that the quote is too low
                            SingleLetterTests *st = CreateSingleLetterTests(newRect, results);
                            if (st != NULL) {
                                ConnectedComponentList cpl = st->getConnectedComponents();
                                if (cpl.size() == 3) {
                                    ConnectedComponent mainCC = cpl[1], quoteCC = cpl[2];
                                    CGRect oneRect;
                                    oneRect.origin.x = newRect.origin.x + mainCC.xmin;
                                    oneRect.origin.y = newRect.origin.y + mainCC.ymin;
                                    oneRect.size.width = mainCC.getWidth();
                                    oneRect.size.height = mainCC.getHeight();
                                    CGRect quoteRect;
                                    quoteRect.origin.x = newRect.origin.x + quoteCC.xmin;
                                    quoteRect.origin.y = newRect.origin.y + quoteCC.ymin;
                                    quoteRect.size.width = quoteCC.getWidth();
                                    quoteRect.size.height = quoteCC.getHeight();
                                    if ((isNormalDigitWidth(r, oneRect, statsWithoutCurrent, results, true) == 0)
                                        // Quote part not on top
                                        && (quoteCC.ymin > newRect.size.height * 0.15)) {
                                        nukeQuote = true;
                                    }
                                }
                                delete st;
                            } // st != NULL
                        }
                        if (nukeQuote) {
                            // Just eliminate the quote - glued so probably redundant
                            replaceTwo(r, r->next->ch, "rule 0452");
                            makeAnotherPass = true;
                            // No need to advance r, removing current is an advancement
                            continue;
                        }
                    }
                    SingleLetterTests *st = CreateSingleLetterTests(newRect, results);
                    if (st != NULL) {
                        ConnectedComponentList cpl = st->getConnectedComponents();
                        if (cpl.size() == 2) {
                            wchar_t newCh = '\0';
                            newCh = SingleLetterTestAs17T(r, newRect, statsWithoutCurrentAndNext, results, &st);
                            // If above test can't decide, make a guess
                            if (newCh == '\0') {
                                if (replaceThree) {
                                    newCh = 'T';
                                } else {
                                    if ((r->next->ch == '/') 
                                        || ((r->previous != NULL) && isDigit(r->previous->ch))
                                        || ((r->next->next != NULL) && isDigit(r->next->next->ch))
                                        ){
                                        newCh = '7';
                                    } else {
                                        // Could be part of a '4', if tall enough, located around the middle/top and curved to the left
                                            // Tall enough
                                        if ((r->rect.size.height > r->next->rect.size.height * 0.30)
                                            // Doesn't drop too low
                                            && (rectTop(r->next->rect) - rectTop(r->rect) > r->next->rect.size.height * 0.20)) {
                                            if (results->imageTests) {
                                                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                                                if (st != NULL) {
                                                    OpeningsTestResults right;
                                                    bool success = st->getOpenings(right,
                                                        SingleLetterTests::Right,
                                                        0.00,      // Start of range to search (top/left)
                                                        1.00,      // End of range to search (bottom/right)
                                                        SingleLetterTests::Bound,   // Require start (top/left) bound
                                                        SingleLetterTests::Bound);  // Require end (bottom/right) bound
                                                    if (success && (right.maxDepth > r->rect.size.width * 0.15)) {
                                                        newCh = '4';
                                                        // Fall through, will get replaced
                                                    }
                                                    delete st;
                                                }
                                            }
                                        }
                                        if (newCh == '\0') {
                                            // Just eliminate the quote - glued so probably redundant
                                            replaceTwo(r, r->next->ch, "rule 0452");
                                            makeAnotherPass = true;
                                            // No need to advance r, removing current is an advancement
                                            continue;
                                        }
                                    }
                                }
                            }

                            if (newCh != '\0') {
                                if (replaceThree) {
                                    ReplacingLog("Validate: rule 0452 replacing [%c%c%c] with [%c] in [%s]", (unsigned short)r->ch, (unsigned short)r->next->ch, (unsigned short)r->next->next->ch, (unsigned short)newCh, toUTF8(r->word->text()).c_str());
                                    r->word->removeLetter(r->next->next);
                                    r->word->removeLetter(r->next);
                                } else {
                                    ReplacingLog("Validate: rule 0452 replacing [%c%c] with [%c] in [%s]", (unsigned short)r->ch, (unsigned short)r->next->ch, (unsigned short)newCh, toUTF8(r->word->text()).c_str());
                                    r->word->removeLetter(r->next);
                                }
                                r->word->updateLetterWithNewCharAndNewRect(r, newCh, newRect);
                                makeAnotherPass = true;
                            }
                        } // single comp
                    } // st != NULL
                    delete st;
				}
			}
            
            // Matching: "$'" (glued quote)
			// Eliminating the quote
            if ((r->ch == '$') && (r->next != NULL) && ((r->next->ch == '\'') || (r->next->ch == '`') || (r->next->ch == '"'))
                    && (rectSpaceBetweenRects(r->rect, r->next->rect) <= 0)) {
                // Just eliminate the quote - glued so probably redundant
                replaceTwo(r, r->next->ch, "rule 0557");
                makeAnotherPass = true;
                // No need to advance r, removing current is an advancement
                continue;
            }

            // "CVI" instead of "ON"
            if ((r->ch == 'C') && (r->next != NULL) && (r->next->ch == 'V') && (r->next->next != NULL) && isVerticalLine(r->next->next->ch)) {
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect, r->next->next->rect);
                if ((combinedRect.size.width < results->globalStats.averageWidthDigits.average * 3 * 1.20)) {
                    wchar_t newCh1 = 'O', newCh2 = 'N';
                    CGRect rect1 = combinedRect;
                    rect1.size.width -= results->globalStats.averageWidthDigits.average;
                    CGRect rect2 = combinedRect;
                    rect2.origin.x = rectRight(rect1) + 1;
                    rect2.size.width = results->globalStats.averageWidthDigits.average;
                    ReplacingLog("Validate: rule 0647 replacing [%c%c%c] in word [%s] with [%c%c]", (unsigned short)r->ch, (unsigned short)r->next->ch, (unsigned short)r->next->next->ch, toUTF8(r->word->text()).c_str(), (unsigned short)newCh1, (unsigned short)newCh2);
                    replaceTwoWithRect(r, newCh1, rect1);
                    r->word->updateLetterWithNewCharAndNewRect(r->next, newCh2, rect2);
                    makeAnotherPass = true;
                }
            }
            
// 1.1T
//#if DEBUG
//			if ((r->ch=='T') && (r->previous != NULL) && (r->previous->ch =='1')) {
//                //CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect, r->next->next->rect);
//                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results); if (st != NULL) delete st;
//                DebugLog("Found in word [%s]", toUTF8(r->word->text()).c_str());
//				DebugLog("Got it");
//			}
//#endif
            
            // "I-1" instead of 'H'
            // "I.I" instead of 'U'
            if (isVerticalLine(r->ch) && (r->next != NULL) && ((r->next->ch == '-') || (r->next->ch == '.')) && (r->next->next != NULL) && (isVerticalLine(r->next->next->ch) || (r->next->next->ch == 'J')) && !(r->flags7 & FLAGS7_TESTED_AS_DISCONNECTED_UPPERCASE_ALL)) {
                CGRect CombinedRect = CreateCombinedRect(r->rect, r->next->rect, r->next->next->rect);
                // Looks like the H is a tad wider than average digit (18% wider), see https://drive.google.com/open?id=0B4jSQhcYsC9VU0ZoV2FoYmpNWWs at end of "1.99 ERCH 3 DR I.DRE @ 1.50 ERCI-J" line
                if ((CombinedRect.size.width < results->globalStats.averageWidthDigits.average * 1.20)
                    && (CombinedRect.size.width > results->globalStats.averageWidthDigits.average * 0.85)) {
                    r->flags7 |= FLAGS7_TESTED_AS_DISCONNECTED_UPPERCASE_ALL;
                    CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect, r->next->next->rect);
                    wchar_t newCh = testForUppercase(r, combinedRect, results, false);
                    if (newCh != '\0') {
                        replaceThreeWithRect(r, newCh, combinedRect, "rule 0652");
                        makeAnotherPass = true;
                    }
                }
            }

			OCRVerboseLog("OCRValidate: about to check 2-letters sequences");
			// ==================== STAGE WITH 2 LETTER SEQUENCES (2 letters sequences / two letters sequences) ========================
            
            //  -----------------------
            //0|                       |
            //1|   111111              |
            //2|  111111111 111        |
            //3|  11    111111         |
            //4|  11        1          |
            //5|  11        1          |
            //6|  11      1111         |
            //7|  11     11111         |
            //8|  11111111   1         |
            //9|  11111111  11         |
            //a|  11        11         |
            //b|  11        11         |
            //c|  11        11         |
            //d|  11        11         |
            //e|  11        11         |
            //f|  11        11         |
            //#| 111        1111111111 |
            //#|  11        1111111111 |
            //#|                       |
            //  -----------------------
            // "R." instead of "PL" / "A." instead of "PL"
            if (((r->ch == 'R') || (r->ch == 'A')) && (r->next != NULL) && (r->next->ch == '.') && (rectSpaceBetweenRects(r->rect, r->next->rect) <= results->globalStats.averageWidthDigits.average * 0.10)) {
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                if (combinedRect.size.width > results->globalStats.averageWidthDigits.average * 2 * 0.85) {
                    SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
                    if (st != NULL) {
                        SegmentList slBottom = st->getHorizontalSegments(0.90, 0.20);
                        if ((slBottom.size() == 2)
                            && (slBottom[0].startPos < results->globalStats.averageWidthDigits.average * 0.15)
                            && (slBottom[1].startPos > results->globalStats.averageWidthDigits.average * 0.85)
                            && (slBottom[1].endPos - slBottom[1].startPos + 1 > results->globalStats.averageWidthDigits.average * 0.80)) {
                            char newCh1 = 'P'; char newCh2 = 'L';
                            ReplacingLog("Validate: rule 0601 replacing, replacing [%c%c] with [%c%c] in word [%s]", (unsigned short)r->ch, (unsigned short)r->next->ch, (unsigned short)newCh1, newCh2, toUTF8(r->word->text()).c_str());
                            CGRect rect1(rectLeft(combinedRect), rectBottom(r->rect), slBottom[1].startPos, r->rect.size.height);
                            CGRect rect2(rectLeft(combinedRect)+slBottom[1].startPos, rectBottom(r->rect), slBottom[1].endPos - slBottom[1].startPos + 1, r->rect.size.height);
                            r->word->updateLetterWithNewCharAndNewRect(r, newCh1, rect1);
                            r->word->updateLetterWithNewCharAndNewRect(r->next, newCh2, rect2);
                        }
                        delete st;
                    }
                }
            }
            
//#if DEBUG
//            // AI.MOND
//			if ((r->ch=='I') && (r->previous != NULL) && (r->previous->ch =='E') && (r->previous->previous != NULL) && (r->previous->previous->ch =='E')) {
//                //CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
//                CGRect combinedRect = computeCapturingRectRight(r, statsWithoutCurrent, results);
//                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results); if (st != NULL) delete st;
//                DebugLog("Found in word [%s]", toUTF8(r->word->text()).c_str());
//				DebugLog("Got it");
//			}
//#endif
            
            //  ------------------
            //0|                  |
            //1|  111             |
            //2|  1               |
            //3| 11               |
            //4|  1               |
            //5|  11              |
            //6|  11              |
            //7|  11              |
            //8|  11              |
            //9|  11              |
            //a|  11              |
            //b|  11              |
            //c|  11              |
            //d|  11              |
            //e|  11              |
            //f|  11              |
            //#|  11              |
            //#|  11              |
            //#|  11              |
            //#|  11              |
            //#|  11              |
            //#|  11              |
            //#|  11              |
            //#|  11              |
            //#|  11              |
            //#|  111             |
            //#|  1111  1  11 111 |
            //#|  11111111111 111 |
            //#|   1111111111 111 |
            //#|      1       11  |
            //#|                  |
            //  ------------------
            // See https://drive.google.com/open?id=0B4jSQhcYsC9VaFdUNFlLMGs5eUk
            // "I." instead of 'L'
            // "L." instead of 'L'
            if ((isVerticalLine(r->ch) || (r->ch == 'L')) && (r->next != NULL) && (r->next->ch == '.') && (rectSpaceBetweenRects(r->rect, r->next->rect) <= results->retailerParams.minSpaceAroundDotsAsPercentOfWidth * results->globalStats.averageWidthDigits.average * 0.85)) {
                bool doit = false;
                wchar_t newCh = '\0';
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                if (testAsL(r, combinedRect, results, false)) {
                    doit = true;
                    newCh = 'L';
                }
                if (doit && (newCh != '\0')) {
                    replaceTwoWithRect(r, newCh, combinedRect, "rule 0658");
                    makeAnotherPass = true;
                }
			}
            
#if DEBUG
			if (((r->ch=='I') || (r->ch=='J')) && (r->next != NULL) && (r->next->ch =='I') && (r->next->next != NULL) && (r->next->next->ch == 'Z')) {
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results); if (st != NULL) delete st;
                DebugLog("Found in word [%s]", toUTF8(r->word->text()).c_str());
				DebugLog("Got it");
			}
#endif

            // "IJ" instead of 'N', see https://drive.google.com/open?id=0B4jSQhcYsC9VamQzdXZXaEM5bEk (blur 6)
            // "LJ" instead of 'U'
            // "lJ" instead of 'U'
			// "L1" instead of 'u'
            // "IJ" instead of 'U', see "GLCIJ" in https://drive.google.com/open?id=0B4jSQhcYsC9VLWNSTXFPalQ1bkU
            // "(J" intead of '0'
            // "IJ" instead of 'R', see https://drive.google.com/open?id=0B4jSQhcYsC9VamQzdXZXaEM5bEk (blur 6)
            // "IJ" instead of 'H', see https://drive.google.com/open?id=0B4jSQhcYsC9VamQzdXZXaEM5bEk (blur 6)
            // "FI" instead of 'R' (retiring rule 0637)
            // "IY" instead of 'R', see https://drive.google.com/open?id=0B4jSQhcYsC9VdWtwVEtGakpwbmc (blur radius 6)
            if (((isVerticalLine(r->ch) || (r->ch == 'J') || (r->ch == 'F') || (r->ch == '(') || (r->ch == 'L')) && (r->next != NULL) && (isVerticalLine(r->next->ch) || (r->next->ch == 'J') || (r->next->ch == 'Y')))
                && (rectRight(r->next->rect) - rectLeft(r->rect) + 1 < results->globalStats.averageWidthDigits.average * 1.20) && !(r->flags7 & FLAGS7_TESTED_AS_DISCONNECTED_UPPERCASE_ALL)) {
                r->flags7 |= FLAGS7_TESTED_AS_DISCONNECTED_UPPERCASE_ALL;
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                wchar_t newCh = testForUppercase(r, combinedRect, results, true);
                if (newCh != '\0') {
                    replaceTwoWithRect(r, newCh, combinedRect, "rule 0677");
                    makeAnotherPass = true;
                }
            }
            
            //  ----------------
            //0|                |
            //1|             11 |
            //2|             11 |
            //3|             11 |
            //4|             11 |
            //5|             11 |
            //6|             11 |
            //7|             11 |
            //8|             11 |
            //9|             11 |
            //a|             11 |
            //b|             11 |
            //c|             11 |
            //d|             11 |
            //e|             11 |
            //f|             11 |
            //#|  1          11 |
            //#| 111         11 |
            //#| 11          11 |
            //#| 11          11 |
            //#| 11          11 |
            //#| 11          11 |
            //#|  11        111 |
            //#|   11 1    111  |
            //#|    1111   11   |
            //#|    111111 11   |
            //#|    11111  1    |
            //#|                |
            //  ----------------
            // ".J" instead of 'J'
            if ((r->ch == '.') && (r->next != NULL) && (r->next->ch == 'J') && (rectSpaceBetweenRects(r->rect, r->next->rect) <= results->retailerParams.minSpaceAroundDotsAsPercentOfWidth * results->globalStats.averageWidthDigits.average * 0.75)) {
                bool doit = false;
                wchar_t newCh = '\0';
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
                if (st != NULL) {
                    SegmentList slBottom = st->getHorizontalSegments(0.925, 0.15);
                    float gap = largestGap(slBottom);
                    if (gap < results->retailerParams.minSpaceAroundDotsAsPercentOfWidth * results->globalStats.averageWidthDigits.average * 0.75) {
                        doit = true; newCh = 'J';
                    }
                    delete st;
                }
                if (doit && (newCh != '\0')) {
                    replaceTwoWithRect(r, newCh, combinedRect, "rule 0662");
                    makeAnotherPass = true;
                }
			}
            
            // "--" instead of '-'
            if ((r->ch == '-') && (r->next != NULL) && (r->next->ch == '-') && (rectSpaceBetweenRects(r->rect, r->next->rect) <= results->globalStats.averageWidthDigits.average * 0.15) && (rectRight(r->next->rect) - rectLeft(r->rect) + 1 < results->globalStats.averageWidthDigits.average * 1.20)) {
                replaceTwo(r, '-', "rule 0676");
                makeAnotherPass = true;
			}

            //  ----------
            //0|          |
            //1| 1     1  |
            //2| 1     11 |
            //3| 1     11 |
            //4| 11    11 |
            //5| 1     11 |
            //6| 1     11 |
            //7| 1     11 |
            //8| 1  11 11 |
            //9| 1  1  11 |
            //a| 1  1  11 |
            //b| 1  11 11 |
            //c| 1  11 1  |
            //d| 11  111  |
            //e|  11  11  |
            //f|  11  1   |
            //#|          |
            //  ----------
            // "IJ" instead of 'W', see https://drive.google.com/open?id=0B4jSQhcYsC9VTlJaWkFyRFlRQ00
            // "VJ" instead of 'W', see https://drive.google.com/open?id=0B4jSQhcYsC9VamQzdXZXaEM5bEk (blur radius 6)
            if ((isVerticalLine(r->ch) || (r->ch == 'L') || (r->ch == 'V')) && (r->next != NULL) && (r->next->ch == 'J') && !(r->flags7 & FLAGS7_TESTED_AS_DISCONNECTED_UPPERCASE_ALL)) {
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                if ((combinedRect.size.width < results->globalStats.averageWidthDigits.average * 1.15)
                    && (combinedRect.size.width > results->globalStats.averageWidthDigits.average * 0.85)) {
                    r->flags7 |= FLAGS7_TESTED_AS_DISCONNECTED_UPPERCASE_ALL;
                    wchar_t newCh = testForUppercase(r, combinedRect, results, true);
                    if (newCh != '\0') {
                        replaceTwoWithRect(r, newCh, combinedRect, "rule 0657");
                        makeAnotherPass = true;
                    }
                }
            }
            
            // "I-" instead of 'F'
            if (isVerticalLine(r->ch) && (r->next != NULL) && (r->next->ch == '-') ) {
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                if (combinedRect.size.width < results->globalStats.averageWidthDigits.average * 1.15) {
                    bool doit = false;
                    char newCh = '\0';
                    SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
                    if (st != NULL) {
                        SegmentList slRight = st->getVerticalSegments(0.80, 0.40);
                        if (slRight.size() == 2) {
                            float gap = largestGap(slRight);
                            if ((slRight[1].endPos < combinedRect.size.height * 0.65)
                                && (gap > combinedRect.size.height * 0.15)) {
                                newCh = 'F';
                                doit = true;
                            }
                        } else if (slRight.size() == 3) {
                            float gap = largestGap(slRight);
                            if ((slRight[0].endPos < combinedRect.size.height * 0.25)
                                && (slRight[1].startPos > combinedRect.size.height * 0.35)
                                && (slRight[1].endPos < combinedRect.size.height * 0.65)
                                && (slRight[2].startPos > combinedRect.size.height * 0.65)
                                && (slRight[2].endPos > combinedRect.size.height * 0.80)
                                && (gap > combinedRect.size.height * 0.15)) {
                                newCh = 'E';
                                doit = true;
                            }
                        }
                        delete st;
                    }
                    if (doit && (newCh != '\0')) {
                        replaceTwoWithRect(r, newCh, combinedRect, "rule 0653");
                        makeAnotherPass = true;
                    }
                }
            }
            
            // "13" instead of 'B'
            if (isVerticalLine(r->ch) && (r->next != NULL) && (r->next->ch == '3') && (rectSpaceBetweenRects(r->rect, r->next->rect) <= 0)) {
                bool doit = false;
                wchar_t newCh = '\0';
                CGRect CombinedRect = CreateCombinedRect(r->rect, r->next->rect);
                if ((CombinedRect.size.width < results->globalStats.averageWidthDigits.average * 1.15)
                    && (CombinedRect.size.width > results->globalStats.averageWidthDigits.average * 0.85)){
                    SingleLetterTests *st = CreateSingleLetterTests(CombinedRect, results, false, 0, 0.03, true);
                    if (st != NULL) {
                        //  -----------
                        //0|           |
                        //1| 11  1     |
                        //2| 111 1  11 |
                        //3| 11    111 |
                        //4| 1      11 |
                        //5|       11  |
                        //6|      111  |
                        //7|     111   |
                        //8|    111    |
                        //9|    111    |
                        //a|    1111   |
                        //b|       11  |
                        //c|        11 |
                        //d|        11 |
                        //e|        11 |
                        //f| 1      11 |
                        //#| 11     11 |
                        //#| 111  1111 |
                        //#|  11  11   |
                        //#|  11  1    |
                        //#|           |
                        //  -----------
                        // Could be the above, test for it
                        SegmentList slLeft = st->getVerticalSegments(0.10, 0.20);
                        if (slLeft.size() == 2) {
                            float gap = largestGap(slLeft);
                            if ((slLeft[0].endPos < CombinedRect.size.height * 0.35)
                                && (slLeft[1].startPos > CombinedRect.size.height * 0.65)
                                && (gap > CombinedRect.size.height * 0.25)) {
                                doit = true;
                                //  --------------
                                //0|              |
                                //1|  11111111    |
                                //2|  111111111   |
                                //3|  111    111  |
                                //4|   11     11  |
                                //5|   11     11  |
                                //6|   11     11  |
                                //7|   11     11  |
                                //8|   11    111  |
                                //9|   11    111  |
                                //a|   11111111   |
                                //b|   1111111    |
                                //c|   11    1111 |
                                //d|   11     111 |
                                //e|   11      11 |
                                //f|  111      11 |
                                //#|  111      11 |
                                //#|  11       11 |
                                //#|  11       11 |
                                //#| 1111    1111 |
                                //#| 11111111111  |
                                //#|  111111111   |
                                //#|              |
                                //  --------------
                                // Wait, don't tag THIS a '3'!
                                ConnectedComponentList invertCpl = st->getInverseConnectedComponents();
                                if ((invertCpl.size()>=2)
                                    && (invertCpl[1].getWidth() > CombinedRect.size.width * 0.20)
                                    && (invertCpl[1].getHeight() > CombinedRect.size.height * 0.20)) {
                                    newCh = 'B';
                                } else {
                                    newCh = '3';
                                }
                            }
                        }
                        if (newCh == '\0') {
                            // If it didn't match a '3', use a wider segment because of this pattern which started PAST the 20% mark (2 of 8)
                            //  ------------
                            //0|            |
                            //1|   1111111  |
                            //2|   11111111 |
                            //3|   11    11 |
                            //4|   11    11 |
                            //5|   11    11 |
                            //6|   11   111 |
                            //7|   11   11  |
                            //8|   1111111  |
                            //9|   11   111 |
                            //a|   11    11 |
                            //b|   11    11 |
                            //c|   11    11 |
                            //d|   1     11 |
                            //e|   1     11 |
                            //f|  111 11111 |
                            //#| 111111111  |
                            //#|            |
                            //  ------------
                            SegmentList slLeft = st->getVerticalSegments(0.15, 0.30);
                            float totLength = combinedLengths(slLeft);
                            if (totLength > CombinedRect.size.height * 0.80) {
                                //  ------------
                                //0|            |
                                //1| 11 1111    |
                                //2| 11 11 111  |
                                //3| 11     11  |
                                //4| 11     11  |
                                //5| 11      1  |
                                //6| 11      11 |
                                //7| 11      11 |
                                //8| 11      11 |
                                //9| 11      1  |
                                //a| 111     1  |
                                //b| 111 111    |
                                //c| 11  111    |
                                //d| 11   11    |
                                //e| 11   111   |
                                //f| 11    11   |
                                //#| 11    111  |
                                //#| 11     11  |
                                //#| 11     11  |
                                //#| 11      11 |
                                //#|  1       1 |
                                //#|            |
                                //  ------------
                                // The above matches - so now need to test for wide gap at bottom (=> R)
                                SegmentList slBottom = st->getHorizontalSegments(0.95, 0.10);
                                if (largestGap(slBottom) > CombinedRect.size.width * 0.25) {
                                    newCh = 'R'; doit = true;
                                } else {
                                    newCh = 'B'; doit = true;
                                }
                            }
                        }
                        if (newCh == '\0') {
                            DebugLog("Aborting rule 0656 13->B in word [%s]", toUTF8(r->word->text()).c_str());
                        }
                        delete st;
                    }
                }
                if (doit && (newCh != '\0')) {
                    replaceTwoWithRect(r, newCh, CombinedRect, "rule 0656");
                    makeAnotherPass = true;
                }
            }
            
#if DEBUG
			if ((r->ch=='I') && (r->next != NULL) && (r->next->ch =='R')) {
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
                if (st != NULL) delete st;
                DebugLog("Found in word [%s]", toUTF8(r->word->text()).c_str());
				DebugLog("Got it");
			}
#endif
            // "F3" instead of 'R' or 'A', see CVS https://drive.google.com/open?id=0B4jSQhcYsC9VU1U3OG1EY0V0NlE (actually NOT. There is a "FS" instead of 'A' but it grabs a piece of the 'K' that follows so it's too wide)
            // "FI" instead of 'A'
            // "IR" instead of 'A'
            if (((r->ch == 'F') && (r->next != NULL) && ((r->next->ch == '3') || isVerticalLine(r->next->ch)))
                || (isVerticalLine(r->ch) && (r->next != NULL) && (r->next->ch == 'R')))
                 {
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                if (combinedRect.size.width <= results->globalStats.averageWidthDigits.average * 1.20) {
                    //  ---------------
                    //0|               |
                    //1|    1111       |
                    //2| 1111111 11    |
                    //3| 111     111   |
                    //4| 11        11  |
                    //5| 111       1   |
                    //6|  11       11  |
                    //7| 111       111 |
                    //8| 11         11 |
                    //9| 111       111 |
                    //a| 111       11  |
                    //b| 11       11   |
                    //c|          11   |
                    //d| 11111111      |
                    //e| 111           |
                    //f| 111           |
                    //#| 111           |
                    //#| 111           |
                    //#| 111           |
                    //#| 111           |
                    //#| 111           |
                    //#| 111           |
                    //#| 11            |
                    //#|               |
                    //  ---------------
                    // Need to avoid acting on the above (tag as 'P' instead) - test lower part and demand at least 2 horizontal segment + which together span at least 85% of the width
                    wchar_t newCh = 'R';
                    bool doit = false;
                    SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
                    if (st != NULL) {
                        SegmentList slBottom = st->getHorizontalSegments(0.875, 0.25);
                        float widthBottom = totalWidth(slBottom);
                        if ((widthBottom > combinedRect.size.width * 0.85) && (slBottom.size() >= 2)) {
                            // Find largest gap below
                            float maxGap = largestGap(slBottom);
                            if (maxGap > combinedRect.size.width * 0.20)
                                doit = true;
                        } else if (slBottom.size() >= 1) {
                            // Possible 'P': either a single segment or multiple - either was must not be wide bottom + pattern close to left side and really narrow
                            if ((widthBottom < combinedRect.size.width * 0.30) && (slBottom[0].startPos < combinedRect.size.width * 0.15)) {
                                newCh = 'P'; doit = true;
                            }
                        }
                        if (st != NULL) delete st;
                        if (newCh == 'R') doit = false; // Means retiring this rule for FI -> R because rule 0677 replaces it
                    }
                    if (doit) {
                        replaceTwoWithRect(r, newCh, combinedRect, "rule 0637");
                        makeAnotherPass = true;
                    }
                }
            }

            // "//" instead of '/' (disconnected due to vertical line)
            if ((r->ch == '/') && (r->next != NULL) && (r->next->ch == '/') && (statsWithoutCurrentAndNext->averageHeightDigits.count >= 2)) {
                // One of them (or both) way too short yet combined having the right height
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                if ((combinedRect.size.height > statsWithoutCurrentAndNext->averageHeightDigits.average * 0.85) && (combinedRect.size.height < statsWithoutCurrentAndNext->averageHeightDigits.average * 1.15) && ((r->rect.size.height < statsWithoutCurrentAndNext->averageHeightDigits.average * 0.85) || (r->next->rect.size.height < statsWithoutCurrentAndNext->averageHeightDigits.average * 0.85)) && (combinedRect.size.width < statsWithoutCurrentAndNext->averageHeightDigits.average * 2)) {
                    replaceTwoWithRect(r, '/', combinedRect, "rule 0578");
                    makeAnotherPass = true;
                }
            }
            
#if DEBUG
            if ((r->ch=='-') && (r->next != NULL) && (r->next->ch=='1') && (r->previous != NULL) && (r->previous->ch == '0')) {
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
                if (st != NULL) delete st;
                DebugLog("Found in [%s]", toUTF8(r->word->text()).c_str());
                DebugLog("");
            }
#endif

            // Any dash glued to a digit is likely spurious - if combined it doesn't make it too wide
            // - quality: 87 [132,494 w=6,h=6]
            // 7 quality: 93 [138,494 w=17,h=39]
            // or
            // 2 quality: 92 [233,496 w=23,h=37]
            // - quality: 76 [254,520 w=4,h=4]
            if ((r->next != NULL) && (statsWithoutCurrent->averageWidthDigits.count >= 2)
                && ((((r->ch == '-') && (r->rect.size.width < statsWithoutCurrentAndNext->averageWidthDigits.average * 0.45) && isDigit(r->next->ch))
                    || (isDigit(r->ch) && (r->next->ch == '-') && (r->next->rect.size.width < statsWithoutCurrentAndNext->averageWidthDigits.average * 0.45))))
                && (rectSpaceBetweenRects(r->rect, r->next->rect) <= 0)) {
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                if (combinedRect.size.width < statsWithoutCurrent->averageWidthDigits.average * 1.15) {
                    wchar_t newCh = ((r->ch == '-')? r->next->ch:r->ch);
                    ReplacingLog("Validate: rule 0546 replacing, eliminating glued [-] in word [%s]", toUTF8(r->word->text()).c_str());
                    replaceTwoWithRect(r, newCh, combinedRect);
//                    r->word->updateLetterWithNewCharAndNewRect(r->next, newCh, combinedRect);
//                    SmartPtr<OCRRect> tmpR = r->next;
//                    r->word->removeLetter(r);
//                    r = tmpR;
                    // Let the digit get tested below
                }
            }
            // "-1" or "-I" instead of '4' (07-20-2015 Walmart) but with the '-' wider than the above limit of 0.45 av. digit width
            else if ((r->ch == '-') && (r->next != NULL) && ((r->next->ch == '1') || (r->next->ch == 'I')) && (statsWithoutCurrent->averageWidthDigits.count >= 2) && (rectSpaceBetweenRects(r->rect, r->next->rect) < statsWithoutCurrentAndNext->averageSpacingDigits.average)) {
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                if ((combinedRect.size.width < statsWithoutCurrentAndNext->averageWidthDigits.average * 1.15) && (combinedRect.size.width > statsWithoutCurrentAndNext->averageWidthDigits.average * 0.85)) {
                    SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
                    if (st != NULL) {
                        // Test single comp
                        ConnectedComponentList cpl = st->getConnectedComponents();
                        if (cpl.size() == 2) {
                            CGRect actualRect = combinedRect;
                            actualRect.origin.x += cpl[1].xmin;
                            actualRect.size.width = cpl[1].xmax - cpl[1].xmin + 1;
                            actualRect.origin.y += cpl[1].ymin;
                            actualRect.size.height = cpl[1].ymax - cpl[1].ymin + 1;
                            if ((actualRect.size.width < statsWithoutCurrentAndNext->averageWidthDigits.average * 1.15) && (actualRect.size.width > statsWithoutCurrentAndNext->averageWidthDigits.average * 0.85)) {
                            } // actual rect around width of a normal digit
                            // Finally, test that suspected '4' has an inverted comp on top part
                            ConnectedComponentList invertCpl = st->getInverseConnectedComponents();
                            if ((invertCpl.size() == 2) && ((invertCpl[1].ymax - invertCpl[1].ymin) < actualRect.size.height * 0.65)) {
                                // Replace!
                                replaceTwoWithRect(r, '4', actualRect, "rule 0558");
                                makeAnotherPass = true; // Let the new '4' get tested below
                            } // found hole on top part
                        } // single comp
                        delete st;
                    } // st != NULL
                } // around the width of a normal digit
            }

            // Dash too high + glued to '7' - eliminate
            if ((r->ch == '-') && (r->next != NULL) && (r->next->ch == '7') && (rectSpaceBetweenRects(r->rect, r->next->rect) < statsWithoutCurrentAndNext->averageSpacing.average)) {
                float gap = rectBottom(r->rect) - rectBottom(r->next->rect);
                if (gap < r->next->rect.size.height * 0.20) {
                    ReplacingLog("Validate: rule 0545 replacing, eliminating glued [%c] in word [%s]", (unsigned short)r->ch, toUTF8(r->word->text()).c_str());
                    CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                    r->word->updateLetterWithNewCharAndNewRect(r->next, r->next->ch, combinedRect);
                    SmartPtr<OCRRect> tmpR = r->next;
                    r->word->removeLetter(r);
                    r = tmpR;
                    // Let the '7' get tested below
                }
            }
            
//            // 1+5 instead of 5. 2015-06-17 commenting out because of false positives.
//            if ((r->ch == '1') && (r->next != NULL) && (r->next->ch == '5') && (rectSpaceBetweenRects(r->rect, r->next->rect) < rectSpaceBetweenRects(r->rect, r->next->rect) < statsWithoutCurrentAndNext->averageSpacing.average * 0.40)) {
//                bool doit = false;
//                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
//                if ((digitsOnly && (countCharsInCurrentWord > RETAILER_PRODUCT_NUMBER_LEN))
//                    || ((r->rect.size.height < statsWithoutCurrentAndNext->averageHeightDigits.average * 0.60)
//                    //&& (rectSpaceBetweenRects(r->rect, r->next->rect) <= 0)
//                    )) {
//#if DEBUG
//                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
//                delete st;
//#endif
//                    doit = true;
//                } else if (!(digitsOnly && (countLastDigitsSequence > RETAILER_PRODUCT_NUMBER_LEN))) {
//                    // Absent the above test, need the height to be suspicious or having two components (i.e. the left slice of the 5)
//                    SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
//                    if (st != NULL) {
//                        ConnectedComponentList cpl = st->getConnectedComponents();
//                        if (cpl.size() >= 3) {
//                            float gap;
//                            if (cpl[2].ymin > cpl[1].ymin)
//                                gap = cpl[2].ymin - cpl[1].ymin;
//                            else
//                                gap = cpl[1].ymin - cpl[2].ymax;
//                            if (gap > combinedRect.size.height * 0.15)
//                                doit = true;
//                        }
//                        delete st;
//                    }
//                }
//                if (doit) {
//                    ReplacingLog("Validate: rule 0546 replacing, eliminating glued [%c] in word [%s]", (unsigned short)r->ch, toUTF8(r->word->text()).c_str());
//                    r->word->updateLetterWithNewCharAndNewRect(r->next, r->next->ch, combinedRect);
//                    SmartPtr<OCRRect> tmpR = r->next;
//                    r->word->removeLetter(r);
//                    r = tmpR;
//                    // Let the '5' get tested below
//                }
//            }
            
            // :+3 instead of 3
            if ((r->ch == ':') && (r->next != NULL) && (r->next->ch == '3') && digitsOnly && (countCharsInCurrentWord > results->retailerParams.productNumberLen)) {
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                ReplacingLog("Validate: rule 0548 replacing, eliminating glued [%c] in word [%s]", (unsigned short)r->ch, toUTF8(r->word->text()).c_str());
                r->word->updateLetterWithNewCharAndNewRect(r->next, r->next->ch, combinedRect);
                SmartPtr<OCRRect> tmpR = r->next;
                r->word->removeLetter(r);
                r = tmpR;
                // Let the '3' get tested below
            }
            
            // C+3 instead of 3
            if ((r->ch == 'C') && (r->next != NULL) && (r->next->ch == '3') && (rectSpaceBetweenRects(r->rect, r->next->rect) <= 0)
                // Even combined, not much wider than a normal digit
                && (statsWithoutCurrentAndNext->averageWidthDigits.count >= 1) && (rectRight(r->next->rect) - rectLeft(r->rect) + 1 < statsWithoutCurrentAndNext->averageWidthDigits.average * 1.15)) {
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                ReplacingLog("Validate: rule 0549 replacing, eliminating glued [%c] in word [%s]", (unsigned short)r->ch, toUTF8(r->word->text()).c_str());
                r->word->updateLetterWithNewCharAndNewRect(r->next, r->next->ch, combinedRect);
                SmartPtr<OCRRect> tmpR = r->next;
                r->word->removeLetter(r);
                r = tmpR;
                // Let the '3' get tested below
            }

            //  ------------
            //0|            |
            //1|        11  |
            //2|        11  |
            //3|      1 11  |
            //4|      1 11  |
            //5|    111 11  |
            //6|   11   11  |
            //7|   11   11  |
            //8|        11  |
            //9|        11  |
            //a| 1      11  |
            //b| 11     11  |
            //c| 111111 111 |
            //d| 1 1111 111 |
            //e|        11  |
            //f|        11  |
            //#|        11  |
            //#|        11  |
            //#|        11  |
            //#|            |
            //  ------------
            
            // "-1" instead of '4' with 2 connected comps for the "-"
            if ((r->ch == '-') && (r->next != NULL) && isVerticalLine(r->next->ch) && (rectSpaceBetweenRects(r->rect, r->next->rect) < r->next->rect.size.height * 0.11)) {
                float referenceWidth = 0;
                if (statsWithoutCurrent->averageWidthDigits.count >= 2) {
                    referenceWidth = statsWithoutCurrent->averageWidthDigits.average;
                } else if (statsWithoutCurrent->averageWidthUppercase.count >= 2) {
                    referenceWidth = statsWithoutCurrent->averageWidthUppercase.average;
                }
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                if ((combinedRect.size.width > referenceWidth * 0.85) && (combinedRect.size.width < referenceWidth * 1.15)) {
                    bool doit = false;
                    // Make rect taller for the cases where Blink returned a rect only around the middle part
                    CGRect tallerRect(rectLeft(r->rect), rectBottom(r->next->rect), r->rect.size.width, r->next->rect.size.height);
                    SingleLetterTests *st = CreateSingleLetterTests(tallerRect, results);
                    SingleLetterTests *stNext = CreateSingleLetterTests(r->next->rect, results);
                    if ((st != NULL) && (stNext != NULL)) {
                        ConnectedComponentList cplNext = stNext->getConnectedComponents();
                        ConnectedComponentList cpl = st->getConnectedComponents();
                        if ((cpl.size() >= 3) && (cplNext.size() >= 2)) {
                            /* Test all connected comps and:
                               1. Find a comp on top sloping right
                               2. Find a comp around the middle wider at bottom than top
                             */
                             float areaNext = cplNext[0].area;
                             bool gotTop = false, gotMiddle = false;
                             CGRect topRect, middleRect;
                             for (int i=1; i<cpl.size(); i++) {
                                ConnectedComponent cc = cpl[i];
                                CGRect adjustedRect (rectLeft(tallerRect) + cc.xmin, rectBottom(tallerRect) + cc.ymin, cc.getWidth(), cc.getHeight());
                                if (!gotTop) {
                                    if ((rectTop(adjustedRect) < rectBottom(r->next->rect) + r->next->rect.size.height * 0.50)
                                        && ((float)cc.area > areaNext * 0.10)) {
                                        // Verify slopping right
                                        SegmentList top = st->getHorizontalSegments((cc.ymin + cc.getHeight()*0.10)/tallerRect.size.height, 0.01);
                                        SegmentList bottom = st->getHorizontalSegments((cc.ymax - cc.getHeight()*0.10)/tallerRect.size.height, 0.01);
                                        if ((top.size() >= 1) && (bottom.size() >= 1)
                                            && (top[0].startPos > bottom[0].startPos)
                                            && (top[top.size()-1].endPos > bottom[bottom.size()-1].endPos)) {
                                            gotTop = true;
                                            topRect = adjustedRect;
                                            continue;
                                        }
                                    }
                                }
                                if (!gotMiddle) {
                                    if ((rectTop(adjustedRect) > (rectBottom(r->next->rect) + r->next->rect.size.height * 0.50))
                                        && (rectTop(adjustedRect) < (rectBottom(r->next->rect) + r->next->rect.size.height * 0.85))
                                        && ((float)cc.area > areaNext * 0.10)) {
                                        SegmentList top = st->getHorizontalSegments((cc.ymin + cc.getHeight()*0.20)/tallerRect.size.height, 0.01);
                                        SegmentList bottom = st->getHorizontalSegments((cc.ymax - cc.getHeight()*0.10)/tallerRect.size.height, 0.20);
                                        if ((top.size() >= 1) && (bottom.size() == 1)
                                            && (top[0].startPos >= bottom[0].startPos)
                                            && (top[top.size()-1].endPos < bottom[bottom.size()-1].endPos)
                                            && (bottom[bottom.size()-1].endPos - bottom[0].startPos + 1 > adjustedRect.size.width * 0.80)) {
                                            gotMiddle = true;
                                            middleRect = adjustedRect;
                                            continue;
                                        }
                                    }
                                }
                             } // iterate over comps
                            if (gotTop && gotMiddle && (rectTop(topRect) <= rectBottom(middleRect) && (rectLeft(topRect) >= rectLeft(middleRect))))
                                doit = true;
                        } // got expected comps
                        delete st; delete stNext;
                    } // for st's
                    if (doit) {
                        replaceTwoWithRect(r, '4', combinedRect, "rule 0570");
                    }
                }
            }

            // "1I" instead of '4'
            // 2 [20,303 - 31,322] w=11,h=20]
            // 8 [34,303 - 45,322] w=11,h=20]
            // 1 q[47,309 - 52,317] w=5,h=9]
            // I [55,304 - 59,322] w=4,h=19]
            // 1 [64,305 - 69,322] w=5,h=18]
            //  --------------
            //0|              |
            //1|          1   |
            //2|          11  |
            //3|          11  |
            //4|          11  |
            //5|          11  |
            //6|     1    11  |
            //7|    11    11  |
            //8|    11    11  |
            //9|          11  |
            //a|   1      1   |
            //b|  11      11  |
            //c|  11      11  |
            //d| 1111    1111 |
            //e|  11     111  |
            //f|          11  |
            //#|          11  |
            //#|          11  |
            //#|          11  |
            //#|          11  |
            //#|              |
            //  --------------
            // TBD, see https://www.pivotaltracker.com/story/show/104731722
            
            // "C1" instead of '4'
            //  ------------
            //0|            |
            //1|         11 |
            //2|        111 |
            //3|       1111 |
            //4|      11 11 |
            //5|         11 |
            //6|    1    11 |
            //7|   11    11 |
            //8|  111    11 |
            //9|  11     11 |
            //a|  11     11 |
            //b| 1       11 |
            //c| 11      11 |
            //d| 1111   111 |
            //e| 1111111111 |
            //f|  11    111 |
            //#|         11 |
            //#|         11 |
            //#|         11 |
            //#|         11 |
            //#|         11 |
            //#|            |
            //  ------------
            // 2015-10-08 17:06:29.786 Windfall[23635:573696] #344: 2 quality: 91 [476,469 - 487,488] w=11,h=20]
            // 2015-10-08 17:06:29.786 Windfall[23635:573696] #345: . quality: 99 [493,486 - 496,488] w=3,h=3]
            // 2015-10-08 17:06:29.786 Windfall[23635:573696] #346: C quality: 51 [503,475 - 508,483] w=5,h=9]
            // 2015-10-08 17:06:29.786 Windfall[23635:573696] #347: 1 quality: 81 [507,469 - 513,488] w=6,h=20]
            // 2015-10-08 17:06:29.786 Windfall[23635:573696] #348: 9 quality: 87 [516,469 - 528,488] w=12,h=20]
            
            //2015-10-31 21:34:12.471 Windfall[24333:1594542] #337: $ quality: 67 [490,352 - 502,373] w=12,h=22]
            //2015-10-31 21:34:12.471 Windfall[24333:1594542] #338: 3 quality: 85 [504,352 - 515,370] w=11,h=19]
            //2015-10-31 21:34:12.471 Windfall[24333:1594542] #339: . quality: 84 [521,367 - 524,371] w=3,h=5]
            //2015-10-31 21:34:12.471 Windfall[24333:1594542] #340: X quality: 55 [529,357 - 534,366] w=5,h=10]
            //2015-10-31 21:34:12.472 Windfall[24333:1594542] #341: 1 quality: 75 [535,352 - 539,371] w=4,h=20]
            //2015-10-31 21:34:12.472 Windfall[24333:1594542] #342: 9 quality: 87 [542,352 - 553,370] w=11,h=19]
            
            // "Z1" instead of '4'
            //  -------------
            //0|             |
            //1|          1  |
            //2|          11 |
            //3|         111 |
            //4|        1111 |
            //5|          11 |
            //6|     11   11 |
            //7|     11   11 |
            //8|    111   11 |
            //9|    11    11 |
            //a|   11     11 |
            //b|  111     11 |
            //c|  11      11 |
            //d| 111      11 |
            //e| 1111111 111 |
            //f|  111111 111 |
            //#|          11 |
            //#|          11 |
            //#|          11 |
            //#|          11 |
            //#|          11 |
            //#|             |
            //  -------------
            //2015-11-17 12:14:04.549 Windfall[52915:3490254] #164: 1 quality: 89 [81,184 - 89,204] w=9,h=21]
            //2015-11-17 12:14:04.549 Windfall[52915:3490254] #165: Z quality: 64 [93,189 - 99,198] w=7,h=10]
            //2015-11-17 12:14:04.549 Windfall[52915:3490254] #166: 1 quality: 79 [100,184 - 103,203] w=4,h=20]
            //2015-11-17 12:14:04.549 Windfall[52915:3490254] #167: 0 quality: 86 [107,185 - 118,203] w=12,h=19]
            
            // Be more strict for the "X1" case
            if ((isCLookalike(r->ch) || (r->ch == '-') || (r->ch == '.') || (r->ch == 'z') || (r->ch == 'Z') || (r->ch == '/') || ((r->ch == 'X') && (r->next != NULL) && (r->next->ch == '1'))) && (r->next!= NULL) && isVerticalLine(r->next->ch) && (statsWithoutCurrentAndNext->averageHeightDigits.count > 0))
            {
                float referenceHeight = statsWithoutCurrentAndNext->averageHeightDigits.average;
                if (statsWithoutCurrentAndNext->averageHeightUppercase.count > statsWithoutCurrentAndNext->averageHeightDigits.count)
                    referenceHeight = statsWithoutCurrentAndNext->averageHeightUppercase.average;
                float referenceWidth = statsWithoutCurrentAndNext->averageWidthDigits.average;
                if (referenceWidth == 0)
                    referenceWidth = statsWithoutCurrentAndNext->averageWidthUppercase.average;
                if (referenceWidth == 0)
                    referenceWidth = results->globalStats.averageWidthDigits.average;
                bool gluedtoPrevious = ((r->previous != NULL) && (rectSpaceBetweenRects(r->previous->rect, r->rect) <= referenceHeight * 0.07));
                bool gluedtoNext;
                // In this example the space between / and 1 was 2 (vs height 19) so allow for larger space. OK because we demand that the / be not too heigh and located properly (not to mention curved)
                //2015-10-31 21:06:41.414 Windfall[23802:1577107] #275: $ quality: 88 [490,305 - 501,326] w=11,h=22]
                //2015-10-31 21:06:41.414 Windfall[23802:1577107] #276: 2 quality: 86 [504,306 - 514,324] w=10,h=19]
                //2015-10-31 21:06:41.414 Windfall[23802:1577107] #277: . quality: 85 [520,321 - 523,325] w=3,h=5]
                //2015-10-31 21:06:41.414 Windfall[23802:1577107] #278: / quality: 48 [528,310 - 533,319] w=5,h=10]
                //2015-10-31 21:06:41.414 Windfall[23802:1577107] #279: 1 quality: 75 [535,306 - 539,324] w=4,h=19]
                //2015-10-31 21:06:41.415 Windfall[23802:1577107] #280: 9 quality: 89 [541,306 - 551,324] w=10,h=19]
                if (r->ch == '/')
                    gluedtoNext = ((r->next != NULL) && (rectSpaceBetweenRects(r->rect, r->next->rect) <= referenceHeight * 0.11));
                else
                    gluedtoNext = ((r->next != NULL) && (rectSpaceBetweenRects(r->rect, r->next->rect) <= referenceHeight * 0.07));
                // Glued to next, next looks like '1', line has digits (otherwise no need to bother creating a '4', useless on its own)
                if (!(r->flags2 & FLAGS2_TESTED_AS_4) && gluedtoNext && !gluedtoPrevious && (statsWithoutCurrentAndNext->averageHeightDigits.count > 0)
                    // Wide enough to be a '4'
                    && (rectRight(r->next->rect) - rectLeft(r->rect) + 1 > referenceWidth * 0.85)
                    // Not too wide
                    && (rectRight(r->next->rect) - rectLeft(r->rect) + 1 < referenceWidth * 1.15)
                    // 4 left side "nose" extends below midpoint of '1'
                    && (rectTop(r->rect) - rectBottom(r->next->rect) > referenceHeight * 0.50)
                    // ... but not too low
                    && (rectTop(r->rect) - rectBottom(r->next->rect) < referenceHeight * 0.80)
                    // 4 left side "nose" not too small
                    && (r->rect.size.height > referenceHeight * 0.25)
                    // 4 left side "nose" not too big
                    && (r->rect.size.height < referenceHeight * 0.70)) {
                    r->flags2 |= FLAGS2_TESTED_AS_4;
                    // Now test that the pattern is curved left
                    SingleLetterTests *st = CreateSingleLetterTests(r->rect, results, false);
                    if (st != NULL) {
                        OpeningsTestResults resRight;
                        bool success = st->getOpenings(resRight, SingleLetterTests::Right,
                                            0.00,      // Start of range to search (top/left)
                                            1.00,      // End of range to search (bottom/right)
                                            SingleLetterTests::Bound,   // Require start (top/left) bound
                                            SingleLetterTests::Bound  // Require end (bottom/right) bound
                                            );
                        if (success) {
                            // One last check: if r->ch == 'X' check no opening on left (as in a real X)
                            bool doit = true;
                            if (r->ch == 'X') {
                                OpeningsTestResults resLeft;
                                bool success = st->getOpenings(resLeft, SingleLetterTests::Left,
                                                0.00,      // Start of range to search (top/left)
                                                1.00,      // End of range to search (bottom/right)
                                                SingleLetterTests::Bound,   // Require start (top/left) bound
                                                SingleLetterTests::Bound  // Require end (bottom/right) bound
                                                );
                                if (success)
                                    doit = false;
                            }
                            if (doit) {
                                replaceTwo(r, '4', "rule 0455");
                                if (r->next == NULL) {
                                    delete st;
                                    continue;
                                }
                            }
                        }
                        delete st;
                    }
                }
            }
            
#if DEBUG
            if ((r->ch=='/') && (r->next != NULL) && (r->next->ch=='9')) {
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
                if (st != NULL) delete st;
                DebugLog("Found in [%s]", toUTF8(r->word->text()).c_str());
                DebugLog("");
            }
#endif
            
            if ((((r->ch == '1') && (r->next != NULL) && (r->next->ch == '3'))
                || ((r->ch == '/') && (r->next != NULL) && (r->next->ch == '9'))) && !(r->flags2 & FLAGS2_TESTED_AS_9)) {
                r->flags2 |= FLAGS2_TESTED_AS_9;
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                char newCh = '\0';
                bool doit = false;
                if ((combinedRect.size.width < results->globalStats.averageWidthDigits.average * 1.20) && (combinedRect.size.width > results->globalStats.averageWidthDigits.average * 0.80)) {
                    newCh = testAsDisconnectedDigit(r, combinedRect, statsWithoutCurrent, results, '9', '\0', true);
                    if (newCh != '\0')
                        doit = true;
                }
                if (doit && (newCh != '\0')) {
                    ReplacingLog("OCRValidate: rule 0687 replacing [%c%c] with [%c] in word [%s]", r->ch, r->next->ch, newCh, toUTF8(r->word->text()).c_str());
                    replaceTwoWithRect(r, newCh, combinedRect);
                    makeAnotherPass = true;
                }
            }

            // "11" instead of '0' where we have productLen + 1 digits => replace even if all we have to go by is width of the combined rect
            if (isVerticalLine(r->ch) && (r->next != NULL) && (isVerticalLine(r->next->ch)) && (results->retailerParams.productNumberLen > 6)) {
                int countBefore = countDigitLookalikes(r, false, results);
                int countAfter = countDigitLookalikes(r, true, results);
                if ((countBefore > 0) && (countAfter > 0) && (countBefore + countAfter == results->retailerParams.productNumberLen + 1)) {
                    CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                    if ((statsWithoutCurrentAndNext->averageWidthDigits.count >= 3) && (combinedRect.size.width < statsWithoutCurrentAndNext->averageWidthDigits.average * 1.15) && (combinedRect.size.width > statsWithoutCurrentAndNext->averageWidthDigits.average * 0.85)) {
                        CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
#if DEBUG
                        if ((r->previous != NULL) && (r->previous->ch=='6') && (r->next->next != NULL) && (r->next->next->ch == '1')) {
                            DebugLog("Found in [%s]", toUTF8(r->word->text()).c_str());
                            DebugLog("");
                        }
#endif
                        wchar_t newCh = testAsDisconnectedDigit(r, combinedRect, statsWithoutCurrent, results, '0', '6', true);
                        if ((newCh == '\0') && !(r->flags4 & FLAGS4_TESTED_AS_DISCONNECTED_DIGIT8)) {
                            r->flags4 |= FLAGS4_TESTED_AS_DISCONNECTED_DIGIT8;
                            newCh = testAsDisconnectedDigit(r, combinedRect, statsWithoutCurrent, results, '8', '\0', true);
                        }
                        if ((newCh == '\0') && !(r->flags5 & FLAGS5_TESTED_AS_DISCONNECTED_DIGIT2)) {
                            r->flags5 |= FLAGS5_TESTED_AS_DISCONNECTED_DIGIT2;
                            newCh = testAsDisconnectedDigit(r, combinedRect, statsWithoutCurrent, results, '2', '\0', true);
                        }
                        bool isSuspect = false;
                        if (newCh == '\0') {
                            newCh = '0';    // Better replace anyhow in UPC, we'll mark as suspect so it will get adjusted into a UPC code later
                            isSuspect = true;
                        }
                        ReplacingLog("OCRValidate: rule 0599 replacing [%c%c] with [%c] in word [%s] to make up exact product length", r->ch, r->next->ch, newCh, toUTF8(r->word->text()).c_str());
                        replaceTwoWithRect(r, newCh, combinedRect);
                        if (isSuspect) r->flags |= FLAGS_SUSPECT;
                        makeAnotherPass = true;
                        countDigitLookAlikesInCurrentWord--;
                    }
                } // count is productNumberLen + 1
            }
            
            // Test for sequence of digits which would be a valid UPC code if ignoring possible spurious dots (e.g. "08430535.54.5")
            if (results->retailerParams.productNumberUPC && isDigit(r->ch) && ((r->previous == NULL) || !isDigit(r->previous->ch))) {
                OCRRectPtr p = r;
                wstring possibleUPCNumber;
                bool foundDots = false;
                while (p != NULL) {
                    if (isDigitLookalikeExtended(p->ch))
                        possibleUPCNumber += p->ch;
                    else if (p->ch == '.') {
                        foundDots = true;
//#if DEBUG
//                        CGRect adjRect = p->rect;
//                        if ((p->previous != NULL) && isDigitLookalikeExtended(p->previous->ch))
//                            adjRect = p->previous->rect;
//                        else if ((p->next != NULL) && isDigitLookalikeExtended(p->next->ch))
//                            adjRect = p->next->rect;
//                        CGRect digitRect(rectLeft(p->rect), rectBottom(adjRect), p->rect.size.width, adjRect.size.height);
//                        SingleLetterTests *st = CreateSingleLetterTests(adjRect, results);
//                        if (st != NULL) delete st;
//#endif
                    } else
                        break;
                    p = p->next;
                }
                if ((possibleUPCNumber.size() == 12) && (foundDots)
                    && ((p == NULL) || ((p->ch == '/') || (p->ch == ' ') || (p->ch == '-') || (p->ch == '*')))) {
                    wstring convertedText = convertDigitsLookalikesToDigits(possibleUPCNumber);
                    if (RegexUtilsValidateUPCCode(convertedText)) {
                        RegexLog("Found UPC number with spurious dots [%s]", toUTF8(r->word->text()).c_str());
                        // Got it! Now simply remove the spurious dots
                        OCRRectPtr p = r;
                        int nDigits = 0;
                        while ((p != NULL) && (p->ch != ' ')) {
                            if (isDigitLookalikeExtended(p->ch)) {
                                if (++nDigits == 12)
                                    break;
                            }
                            if (p->ch == '.') {
                                OCRRectPtr tmpP = p->next;
                                r->word->removeLetter(p);
                                p = tmpP; continue;
                            }
                            p = p->next;
                        }
                    }
                }
            }
            
//#if DEBUG
//			if ((r->ch =='E') && (r->next != NULL) && (r->next->ch =='I') && (r->previous != NULL) && (r->previous->ch =='9')) {
//                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
//                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
//                if (st != NULL) delete st;
//				DebugLog("Found in [%s]", toUTF8(r->word->text()).c_str());
//                DebugLog("");
//			}
//#endif

            //2015-11-02 16:09:25.953 Windfall[7360:407933] #315: 9 quality: 75 [192,327 - 200,344] w=9,h=18]
            //2015-11-02 16:09:25.953 Windfall[7360:407933] #316: E quality: 68 [203,327 - 208,344] w=6,h=18]
            //2015-11-02 16:09:25.953 Windfall[7360:407933] #317: I quality: 68 [210,328 - 212,343] w=3,h=16]
            //2015-11-02 16:09:25.954 Windfall[7360:407933] #318: 7 quality: 83 [217,327 - 223,344] w=7,h=18]
            
            // Test for possible UPC sequence where we have 12 digit lookalikes, NOT matching UPC test but one of them marked as suspect or '$' (in which case we will only accept 5 or 6)
            if (results->retailerParams.productNumberUPC
                && ((r->flags & FLAGS_SUSPECT)
                    || (r->ch == '$')
                    || ((r->ch == '3') && ((r->previous == NULL) || (r->previous->ch == ' ') || (rectSpaceBetweenRects(r->previous->rect, r->rect) > statsWithoutCurrentAndNext->averageSpacing.average * 1.15)) && (r->rect.size.width < statsWithoutCurrent->averageWidthDigits.average * 0.85)))
                && (countCharsInCurrentWord == results->retailerParams.productNumberLen) && (countDigitLookAlikesInCurrentWord == 12)) {
                DebugLog("OCRValidate(): trying to find missing UPC digit in [%s]", toUTF8(r->word->text()).c_str());
                wstring productText;
                OCRRectPtr p = r->previous;
                OCRRectPtr lastDigitR = r;
                int previousDigits = 0;
                bool abort = false;
                bool weCareAboutOtherSuspect = (r->ch != '$');
#if DEBUG
                if (r->ch == '$') {
                    DebugLog("");
                }
#endif
                while ((p != NULL) && isDigitLookalikeExtended(p->ch)) {
                    productText = p->ch + productText;
                    previousDigits++;
                    if (weCareAboutOtherSuspect && (p->flags & FLAGS_SUSPECT)) {
                        // We can't risk replacing one suspect digit if another is tagged as suspect too!
                        DebugLog("OCRValidate(): aborting UPC fix, 2nd suspect digit [%c] left of [%c] in [%s]", (unsigned short)p->ch, (unsigned short)r->ch, toUTF8(r->word->text()).c_str());
                        abort = true;
                        break;
                    }
                    p = p->previous;
                }
                if (!abort) {
                    productText = productText + r->ch;
                    p = r->next;
                    while ((p != NULL) && isDigitLookalikeExtended(p->ch)) {
                        productText = productText + p->ch;
                        lastDigitR = p;
                        if (weCareAboutOtherSuspect && (p->flags & FLAGS_SUSPECT)) {
                            // We can't risk replacing one suspect digit if another is tagged as suspect too!
                            DebugLog("OCRValidate(): aborting UPC fix, 2nd suspect digit [%c] right of [%c] in [%s]", (unsigned short)p->ch, (unsigned short)r->ch, toUTF8(r->word->text()).c_str());
                            abort = true;
                            break;
                        }
                        p = p->next;
                    }
                }
                if (!abort && (productText.length() == 12)) {
                    productText = convertDigitsLookalikesToDigits(productText);
                    if (!RegexUtilsValidateUPCCode(productText)) {
                        wchar_t validChForUPC = RegexUtilsDetermineMissingUPCDigits(productText, previousDigits);
                        // Accept suggested alternate digit if flagged as suspect or was a '3' that's actually '9' or '8' (3 being the possible right side of these digits)
                        if (validChForUPC != '\0') {
                            if (((r->flags & FLAGS_SUSPECT)
                                || ((r->ch == '3') && ((validChForUPC == '9') || (validChForUPC == '8')))
                                || (((r->ch == '5') || (r->ch == '$')) && (validChForUPC == '6'))
                                || (((r->ch == '6') || (r->ch == '$')) && (validChForUPC == '5')))) {
                                ReplacingLog("Validate: rule 0571 replacing [%c] with [%c] in word [%s] to make it a valid UPC code", (unsigned short)r->ch, (unsigned short)validChForUPC, toUTF8(r->word->text()).c_str());
                                r->word->updateLetterWithNewCharAndNewRect(r, validChForUPC, r->rect);
                                makeAnotherPass = true;
                                r = lastDigitR->next;
                                if (r == NULL) break; // Entire item is the product number, which is perfect - stop testing
                                continue;
                            }
#if DEBUG
                            else {
                                ReplacingLog("Validate: rule 0571 NOT replacing [%c] with [%c] in word [%s] to make it a valid UPC code", (unsigned short)r->ch, (unsigned short)validChForUPC, toUTF8(r->word->text()).c_str());
                            }
#endif
                        }
                    }
                }
            }
            
            // Test for possible UPC sequence where we have 13 chars, one of them not a digit lookalike but which combined with next or previous letter, makes up a possible digit, then find which digit makes it a UPC code
            if (results->retailerParams.productNumberUPC && (r->next != NULL) && (!isDigitLookalikeExtended(r->ch) || (!isDigitLookalikeExtended(r->next->ch))) && (countCharsInCurrentWord == results->retailerParams.productNumberLen + 1) && (countDigitLookAlikesInCurrentWord == 12) && (rectSpaceBetweenRects(r->rect, r->next->rect) < statsWithoutCurrentAndNext->averageSpacingDigits.average)) {
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                if ((combinedRect.size.width < statsWithoutCurrentAndNext->averageWidthDigits.average * 1.15) && (combinedRect.size.width > statsWithoutCurrentAndNext->averageWidthDigits.average * 0.85)) {
                    DebugLog("OCRValidate(): trying to find missing UPC digit in [%s]", toUTF8(r->word->text()).c_str());
                    wstring productText;
                    OCRRectPtr p = r->previous;
                    int previousDigits = 0;
                    while ((p != NULL) && isDigitLookalikeExtended(p->ch)) {
                        productText = p->ch + productText;
                        previousDigits++;
                        p = p->previous;
                    }
                    productText = productText + L'0';
                    p = r->next->next;
                    if (productText.length() < 12) {
                        while ((p != NULL) && isDigitLookalikeExtended(p->ch)) {
                            productText = productText + p->ch;
                            p = p->next;
                        }
                    }
                    // PQTODO looks like we close a blind eye to the possibility that after the digits we have a non-digits (as opposed to end of line or space), even though regexes only allow a few specific characters to be glued after product numbers. I guess we should test if the glued character is one of these allowed characters.
                    if (productText.length() == 12) {
                        productText = convertDigitsLookalikesToDigits(productText);
                        wchar_t validChForUPC = RegexUtilsDetermineMissingUPCDigits(productText, previousDigits);
                        if (validChForUPC != '\0') {
                            replaceTwoWithRect(r, validChForUPC, combinedRect, "rule 0559");
                            makeAnotherPass = true;
                            r = p; continue;    // Leave this sequence alone!
                        }
                    }
                }
            }
            
            // Test for possible UPC sequence where we have 13-15 chars, 11 digit lookalikes and where these 1-3 non-digit chars can be replaced with one digit to make it a UPC code
            if (results->retailerParams.productNumberUPC && (countDigitLookAlikesInCurrentWord == 11) && !isDigitLookalikeExtended(r->ch)) {
                // Count how many non-digits we have (starting here)
                int numNonDigits = 1;
                CGRect combinedRect = r->rect;
                OCRRectPtr p = r->next;
                while (p != NULL) {
                    if (!isDigitLookalikeExtended(p->ch)) {
                        numNonDigits++;
                        combinedRect = CreateCombinedRect(combinedRect, p->rect);
                    }
                    else break;
                    p = p->next;
                }
                OCRRectPtr pSecondPart = p;

                if ((combinedRect.size.width < statsWithoutCurrentAndNext->averageWidthDigits.average * 1.15)) {
                    DebugLog("OCRValidate(): trying to find missing UPC digit in [%s]", toUTF8(r->word->text()).c_str());
                    wstring productText;
                    OCRRectPtr p = r->previous;
                    int previousDigits = 0;
                    while ((p != NULL) && isDigitLookalikeExtended(p->ch)) {
                        productText = p->ch + productText;
                        previousDigits++;
                        p = p->previous;
                    }
                    productText = productText + L'0';
                    p = pSecondPart;
                    while ((p != NULL) && isDigitLookalikeExtended(p->ch)) {
                        productText = productText + p->ch;
                        p = p->next;
                    }
                    if (productText.length() == 12) {
                        productText = convertDigitsLookalikesToDigits(productText);
                        wchar_t validChForUPC = RegexUtilsDetermineMissingUPCDigits(productText, previousDigits);
                        if (validChForUPC != '\0') {
                            ReplacingLog("Validate: rule 0572 replacing %d chars starting with [%c] with [%c] in word [%s] to make it a valid UPC code", numNonDigits, (unsigned short)r->ch, (unsigned short)validChForUPC, toUTF8(r->word->text()).c_str());
                            r->word->updateLetterWithNewCharAndNewRect(r, validChForUPC, combinedRect);
                            for (int k=0; k<numNonDigits-1; k++)
                                r->word->removeLetter(r->next);
                            makeAnotherPass = true;
                            r = r->next; continue;
                        }
                    }
                }
            }

            // Test for 2 glued (or almost glued) characters, not both a '1', where total digits is product number len + 1, and retailer uses UPC codes: find the digit we need to insert whereby a valid UPC code is formed
            if (results->retailerParams.productNumberUPC && digitsOnly && (countCharsInCurrentWord == results->retailerParams.productNumberLen + 1) && (r->next != NULL) && ((r->ch != '1') || (r->next->ch != '1')) && (rectSpaceBetweenRects(r->rect, r->next->rect) < statsWithoutCurrentAndNext->averageSpacingDigits.average)) {
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                if ((combinedRect.size.width < statsWithoutCurrentAndNext->averageWidthDigits.average * 1.15) && (combinedRect.size.width > statsWithoutCurrentAndNext->averageWidthDigits.average * 0.85)) {
                    // First try to recognize the combined pattern as a digit
                    wchar_t newCh = '\0';
                    if (!(r->flags4 & FLAGS4_TESTED_AS_DISCONNECTED_DIGIT0)) {
                        newCh = testAsDisconnectedDigit(r, combinedRect, statsWithoutCurrent, results, '0', '\0', true);
                        r->flags4 |= FLAGS4_TESTED_AS_DISCONNECTED_DIGIT0;
                    }
                    if ((newCh == '\0') && !(r->flags4 & FLAGS4_TESTED_AS_DISCONNECTED_DIGIT8)) {
                        newCh = testAsDisconnectedDigit(r, combinedRect, statsWithoutCurrent, results, '8', '\0', true);
                        r->flags4 |= FLAGS4_TESTED_AS_DISCONNECTED_DIGIT8;
                    }
                    if ((newCh == '\0') && !(r->flags4 & FLAGS4_TESTED_AS_DISCONNECTED_DIGIT6)) {
                        newCh = testAsDisconnectedDigit(r, combinedRect, statsWithoutCurrent, results, '6', '\0', true);
                        r->flags4 |= FLAGS4_TESTED_AS_DISCONNECTED_DIGIT6;
                    }
                    if ((newCh == '\0') && !(r->flags3 & FLAGS3_TESTED_AS_DISCONNECTED_DIGIT9)) {
                        newCh = testAsDisconnectedDigit(r, combinedRect, statsWithoutCurrent, results, '9', '\0', true);
                        r->flags3 |= FLAGS3_TESTED_AS_DISCONNECTED_DIGIT9;
                    }
                    if (newCh != '\0') {
                        replaceTwoWithRect(r, newCh, combinedRect, "rule 0590 unknown disconnected digit");
                        makeAnotherPass = true;
                    } else {
                        wstring productText;
                        OCRRectPtr p = r->previous;
                        int previousDigits = 0;
                        while ((p != NULL) && isDigit(p->ch)) {
                            productText = p->ch + productText;
                            previousDigits++;
                            p = p->previous;
                        }
                        productText = productText + L'0';
                        p = r->next->next;
                        while ((p != NULL) && isDigit(p->ch)) {
                            productText = productText + p->ch;
                            p = p->next;
                        }
                        wchar_t validChForUPC = RegexUtilsDetermineMissingUPCDigits(productText, previousDigits);
                        if (validChForUPC != '\0') {
                            replaceTwoWithRect(r, validChForUPC, combinedRect, "rule 0559");
                        }
                    }
                }
            }

            // "V/" instead of 'W'
            if ((r->ch == 'V') && (r->next!= NULL) && (r->next->ch == '/') && (rectSpaceBetweenRects(r->rect, r->next->rect) <= 0)) {
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
                if (st != NULL) {
                    ConnectedComponentList cpl = st->getConnectedComponents();
                    // Because we think it's a 'W', be tolerant of additional connected components - as long as they are all the way at the bottom (below the shadow of the 'W' on the right) or at the very top (if it's the dot of a 'i')
                    bool doit = true;
                    if (cpl.size() > 2) {
                        // Test all spurious components
                        ConnectedComponent mainCC = cpl[1];
                        for (int i = 2; i<cpl.size(); i++) {
                            ConnectedComponent newCC = cpl[i];
                                // Make sure it's to the right
                            if ((newCC.xmin < combinedRect.size.width * 0.66)
                                && (newCC.area > mainCC.area * 0.25)) {
                                doit = false;
                                break;
                            }
                        }
                    } // cpl.size() > 2
                    if (doit) {
                        // Now test for the presence of an opening at the bottom
                        OpeningsTestResults bottom;
                        bool success = st->getOpenings(bottom,
                                SingleLetterTests::Bottom,
                                0.15,      // Start of range to search (top/left)
                                0.85,      // End of range to search (bottom/right)
                                SingleLetterTests::Bound,   // Require start (top/left) bound
                                SingleLetterTests::Bound);  // Require end (bottom/right) bound
                        if (success && (bottom.maxDepth > combinedRect.size.height * 0.10)) {
                            replaceTwoWithRect(r, 'W', combinedRect, "rule 0505");
                            makeAnotherPass = true;
                        }
                    }
                    delete st;
                } // st != NULL
            } // "V/" instead of 'W'

            // "21" instead o '8'
            if ((r->ch == '2') && (results->imageTests) && !(r->flags3 & FLAGS3_TESTED_AS_8) && (r->next != NULL) && (r->next->ch == '1') && (statsWithoutCurrentAndNext->averageWidthDigits.count >= 3) && (r->rect.size.width < statsWithoutCurrentAndNext->averageWidthDigits.average * 0.75)
            // Overlapping
            && (rectSpaceBetweenRects(r->rect, r->next->rect) <= 0)
            // Combination in line with av. digit width
            && (rectRight(r->next->rect) - rectLeft(r->rect) + 1 < statsWithoutCurrentAndNext->averageWidthDigits.average * 1.15)) {
                r->flags3 |= FLAGS3_TESTED_AS_8;
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
                if (st != NULL) {
                    ConnectedComponentList cpl = st->getConnectedComponents();
                    if (cpl.size() == 2) {
                        char newCh = SingleLetterTestSAsDigit(r, combinedRect, 1, results);
                        if (newCh != '\0') {
                            ReplacingLog("Validate: rule 0502 replacing [%c%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)r->next->ch, (unsigned short)newCh, toUTF8(r->word->text()).c_str());
                            replaceTwoWithRect(r, newCh, combinedRect, "rule 0502");
                            makeAnotherPass = true;
                        }
                    } // single comp
                } // st != NULL
            }
            
            // "4-" instead of '4'
            if ((r->ch == '4') && (r->next != NULL) && (r->next->ch == '-')
                // '-' included in '4': start after start of r and ends before end of r
                && (rectSpaceBetweenRects(r->rect, r->next->rect) < 0)) {
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
                if (st != NULL) {
                    ConnectedComponentList cpl = st->getConnectedComponents();
                    if (cpl.size() == 2) {
                        // Just remove the '-' or make it a '+'?
                        // If there is a digit before, unlikely to be a plus (in the middle of phone?)
                        SmartPtr<OCRRect> p = r->previous;
                        bool foundDigit = false;
                        while (p != NULL) {
                            if (isDigit(p->ch)) {
                                foundDigit = true;
                                break;
                            }
                            p = p->previous;
                        }
                        bool isPlus = false;
                        if (!foundDigit) {
                            // One more test: look for cross pattern through segments
                            SegmentList slTop = st->getHorizontalSegments(0.075, 0.15);
                            if (slTop.size() == 1) {
                                // Now check vertical segment on left side
                                float leftDepth = slTop[0].startPos / combinedRect.size.width;
                                SegmentList slLeft = st->getVerticalSegments(leftDepth / 2, leftDepth);
                                if (slLeft.size() == 1) {
                                    if ((abs(slTop[0].startPos - (combinedRect.size.width - slTop[0].endPos)) < combinedRect.size.width * 0.15)
                                            && (abs(slLeft[0].startPos - (combinedRect.size.height - slLeft[0].endPos)) < combinedRect.size.height * 0.15)) {
                                        isPlus = true;
                                    }
                                } // single left side segment
                            } // single segment on top
                        } // !foundDigit
                        char newCh = (isPlus? '+':'4');
                        if (isPlus) {
                            ReplacingLog("Validate: rule 0501 replacing [%c%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)r->next->ch, (unsigned short)newCh, toUTF8(r->word->text()).c_str());
                            r->word->updateLetterWithNewCharAndNewRect(r, newCh, combinedRect);
                            r->word->removeLetter(r->next); // Remove the '-'
                            makeAnotherPass = true;
                        } else {
                            replaceTwoWithRect(r, newCh, combinedRect, "rule 0501");
                            makeAnotherPass = true;
                        }
                    } // single connect comp
                    delete st;
                } // st != NULL
            }

            // Replace "- with 7
			if (isQuote(r->ch)
                && (r->next != NULL) && (r->next->ch == '-')
                // Overlapping
                && (rectSpaceBetweenRects(r->rect, r->next->rect) < 0)
                 )
            {
                bool doit = false;
                char newCh = '7';
                if (results->imageTests && !(r->flags3 & FLAGS3_TESTED_AS_7)) {
                    float minX = MIN(rectLeft(r->rect), rectLeft(r->next->rect));
                    float maxX = MAX(rectRight(r->rect), rectRight(r->next->rect));
                    float minY = MIN(rectBottom(r->rect), rectBottom(r->next->rect));
                    float maxY = MAX(rectTop(r->rect), rectTop(r->next->rect));
                    CGRect combinedRect (minX, minY, maxX - minX + 1, maxY - minY + 1);
                    if (tallHeightTest(statsWithoutCurrentAndNext.getPtr(), combinedRect.size.height, '7', false, 2, false) == 1) {
                        doit = true;
                        SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
                        if (st != NULL) {
                            doit = true;
                            // Rest of line not glued
                            if ((r->next->next != NULL) && (r->next->next->ch != ' ') && (rectSpaceBetweenRects(r->next->rect, r->next->next->rect) <= 0)) {
                                // Might be glued, check if next char really touches us (as opposed to just overlapping rects)
                                float minMinX = MIN(minX, rectLeft(r->next->next->rect));
                                float maxMaxX = MAX(maxX, rectRight(r->next->next->rect));
                                float minMinY = MIN(minY, rectBottom(r->next->next->rect));
                                float maxMaxY = MAX(maxY, rectTop(r->next->next->rect));
                                CGRect combinedCombinedRect (minMinX, minMinY, maxMaxX - minMinX + 1, maxMaxY - minMinY + 1);
                                SingleLetterTests *stSt = CreateSingleLetterTests(combinedCombinedRect, results);
                                if (stSt != NULL) {
                                    ConnectedComponentList cplCombined = st->getConnectedComponents();
                                    ConnectedComponentList cplCombinedCombined = stSt->getConnectedComponents();
                                    if ((cplCombined.size() < 2) || (cplCombinedCombined.size() < 2)
                                        || (cplCombinedCombined.size() != cplCombined.size() + 1)) {
                                            doit = false;
                                        }
                                    delete stSt;
                                }
                            }
                            if (doit) {
                                // Has a top like 7?
                                bool hasTop = st->getSide(SingleLetterTests::Top, 0.90, false);
                                if (hasTop) {
                                    // One more test: check that the bottom of the next letter is not touching the right side (i.e. that it is sloping right like a /)
                                    SegmentList sl = st->getHorizontalSegments(0.95, 0.05);
                                    if (sl.size() >= 1) {
                                        Segment lastSegment = sl[sl.size() - 1];
                                        if (lastSegment.endPos > combinedRect.size.width * 0.80) {
                                            doit = false;
                                        }
                                    }
                                } // hasTop
                            }
                            delete st;
                        }
                    } // tall
                }
                if (doit) {
                    replaceTwo(r, newCh, "rule 0297");
                    makeAnotherPass = true;
                }
			}
            
            // '.' glued to next letter
            if ((r->ch == '.')
                && !(r->flags5 & FLAGS5_TESTED_AS_SUBSUMED)
                // Glued to next letter
                && (r->next != NULL) && ((spaceBetween = rectSpaceBetweenRects(r->rect, r->next->rect)) <= 0)
                // Not glued to previous
                && ((r->previous == NULL) || (r->previous->ch == ' ') || (rectSpaceBetweenRects(r->previous->rect, r->rect) > 0)))
            {
                // Verify the dot is actually glued to next letter
                r->flags5 |= FLAGS5_TESTED_AS_SUBSUMED;
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                SingleLetterTests *st1 = CreateSingleLetterTests(r->rect, results);
                SingleLetterTests *st2 = CreateSingleLetterTests(r->next->rect, results);
                SingleLetterTests *stCombined = CreateSingleLetterTests(combinedRect, results);
                if ((st1 != NULL) && (st2 != NULL) && (stCombined != NULL)) {
                    ConnectedComponentList cpl1 = st1->getConnectedComponents();
                    ConnectedComponentList cpl2 = st2->getConnectedComponents();
                    ConnectedComponentList cplCombined = stCombined->getConnectedComponents();
#if DEBUG
                    SingleLetterPrint(cpl1, r->rect);
                    SingleLetterPrint(cpl2, r->rect);
                    SingleLetterPrint(cplCombined, r->rect);
#endif
                    if ((cpl1.size() >= 2) && (cpl2.size() >= 2) && (cplCombined.size() >= 2)
                        // +2 because connected components lists include one summary entry in addition to actual list
                        && (cpl1.size() + cpl2.size() == cplCombined.size() + 2)) {
                        // One more check: if '.' coordinates are included in the next rect, check if it is even glued to any other connected component or else still alive and well in the combined rect.
                        bool doit = true;
                        if (rectLeft(r->rect) >= rectLeft(r->next->rect)) {
                            for (int cc=1; cc<cplCombined.size(); cc++) {
                                if ((cplCombined[cc].xmin + rectLeft(combinedRect) == cpl1[1].xmin + rectLeft(r->rect))
                                    && (cplCombined[cc].ymin + rectBottom(combinedRect) == cpl1[1].ymin + rectBottom(r->rect))
                                    && (cplCombined[cc].area == cpl1[1].area)) {
                                    doit = false;
                                    ReplacingLog("Validate: rule 0286 NOT replacing [%c%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)r->next->ch, (unsigned short)r->next->ch, toUTF8(r->word->text()).c_str());
                                }
                            }
                            if (doit) {
                                wchar_t newCh = r->next->ch;
                                if ((newCh == '.') && (combinedRect.size.width >= combinedRect.size.height *OCR_RATIO_DASH_MIN_WIDTH_TO_HEIGHT))
                                    newCh = '-';
                                replaceTwoWithRect(r, newCh, combinedRect, "rule 0286");
                                makeAnotherPass = true;
                            }
                        }
                    }
                    delete st1; delete st2; delete stCombined;
                }
            }

            // ".." instead of '.' when one of the dots touches previous/next - eliminate the glued dot
            if ((r->ch == '.') && (r->next != NULL) && (r->next->ch == '.')) {
                float spaceBetweenTwo = rectSpaceBetweenRects(r->rect, r->next->rect);
                bool gluedTogether = (spaceBetweenTwo <= 0);
                
                bool gluedToPrevious = false;
                float spaceWithPrevious;
                if ((r->previous != NULL) && (r->previous->ch != ' ')) {
                    spaceWithPrevious = rectSpaceBetweenRects(r->previous->rect, r->rect);
                }
                
                bool gluedToNext = false;
                float spaceWithNext;
                if ((r->next->next != NULL) && (r->next->next->ch != ' ')) {
                    spaceWithNext = rectSpaceBetweenRects(r->next->rect, r->next->next->rect);
                }
                
                if (!gluedToNext && !gluedToPrevious && gluedTogether) {
                    // Replace two dots with one
                    // Not testing that we have a single components because it's difficult for dots to touch without being one
                    char newCh = '.';
                    CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                    if (combinedRect.size.width >= combinedRect.size.height * OCR_RATIO_DASH_MIN_WIDTH_TO_HEIGHT)
                        newCh = '-';
                    replaceTwoWithRect(r, newCh, combinedRect, "rule 0285");
                    makeAnotherPass = true;
                } else if (gluedToNext && !gluedToPrevious && !gluedTogether) {
                    // Verify the dot is actually glued to next letter
                    CGRect combinedRect = CreateCombinedRect(r->next->rect, r->next->next->rect);
                    SingleLetterTests *st1 = CreateSingleLetterTests(r->next->rect, results);
                    SingleLetterTests *st2 = CreateSingleLetterTests(r->next->next->rect, results);
                    SingleLetterTests *stCombined = CreateSingleLetterTests(combinedRect, results);
                    if ((st1 != NULL) && (st2 != NULL) && (stCombined != NULL)) {
                        ConnectedComponentList cpl1 = st1->getConnectedComponents();
                        ConnectedComponentList cpl2 = st2->getConnectedComponents();
                        ConnectedComponentList cplCombined = stCombined->getConnectedComponents();
                        if ((cpl1.size() >= 2) && (cpl2.size() >= 2) && (cplCombined.size() >= 2)
                            // +2 because connected components lists include one summary entry in addition to actual list
                            && (cpl1.size() + cpl2.size() == cplCombined.size() + 2)) {
                            replaceTwoWithRect(r->next, r->next->next->ch, combinedRect, "rule 0285");
                            makeAnotherPass = true;
                        }
                        delete st1; delete st2; delete stCombined;
                    }
                } else if (!gluedToNext && gluedToPrevious && !gluedTogether) {
                    // Verify the dot is actually glued to previous letter
                    CGRect combinedRect = CreateCombinedRect(r->previous->rect, r->rect);
                    SingleLetterTests *st1 = CreateSingleLetterTests(r->previous->rect, results);
                    SingleLetterTests *st2 = CreateSingleLetterTests(r->rect, results);
                    SingleLetterTests *stCombined = CreateSingleLetterTests(combinedRect, results);
                    if ((st1 != NULL) && (st2 != NULL) && (stCombined != NULL)) {
                        ConnectedComponentList cpl1 = st1->getConnectedComponents();
                        ConnectedComponentList cpl2 = st2->getConnectedComponents();
                        ConnectedComponentList cplCombined = stCombined->getConnectedComponents();
                        if ((cpl1.size() >= 2) && (cpl2.size() >= 2) && (cplCombined.size() >= 2)
                            // +2 because connected components lists include one summary entry in addition to actual list
                            && (cpl1.size() + cpl2.size() == cplCombined.size() + 2)) {
                            replaceTwoWithRect(r->previous, r->previous->ch, combinedRect, "rule 0285");
                            makeAnotherPass = true;
                        }
                        delete st1; delete st2; delete stCombined;
                    }
                }
            }
            
            // False dot glued to 'a'
            if ((r->ch == '.') && (r->previous != NULL)) {
                if ((round == 1) && (r->previous != NULL) && (r->previous->ch == 'a') && (rectSpaceBetweenRects(r->previous->rect, r->rect) < 0)) {
                    if ((r->flags5 & FLAGS5_TESTED_FOUND_GLUED)
                        // Only glued dot on this line
                        && (numGluedDots == 1)
                        // Some dots not connected
                        && (numDisconnectedDots > 0)) {
                            // Just eliminate the '.'
                            // First adjust the previous rect
                            CGRect newRect = CreateCombinedRect(r->previous->rect, r->rect);
                            ReplacingLog("Validate: rule 0498 replacing, eliminating glued [%c] in word [%s]", (unsigned short)r->ch, toUTF8(r->word->text()).c_str());
                            r->word->updateLetterWithNewCharAndNewRect(r->previous, r->previous->ch, newRect);
                            SmartPtr<OCRRect> tmpR = r->next;
                            r->word->removeLetter(r);
                            r = tmpR;
                            continue;
                    }
                } else {
                    // round == 0 (first passs), test all dots
                    if ((rectSpaceBetweenRects(r->previous->rect, r->rect) > 0) && ((r->next == NULL) || (r->next->ch == ' ') || (rectSpaceBetweenRects(r->rect, r->next->rect) > 0))) {
                        // No need to single-letter stuff, not connected!
                        numDisconnectedDots++;
                    } else {
                        CGRect combinedRect = CreateCombinedRect(r->previous->rect, r->rect);
                        SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
                        if (st != NULL) {
                            ConnectedComponentList cpl = st->getConnectedComponents();
                            if (cpl.size() == 2) {
                                // We are just counting
                                ReplacingLog("Validate: glued dot after [%c] in word [%s]", (unsigned short)r->previous->ch, toUTF8(r->word->text()).c_str());
                                numGluedDots++;
                                r->flags5 |= FLAGS5_TESTED_FOUND_GLUED; // Set only when glued to previous letter, since that's the only case we handle for now (after 'a')
                                // We only wish to make another pass if we found just ONE glue dot, otherwise play it safe, perhaps this is a line where many letters are glued
                                makeAnotherPass = true;
                            } else {
                                // Not glued with previous, now test with next!
                                bool gluedWithNext = false;
                                if ((r->next != NULL) && (r->next->ch != ' ')) {
                                    CGRect combinedRectNext = CreateCombinedRect(r->previous->rect, r->rect);
                                    SingleLetterTests *stNext = CreateSingleLetterTests(combinedRectNext, results);
                                    if (stNext != NULL) {
                                        ConnectedComponentList cpl = st->getConnectedComponents();
                                        if (cpl.size() == 2) {
                                            gluedWithNext = true;
                                        }
                                        delete stNext;
                                    } // stNext != NULL
                                }
                                if (gluedWithNext) {
                                    ReplacingLog("Validate: glued dot before [%c] in word [%s]", (unsigned short)r->next->ch, toUTF8(r->word->text()).c_str());
                                    numGluedDots++;
                                    // makeAnotherPass = true; // no need set, for now we only handle dot glued AFTER 'a', not before a letter
                                } else {
                                    // We are just counting
                                    ReplacingLog("Validate: disconnected dot after [%c] in word [%s]", (unsigned short)r->previous->ch, toUTF8(r->word->text()).c_str());
                                    numDisconnectedDots++;
                                }
                            }
                            delete st;
                        } // st != NULL
                    }
                }
            }
            
#if DEBUG
            if ((r->ch == 'I') && (r->next != NULL) && (r->next->ch == 'E') && (r->next->next != NULL) && (r->next->next->ch == 'R')) {
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
                if (st != NULL) delete st;
                DebugLog("Found in word [%s]", toUTF8(r->word->text()).c_str());
                DebugLog("");
            }
#endif
            
            // "IE" instead of 'E'
            // "IR" instead of 'R' etc
            // "ID" instead of 'D', see https://drive.google.com/open?id=0B4jSQhcYsC9VdWtwVEtGakpwbmc (blur radius 6)
            if (isVerticalLine(r->ch) && (r->next != NULL) &&  hasVerticalLeftSide(r->next->ch) && (rectSpaceBetweenRects(r->rect, r->next->rect) <= results->globalStats.averageWidthDigits.average * 0.10)) {
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                // Make sure combined rect is not much wider than a normal uppercase
                if ((combinedRect.size.width > results->globalStats.averageWidthDigits.average * 0.85) && (combinedRect.size.width < results->globalStats.averageWidthDigits.average * 1.17)) {
                    char newCh = r->next->ch;
                    replaceTwoWithRect(r, newCh, combinedRect, "rule 0125");
                    makeAnotherPass = true;
                }
            }
            
            if (hasVerticalRightSide(r->ch) && (r->next != NULL) &&  isVerticalLine(r->next->ch) && (rectSpaceBetweenRects(r->rect, r->next->rect) <= 0)) {
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                // Make sure combined rect is not much wider than a normal uppercase
                if ((combinedRect.size.width > results->globalStats.averageWidthDigits.average * 0.85) && (combinedRect.size.width < results->globalStats.averageWidthDigits.average * 1.17)) {
                    char newCh = r->ch;
                    replaceTwoWithRect(r, newCh, combinedRect, "rule 0679");
                    makeAnotherPass = true;
                }
            }
            
#if DEBUG
                if ((r->ch == '.') && (r->next != NULL) && (r->next->ch == '3')) {
                    CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                    SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
                    if (st != NULL) delete st;
                    DebugLog("Found in word [%s]", toUTF8(r->word->text()).c_str());
                    DebugLog("");
                }
#endif
            
            // "yf" or 'y' + 0xfb01 instead of "if" in italic line (bottom left of 'f' gets included under the 'i' to appear like 'y')
            if ((r->ch == 'y') && (r->next != NULL) && ((r->next->ch == 'f') || (r->next->ch == 0xfb01))
                && (rectSpaceBetweenRects(r->rect, r->next->rect) <= 0) && (results->imageTests) && !(r->flags6 & FLAGS6_TESTED_AS_i)) {
                r->flags6 |= FLAGS6_TESTED_AS_i;
                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                if (st != NULL) {
                    ConnectedComponentList cpl = st->getConnectedComponents();
                    if (cpl.size() == 4) {
                        // Dummy first comp + body of the 'i' + leg of the 'f' + dot of the 'i'
                        ConnectedComponent iDotComp, iBodyComp, fLegComp;
                        
                        // Determine 'i' dot comp
                        if (cpl[1].ymin < cpl[2].ymin) {
                            if (cpl[1].ymin < cpl[3].ymin)
                                iDotComp = cpl[1];
                            else
                                iDotComp = cpl[3];
                        } else {
                            // cpl[2].ymin < cpl[1].ymin
                            if (cpl[2].ymin < cpl[3].ymin)
                                iDotComp = cpl[2];
                            else
                                iDotComp = cpl[3];
                        }
                        
                        // Determine leg of 'f' comp
                        if (cpl[1].ymax > cpl[2].ymax) {
                            if (cpl[1].ymax > cpl[3].ymax)
                                fLegComp = cpl[1];
                            else
                                fLegComp = cpl[3];
                        } else {
                            // cpl[2].ymax > cpl[1].ymax
                            if (cpl[2].ymax > cpl[3].ymax)
                                fLegComp = cpl[2];
                            else
                                fLegComp = cpl[3];
                        }
                        
                        // Last remaining comp is the body of the 'i'
                        if ((cpl[1].ymin != iDotComp.ymin) && (cpl[1].ymax != fLegComp.ymax)) {
                            iBodyComp = cpl[1];
                        } else if ((cpl[2].ymin != iDotComp.ymin) && (cpl[2].ymax != fLegComp.ymax)) {
                            iBodyComp = cpl[2];
                        } else {
                            iBodyComp = cpl[3];
                        }
                        
                        if ((iDotComp.ymin != iBodyComp.ymin) && (iBodyComp.ymax != fLegComp.ymax)) {
                            // 3 different comps
                            if (iDotComp.getHeight() < iBodyComp.getHeight()) {
                                // Not much of a check but I guess it's good enough?
                                char newCh = 'i';
                                float xMin = MIN(iBodyComp.xmin, iDotComp.xmin);
                                float xMax = MAX(iBodyComp.xmax, iDotComp.xmax);
                                CGRect newRect (rectLeft(r->rect) + xMin, rectBottom(r->rect) + iDotComp.ymin, xMax - xMin + 1, iBodyComp.ymax + 1);
                                ReplacingLog("Validate: rule 0497 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)newCh, toUTF8(r->word->text()).c_str());
                                r->word->updateLetterWithNewCharAndNewRect(r, newCh, newRect);
                                makeAnotherPass = true;
                            }
                        }
                    }
                    delete st;
                } // st != NULL
            }
            
            // "ld" instead of "kf"
            // Our strategy here will be to recognize that the 'l' and 'd' are glued yet the 'd' is made up of two large components => split the 'd' and let our other rules catch that (e.g. "lc" -> 'k')
            if (isVerticalLine(r->ch) && (r->next != NULL) && !(r->next->flags4 & FLAGS4_TESTED_AS_c) && (r->next->ch == 'd') && (spaceBetween = rectSpaceBetweenRects(r->rect, r->next->rect) < 0)) {
                r->next->flags4 |= FLAGS4_TESTED_AS_c;
                bool doit = false;
                CGRect rect1, rect2;
                SingleLetterTests *stNext = CreateSingleLetterTests(r->next->rect, results);
                if (stNext != NULL) {
                    doit = true;
                    ConnectedComponentList cplNext = stNext->getConnectedComponents();
                    // Expect 2 connected comps (c and l/f/t)
                    // Special case where all letters are close to each other and "cl" ARE glued - accept if we find a notch above & below
                    if ((statsWithoutCurrentAndNext->averageSpacing.average < 0)
                        && ((cplNext.size() == 2) || ((cplNext.size() > 2) && (cplNext[2].area < cplNext[1].area * 0.10)))) {
                        doit = false;
                        // Need to slice off right side to avoid finding the notch created by glued 'l' on the left
                        CGRect rightSide (rectLeft(r->next->rect) + r->next->rect.size.width * 0.20, rectBottom(r->next->rect), r->next->rect.size.width * 0.80, r->next->rect.size.height);
                        SingleLetterTests *stRight = CreateSingleLetterTests(rightSide, results);
                        if (stRight != NULL) {
                            OpeningsTestResults top;
                            bool success = stRight->getOpenings(top,
                                                           SingleLetterTests::Top,
                                                           0.00,      // Start of range to search (top/left)
                                                           0.80,      // End of range to search (bottom/right)
                                                           SingleLetterTests::Bound,   // Require start (top/left) bound
                                                           SingleLetterTests::Bound);  // Require end (bottom/right) bound
                            if (success) {
                                OpeningsTestResults bottom;
                                bool success = stRight->getOpenings(bottom,
                                                                   SingleLetterTests::Bottom,
                                                                   0.00,      // Start of range to search (top/left)
                                                                   0.80,      // End of range to search (bottom/right)
                                                                   SingleLetterTests::Bound,   // Require start (top/left) bound
                                                                   SingleLetterTests::Bound);  // Require end (bottom/right) bound
                                if (success) {
                                    // We are not done: because this is delicate, also test that previous letter is glued, otherwise no point disconnecting next letter in two
                                    CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                                    SingleLetterTests *stCombined = CreateSingleLetterTests(combinedRect, results);
                                    if (stCombined != NULL) {
                                        ConnectedComponentList cplCombined = stCombined->getConnectedComponents();
    #if DEBUG
                                        SingleLetterPrint(cplCombined, combinedRect);
    #endif
                                        if (cplCombined.size() >= 2) {
                                            if (rectLeft(combinedRect) + cplCombined[1].xmax == rectLeft(r->next->rect) + cplNext[1].xmax)
                                                doit = true;
                                        }
                                        delete stCombined;
                                    }
                                    if (doit) {
                                                        // Adjust for the fact we used a sliced right side
                                        float xSplit = (rectLeft(rightSide) - rectLeft(r->next->rect))
                                                + MAX(top.maxDepthCoord, bottom.maxDepthCoord);
                                        if ((xSplit < 3) || (r->next->rect.size.width - xSplit < 3)) {
                                            doit = false;
                                        } else {
                                            rect1.origin.x = rectLeft(r->next->rect);
                                            // Just guessing height
                                            rect1.origin.y = rectBottom(r->next->rect) + r->rect.size.height * 0.25;
                                            rect1.size.width = xSplit;
                                            // Just guessing height
                                            rect1.size.height = r->next->rect.size.height * 0.75;
                                            rect2.origin.x = ((xSplit < r->next->rect.size.width - 2)? rectRight(rect1) + 2:rectRight(rect1) + 1);
                                            rect2.origin.y = rectBottom(r->next->rect) + cplNext[1].ymin;
                                            rect2.size.width = rectRight(r->next->rect) - rectLeft(rect2) + 1;
                                            rect2.size.height = cplNext[1].getHeight();
                                        }
                                    }
                                } // found openings top & bottom
                            } // found opening top
                            delete stRight;
                        } // stRight != NULL
                    }
                    else if ((cplNext.size() < 3)
                        // 2nd comp too small ('c' and 'l' should be of similar sizes)
                        || (cplNext[2].area < cplNext[1].area * 0.50)
                        // 3rd comp too large
                        || ((cplNext.size() >= 4) && (cplNext[3].area > cplNext[2].area * 0.10)))
                        doit = false;
                    else {
                        ConnectedComponent first = ((cplNext[1].xmin < cplNext[2].xmin)? cplNext[1]:cplNext[2]);
                        ConnectedComponent second = ((cplNext[1].xmin < cplNext[2].xmin)? cplNext[2]:cplNext[1]);
                        rect1.origin.x = rectLeft(r->next->rect); // Don't add first.xmin intentionally such that the 'c' stays glued to the preceding 'l' and our "lc" -> 'k' rule fires
                        rect1.origin.y = rectBottom(r->next->rect) + first.ymin;
                        rect1.size.width = first.getWidth() + first.xmin;
                        rect1.size.height = first.getHeight();
                        rect2.origin.x = rectLeft(r->next->rect) + second.xmin;
                        rect2.origin.y = rectBottom(r->next->rect) + second.ymin;
                        rect2.size.width = second.getWidth();
                        rect2.size.height = second.getHeight();
                    }
                    delete stNext;
                }
                if (doit) {
                    // Replace next letter with 2 new letters
                    char newCh1 = 'c';
                    char newCh2 = 'l';
                    r->word->updateLetterWithNewCharAndNewRect(r->next, newCh1, rect1);
                    // Tag new letter as requiring single letter inspection (could be 't' or 'f')
                    r->word->addLetterWithRectConfidenceAfterRect(newCh2, rect2, r->next->confidence + 500, r->next);
                    ReplacingLog("Validate: rule 0098 replacing [%c] with [%c%c] in word [%s]", (unsigned short)r->next->ch, (unsigned short)newCh1, (unsigned short)newCh2, toUTF8(r->word->text()).c_str());
                    makeAnotherPass = true;
                }
            }
            
            // "33" instead of '8'
            if ((r->ch == '3') && (r->next != NULL) && (r->next->ch == '3') && (rectSpaceBetweenRects(r->rect, r->next->rect) <= 0) && (results->imageTests) && !(r->flags4 & FLAGS4_TESTED_AS_8)) {
                r->flags4 |= FLAGS4_TESTED_AS_8;
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results, false, SINGLE_LETTER_VALIDATE_COMP_SIZE | SINGLE_LETTER_VALIDATE_SINGLE_COMP);
                if (st != NULL) {
                    // Check we have two inverted comps
                    ConnectedComponentList invertCp = st->getInverseConnectedComponents();
#if DEBUG
                    SingleLetterPrint(invertCp, combinedRect);
#endif
                    if ((invertCp.size() == 3) || ((invertCp.size() > 3) && (invertCp[3].area < invertCp[2].area * 0.075))) {
                        ConnectedComponent topHole = ((invertCp[1].ymin < invertCp[2].ymin)? invertCp[1]:invertCp[2]);
                        ConnectedComponent bottomHole = ((invertCp[1].ymin < invertCp[2].ymin)? invertCp[2]:invertCp[1]);
                            // Top hole above middle
                        if (((topHole.ymin + topHole.ymax)/2 < combinedRect.size.height * 0.50)
                            // Bottom hole below middle
                            && ((bottomHole.ymin + bottomHole.ymax)/2 > combinedRect.size.height * 0.50)) {
                            char newCh = '8';
                            replaceTwoWithRect(r, newCh, combinedRect, "rule 0047");
                            makeAnotherPass = true;
                        }
                    }
                    delete st;
                }
            }
            
            // "f5" instead of '6'
            if ((r->ch == 'f') && (results->imageTests) && !(r->flags3 & FLAGS3_TESTED_AS_6) && (r->next != NULL) && (r->next->ch == '5') && (rectSpaceBetweenRects(r->rect, r->next->rect) <= 0)) {
                r->flags3 |= FLAGS3_TESTED_AS_6;
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results, false, SINGLE_LETTER_VALIDATE_COMP_SIZE | SINGLE_LETTER_VALIDATE_SINGLE_COMP);
                if (st != NULL) {
                    // Test for bubble below
                    ConnectedComponentList inverseCpl = st->getInverseConnectedComponents();
                    if (inverseCpl.size() >= 2) {
                        ConnectedComponent hole = inverseCpl[1];
                        float holeCenter = (hole.ymin + hole.ymax) / 2;
                        if (holeCenter > combinedRect.size.height * 0.35) {
                            char newCh = '6';
                            replaceTwoWithRect(r, newCh, combinedRect, "rule 0045");
                            makeAnotherPass = true;                            
                        }
                    }
                    delete st;
                }
            }
            
            // "TK" instead of 'A'
            if ((r->ch == 'T') && (r->next != NULL) && (r->next->ch == 'K')
                && (rectSpaceBetweenRects(r->rect, r->next->rect) < 0)) {
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                CGRect newRect;
                if (SingleLetterTestAsA(r, combinedRect, &newRect, statsWithoutCurrentAndNext, results)) {
                    char newCh = 'A';
                    replaceTwoWithRect(r, newCh, newRect, "rule 0042");
                    makeAnotherPass = true;
                }
            }
            
            // "11" instead of '0'
            
            //  ----------------
            //0|                |
            //1|   11 1111  11  |
            //2|  111  111  11  |
            //3|  111           |
            //4| 111            |
            //5| 111            |
            //6| 111            |
            //7| 111            |
            //8| 111   111      |
            //9| 111  1111      |
            //a| 111  1111  1   |
            //b| 111   11   11  |
            //c| 111        11  |
            //d| 111        11  |
            //e| 111        11  |
            //f| 111        111 |
            //#| 111        111 |
            //#| 111        111 |
            //#| 111        11  |
            //#| 1111       11  |
            //#|  111       11  |
            //#|   11 1111  11  |
            //#|   1  1111      |
            //#|                |
            //  ----------------
            
            //-----------
            //           |
            //  11 1111  |
            // 111   1   |
            // 111       |
            // 111       |
            // 111       |
            // 111       |
            //  11       |
            // 111    1  |
            //  11    11 |
            //        11 |
            //       111 |
            //        11 |
            //        1  |
            //        11 |
            //  1    111 |
            //  11   111 |
            //  11   11  |
            //  11 1 11  |
            //     1     |
            //           |
            //-----------
            
            // "lI" or "11" or "II" or "IJ" instead of '6' or '5'
            // TODO plenty of "IJ" not within digits sequences which should be replaced with 'O', below code only triggers when it finds digits
            
#if DEBUG
            // 8L1.35
            if (((r->ch=='I') || (r->ch=='J')) && (r->next != NULL) && (r->next->ch =='I') && (r->next->next != NULL) && (r->next->next->ch == 'Z')) {
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
                if (st != NULL) delete st;
//                CGRect newRect = computeCapturingRectLeft(r->next, statsWithoutCurrent, results);
//                if (newRect.size.height > 0) {
//                    st = CreateSingleLetterTests(newRect, results);
//                    if (st != NULL) delete st;
//                }
                DebugLog("Found in word [%s]", toUTF8(r->word->text()).c_str());
                DebugLog("");
            }
#endif
            
            // Require 2 additional digits lookalikes in current word (besides the current two vertical lines)
            if ((r->next != NULL) && (countDigitLookAlikesInCurrentWord >= 3)
                && (((isVerticalLine(r->ch) || (r->ch == 'L')) && ((isVerticalLine(r->next->ch) || (r->next->ch == 'J'))
                                                // Allow space between them - no need to test width because testAsDisconnectedDigit does that
                                               || ((r->next->ch == ' ') && (r->next->next != NULL) && (isVerticalLine(r->next->next->ch) || (r->next->next->ch == 'J')))))
                    || ((r->ch == '.') && (((r->next->ch == '3') || (isVerticalLine(r->next->ch) || (r->next->ch == 'J')))
                                            || ((r->next->ch == ' ') && (r->next->next != NULL) && ((r->next->next->ch == '3') || (isVerticalLine(r->next->next->ch) || (r->next->ch == 'J')))))))
                && (results->imageTests)
                && !((r->flags3 & FLAGS3_TESTED_AS_TWO_RECTS) && (r->flags7 &FLAGS7_TESTED_AS_DISCONNECTED_DIGIT_ALL))) {
                bool hasSpaceBetween = (r->next->ch == ' ');
                CGRect combinedRect = (hasSpaceBetween? CreateCombinedRect(r->rect, r->next->next->rect):CreateCombinedRect(r->rect, r->next->rect));
                r->flags7 |= FLAGS7_TESTED_AS_DISCONNECTED_DIGIT_ALL;
                r->flags3 |= FLAGS3_TESTED_AS_TWO_RECTS;
                wchar_t newCh = testAsDisconnectedDigit(r, combinedRect, statsWithoutCurrent, results, '\0', '\0', true);
                if (newCh != '\0') {
                    if (hasSpaceBetween)
                        replaceThreeWithRect(r, newCh, combinedRect, "rule 0575 disconnected");
                    else
                        replaceTwoWithRect(r, newCh, combinedRect, "rule 0575 disconnected");
                    makeAnotherPass = true;
                }
            }            
            
//#if DEBUG
//            if (((r->ch=='c') || (r->ch == 'C')) && (r->next != NULL) && (r->next->ch =='J') && (r->previous != NULL) && (r->previous->ch=='9')) {
//                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
//                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
//                if (st != NULL) delete st;
//                DebugLog("Found in word [%s]", toUTF8(r->word->text()).c_str());
//                DebugLog("");
//            }
//#endif
            
            if (((r->ch == '2') || (r->ch == 'c') || (r->ch == 'C')) && (r->next != NULL) && (r->next->ch == 'J') && results->imageTests) {
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                if (combinedRect.size.width < results->globalStats.averageWidthDigits.average * 1.15) {
                    if (combinedRect.size.height < results->globalStats.averageHeightDigits.average * 0.85) {
                        wchar_t newCh = '\0';
                        CGRect newRect = computeTallerRect(r, combinedRect, statsWithoutCurrentAndNext, results);
                        if ((newRect.size.height > 0) && !compareRects(combinedRect, newRect)) {
                            if (!((r->flags3 & FLAGS3_TESTED_AS_DISCONNECTED_DIGIT9) && (r->flags3 & FLAGS3_TESTED_AS_TWO_RECTS))) {
                                r->flags3 |= FLAGS3_TESTED_AS_DISCONNECTED_DIGIT9;
                                newCh = testAsDisconnectedDigit(r, newRect, statsWithoutCurrent, results, '9', '\0', true);
                            }

                            if (newCh != '\0') {
                                replaceTwoWithRect(r, newCh, newRect, "rule 0623 disconnected");
                                makeAnotherPass = true;
                            }
                        }
                    }
                }
            }
            
//#if DEBUG
//            if (((r->ch=='c') || (r->ch == 'C')) && (r->next != NULL) && ((r->next->ch =='J') || (r->next->ch =='I')) && (r->previous != NULL) && isVerticalLine(r->previous->ch)) {
//                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
//                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
//                if (st != NULL) delete st;
//                DebugLog("Found in word [%s]", toUTF8(r->word->text()).c_str());
//                DebugLog("");
//            }
//#endif
            
            // "CJ" instead of '9'
            // "CJ" instead of '0'
            // "CJ" instead of '4' - see https://drive.google.com/open?id=0B4jSQhcYsC9VLVhKV2ZPNTlLRDg
            if (((r->ch == 'c') || (r->ch == 'C')) && (r->next != NULL) && ((r->next->ch == 'J') || (isVerticalLine(r->next->ch) && (r->ch != '/'))) && results->imageTests) {
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                if (combinedRect.size.width < results->globalStats.averageWidthDigits.average * 1.20) {
                    wchar_t newCh = '\0';
                    CGRect newRect = computeTallerRect(r, combinedRect, statsWithoutCurrentAndNext, results);
                    if (!((r->flags3 & FLAGS3_TESTED_AS_DISCONNECTED_DIGIT9) && (r->flags3 & FLAGS3_TESTED_AS_TWO_RECTS))) {
                        r->flags3 |= FLAGS3_TESTED_AS_DISCONNECTED_DIGIT9;
                        r->flags3 |= FLAGS3_TESTED_AS_TWO_RECTS;
                        newCh = testAsDisconnectedDigit(r, newRect, statsWithoutCurrent, results, '9', '\0', true);
                    }
                    if ((newCh == '\0') && !((r->flags4 & FLAGS4_TESTED_AS_DISCONNECTED_DIGIT0) && (r->flags3 & FLAGS3_TESTED_AS_TWO_RECTS))) {
                        r->flags4 |= FLAGS4_TESTED_AS_DISCONNECTED_DIGIT0;
                        r->flags3 |= FLAGS3_TESTED_AS_TWO_RECTS;
                        newCh = testAsDisconnectedDigit(r, newRect, statsWithoutCurrent, results, '0', '\0', true);
                    }
                    if ((newCh == '\0') && !((r->flags3 & FLAGS3_TESTED_AS_DISCONNECTED_DIGIT4) && (r->flags3 & FLAGS3_TESTED_AS_TWO_RECTS))) {
                        r->flags3 |= FLAGS3_TESTED_AS_DISCONNECTED_DIGIT4;
                        r->flags3 |= FLAGS3_TESTED_AS_TWO_RECTS;
                        newCh = testAsDisconnectedDigit(r, newRect, statsWithoutCurrent, results, '4', '\0', true);
                    }

                    if (newCh != '\0') {
                        replaceTwoWithRect(r, newCh, newRect, "rule 0625 disconnected");
                        makeAnotherPass = true;
                    }
                }
            }
            
            
//#if DEBUG
//            if ((r->previous != NULL) && (r->previous->ch=='3') && (r->ch=='I') && (r->next != NULL) && (r->next->ch =='I') && (r->next->next != NULL) && (r->next->next->ch =='1')) {
//                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect, r->next->next->rect);
//                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
//                if (st != NULL) delete st;
//                DebugLog("Found in word [%s]", toUTF8(r->word->text()).c_str());
//                DebugLog("");
//            }
//#endif
            //  0123456789abcdef##
            //  ------------------
            //0|                  |
            //1|       1          |
            //2|     1111    1    |
            //3|    1111    111   |
            //4|   1111     111   |
            //5|  1111      111   |
            //6|  111        11   |
            //7|  11         111  |
            //8|  11          11  |
            //9| 111          111 |
            //a| 111          111 |
            //b|  11          111 |
            //c|  111         111 |
            //d|  111        1111 |
            //e|  11111      1111 |
            //f|   111111    111  |
            //#|   111111    111  |
            //#|       11     11  |
            //#|              11  |
            //#|              11  |
            //#|             111  |
            //#|             111  |
            //#|            1111  |
            //#|  11       1111   |
            //#|  1111     111    |
            //#|  111111   111    |
            //#|   111111   1     |
            //#|                  |
            //  ------------------
            //  0123456789abcdef##

// 2016-03-02 Retiring this rule - seems to misfires often + we should be testing patterns like that using testAsDisconnectedDigits
#if 0
            // "CJ" ot "IJ" instead of '0' or '9'. See Home Depot receipt submitted by Darren 09-09-2015:
            // C quality: 88 [534,1 w=8,h=22]
            // J quality: 85 [543,3 w=5,h=19] (combined width = 14 versus normal digit width 13)
            // 7 quality: 90 [550,1 w=13,h=22]
            if (((r->ch == 'C') || (r->ch == 'c') || (r->ch == 'I')) && (r->next != NULL) && ((r->next->ch == 'J') || (r->next->ch == 'I'))) {
                float referenceWidth = 0;
                if (statsWithoutCurrentAndNext->averageWidthDigits.count >= 3) {
                    referenceWidth = statsWithoutCurrentAndNext->averageWidthDigits.average;
                } else if (statsWithoutCurrentAndNext->averageWidthUppercase.count >= 3) {
                    referenceWidth = statsWithoutCurrentAndNext->averageWidthUppercase.average;
                } else if (results->globalStats.averageWidthDigits.count >= 3) {
                    referenceWidth = results->globalStats.averageWidthDigits.average;
                }
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                // Both combined not much wider than a normal letter?
                if ((combinedRect.size.width < referenceWidth * 1.20)
                    || ((combinedRect.size.width < referenceWidth * 1.40) && (combinedRect.size.width < results->globalStats.averageWidthDigits.average * 1.20))) {
                    // Require digits nearby
                    bool doit = false;
                    if (r->previous != NULL) {
                        if (isDigitLookalikeExtended(r->previous->ch))
                            doit = true;
                        else if (((r->previous->ch == ' ') || (r->previous->ch == '.')) && (r->previous->previous != NULL) && isDigitLookalikeExtended(r->previous->previous->ch))
                            doit = true;
                    } else if (r->next->next != NULL) {
                        if (isDigitLookalikeExtended(r->next->next->ch))
                            doit = true;
                        else if (((r->next->next->ch == ' ') || (r->next->next->ch == '.')) && (r->next->next->next != NULL) && isDigitLookalikeExtended(r->next->next->next->ch))
                            doit = true;
                    }
                    if (doit) {
                        // Could be a '9'!
                        char newCh = '0';
                        SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                        if (st != NULL) {
                            ConnectedComponentList cpl = st->getConnectedComponents();
                            if (cpl.size() >= 2) {
                                ConnectedComponent letterCCC = cpl[1]; // Assume 'C' is the main component
                                CGRect adjustedRect(rectLeft(r->rect) + letterCCC.xmin, rectBottom(r->rect) + letterCCC.ymin, letterCCC.getWidth(), letterCCC.getHeight());
                                if ((adjustedRect.size.height < r->next->rect.size.height * 0.75)
                                    && (rectTop(adjustedRect) < rectBottom(r->next->rect) + r->next->rect.size.height * 0.75))
                                    newCh = '9';
                            }
                            delete st;
                        }
                        
                        // Last check: if we determined it's a '0', check if it's not a 'U' instead, as in:
                        //  --------------
                        //0|              |
                        //1| 111      111 |
                        //2| 111      111 |
                        //3| 111      111 |
                        //4| 111      111 |
                        //5| 111      111 |
                        //6| 111      111 |
                        //7| 111      111 |
                        //8| 111      111 |
                        //9| 111      111 |
                        //a| 111      11  |
                        //b| 111      11  |
                        //c| 11       11  |
                        //d| 11       11  |
                        //e| 11       11  |
                        //f| 11       11  |
                        //#| 11       11  |
                        //#| 11      111  |
                        //#| 111     111  |
                        //#| 111  11111   |
                        //#|  11 11111    |
                        //#|      1111    |
                        //#|              |
                        //  --------------
                        // Opening 7 pixels out of width=12
                        // Test if we have a wide open top, if so make it a 'U'. Note: we accept 'U' as a substitute for '0' anyhow in product numbers and prices so we should be liberal about it
                        SingleLetterTests *stCombined = CreateSingleLetterTests(combinedRect, results);
                        if (stCombined != NULL) {
                            SegmentList slTop = stCombined->getHorizontalSegments(0.05, 0.10);
                            if ((slTop.size() == 2) && (slTop[1].startPos - slTop[0].endPos - 1 >= combinedRect.size.width * 0.41))
                                newCh = 'U';
                            delete stCombined;
                        }
                    
                        replaceTwoWithRect(r, newCh, combinedRect, "rule 0060");
                        makeAnotherPass = true;
                        // Continue (i.e. test the newly created '0'
                    }
                }
            }
#endif // 0
            
#if DEBUG
            if ((r->ch=='C') && (r->next != NULL) && (r->next->ch =='3') && (r->next->next != NULL) && (r->next->next->ch =='2')) {
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
                if (st != NULL) delete st;
                DebugLog("Found in word [%s]", toUTF8(r->word->text()).c_str());
                DebugLog("");
            }
#endif
            
            if ((r->ch == 'C') && (r->next != NULL) && (r->next->ch == '3') && (rectRight(r->next->rect) - rectLeft(r->rect) + 1 < results->globalStats.averageWidthDigits.average * 1.15) && results->imageTests) {
                char newCh = '\0';
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                if (!(r->flags4 & FLAGS4_TESTED_AS_DISCONNECTED_DIGIT0)) {
                    r->flags4 |= FLAGS4_TESTED_AS_DISCONNECTED_DIGIT0;
                    newCh = testAsDisconnectedDigit(r, combinedRect, statsWithoutCurrent, results, '0', '\0', true);
                }
                if ((newCh == '\0') && !(r->flags4 & FLAGS4_TESTED_AS_DISCONNECTED_DIGIT8)) {
                    r->flags4 |= FLAGS4_TESTED_AS_DISCONNECTED_DIGIT8;
                    newCh = testAsDisconnectedDigit(r, combinedRect, statsWithoutCurrent, results, '8', '\0', true);
                }
                if ((newCh == '\0') && (r->rect.size.height < results->globalStats.averageHeightDigits.average * 0.70) && !(r->flags3 & FLAGS3_TESTED_AS_DISCONNECTED_DIGIT9)) {
                    r->flags3 |= FLAGS3_TESTED_AS_DISCONNECTED_DIGIT9;
                    newCh = testAsDisconnectedDigit(r, combinedRect, statsWithoutCurrent, results, '9', '\0', true);
                }
                if (newCh != '\0') {
                    replaceTwoWithRect(r, newCh, combinedRect, "rule 0623");
                    makeAnotherPass = true;
                }
            }
            
            // "CJ" or "CD" instead of 'C'
            if ((r->ch == '(')
                && (r->next != NULL) && ((r->next->ch == 'J') || (r->next->ch == 'D'))
                && !(r->flags4 & FLAGS4_TESTED_AS_c)
                && (results->imageTests)
                // Well spaced
                && (line->averageSpacing.average > 0)
                // Glued
                && (rectSpaceBetweenRects(r->rect, r->next->rect) <=0)
                && (tallHeightTest(statsWithoutCurrentAndNext.getPtr(), r->rect.size.height, 0, false, 0, true) == 1))
            {
                r->flags4 |= FLAGS4_TESTED_AS_c;
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                // Require single component
                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results, SINGLE_LETTER_VALIDATE_SINGLE_COMP);
                if (st != NULL) {
                    // Now test 2nd letter and expect one component bottom right or else two components (one of them below right)
                    SingleLetterTests *stRight = CreateSingleLetterTests(r->next->rect, results);
                    if (stRight != NULL) {
                        ConnectedComponentList cpl = stRight->getConnectedComponents();
                        bool doit = false;
                        if (cpl.size() == 3) {
#if DEBUG
                            SingleLetterPrint(cpl, combinedRect);
#endif
                            ConnectedComponent bottomRight = ((cpl[1].ymin > cpl[2].ymin)? cpl[1]:cpl[2]);
                            ConnectedComponent topRight = ((cpl[1].ymin > cpl[2].ymin)? cpl[2]:cpl[1]);
    
                            // Right part of the 'C' clearly should be below the center
                            if ((bottomRight.ymin > combinedRect.size.height * 0.50) && (r->next->ch != 'D')) {
                                doit = true;
                            } else {
                                // If second letter is 'D', need to test more
                                // Expect both components to have roughly the same height
                                if ((cpl[1].getHeight() <= cpl[2].getHeight() * 1.35)
                                    && (cpl[1].getHeight() >= cpl[2].getHeight() * 0.65)
                                    // One entirely above the other
                                    && (topRight.ymax < bottomRight.ymin)
                                    ) {
                                    // Also test that we have a deep opening from right side
                                    OpeningsTestResults right;
                                    bool success = st->getOpenings(right,
                                            SingleLetterTests::Right,
                                            0.15,      // Start of range to search (top/left)
                                            0.85,      // End of range to search (bottom/right)
                                            SingleLetterTests::Bound,   // Require start (top/left) bound
                                            SingleLetterTests::Bound);  // Require end (bottom/right) bound
                                    if (success && (right.maxDepth > combinedRect.size.width * 0.60))
                                        doit = true;
                                }
                            }
                        }
                        if (doit) {
                            replaceTwoWithRect(r, 'C', combinedRect);
                            // Fall through, to allow other combinations with 'C'
                        }
                        delete stRight;
                    }
                    delete st;
                }
            }
            
            // 4+1 instead of 4
            if ((r->ch == '4') && (r->next != NULL) && (r->next->ch == '1') 
                // Well spaced
                && (line->averageSpacingDigits.average > 0)
                // Overlapping
                && (rectSpaceBetweenRects(r->rect, r->next->rect) < 0)
                // '1' taller
                && (r->rect.size.height < r->next->rect.size.height)
                )
            {
                bool doit = true;
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                // Require a single component
                if (results->imageTests) {
                    SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
                    if (st != NULL) {
                        // Special test: on the Naomi case the '4' included a dash!
                        ConnectedComponentList cpl = st->getConnectedComponents();
                        if ((cpl.size() > 2) && (cpl[2].area > cpl[1].area * 0.05)) {
                            // More than one connected comp: abort or insert a dash?
                            ConnectedComponent dash = cpl[2];
                            ConnectedComponent major = cpl[1];
                                // Dash to left of 4
                            if ((major.xmin > dash.xmax)
                                // Around cebtered in height
                                && (dash.ymin > combinedRect.size.height * 0.25)
                                && (dash.ymax < combinedRect.size.height * 0.75)
                                // Wider than tall by the right margin
                                && (dash.getWidth() > dash.getHeight() * OCR_RATIO_DASH_MIN_WIDTH_TO_HEIGHT)) {
                                // Insert dash + 4
                                wchar_t newCh1 = '-';
                                CGRect rect1 (rectLeft(combinedRect) + dash.xmin, rectBottom(combinedRect) + dash.ymin, dash.getWidth(), dash.getHeight());
                                r->word->updateLetterWithNewCharAndNewRect(r, newCh1, rect1);
                                wchar_t newCh2 = '4';
                                CGRect rect2 (rectLeft(combinedRect) + major.xmin, rectBottom(combinedRect) + major.ymin, major.getWidth(), major.getHeight());
                                r->word->updateLetterWithNewCharAndNewRect(r->next, newCh2, rect2);
                                ReplacingLog("Validate: rule 0065 replacing [41] with [-4] in word [%s]", toUTF8(r->word->text()).c_str());
                                makeAnotherPass = true;
                                doit = false; // Fall through here and continue with other rules
                            } else {
                                // Abort, significant unknown 2nd element 
                                doit = false;
                            }
                        }
                    }
                    if (st == NULL) {
                        doit = false;
                    } else {
                        delete st;
                    }
                }
                if (doit) {
                    wchar_t newCh = '4';
                    replaceTwoWithRect(r, newCh, combinedRect);
                    makeAnotherPass = true;
                }
            }

            // !| instead of 9
            if (((r->ch == '!') || (r->ch == ':')) && (r->next != NULL) && isVerticalLine(r->next->ch) && (rectSpaceBetweenRects(r->rect, r->next->rect) <= 0)) 
            {
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                wchar_t newCh = SingleLetterTestSAsDigit(r, combinedRect, 2, results);
                if (newCh != '\0') {
                    replaceTwoWithRect(r, newCh, combinedRect);
                    makeAnotherPass = true;
                }
            }
            
#if DEBUG
            if ((r->ch == '1') && (r->next != NULL) && (r->next->ch == '1') && (r->previous != NULL) && (r->previous->ch=='9')) {
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
                DebugLog("Found in word [%s]", toUTF8(r->word->text()).c_str());
                if (st != NULL) delete st;
            }
#endif

            //  --------------
            //0|              |
            //1| 11       111 |
            //2| 11       111 |
            //3| 111      111 |
            //4| 111      111 |
            //5| 1111     111 |
            //6| 1111     11  |
            //7| 1111     11  |
            //8| 11 1     11  |
            //9| 11       11  |
            //a| 11  11   111 |
            //b| 11   11  111 |
            //c| 11   11  111 |
            //d| 11    11 111 |
            //e| 11     11111 |
            //f| 11     11111 |
            //#| 11      1111 |
            //#| 11      1111 |
            //#| 11      1111 |
            //#| 111      111 |
            //#| 11        1  |
            //#|              |
            //  --------------

            // "II" instead of 'O' and '0'
            // "11" instead of 'N'
            if (isVerticalLine(r->ch) && (r->next != NULL) && isVerticalLine(r->next->ch) && (rectSpaceBetweenRects(r->rect, r->next->rect) <= 0) && results->imageTests)
            {
                wchar_t newCh = '\0';
                bool doit = false;
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                SingleLetterTests *st = NULL;
                if (!(r->flags6 & FLAGS6_TESTED_AS_O) && (SingleLetterTestAsO(r, combinedRect, statsWithoutCurrentAndNext, results, newCh, &st) >= 0.50) && (newCh != '\0') && (newCh != r->ch))
                {
                    // "/I" instead of 'A' in the middle of an uppercase word
                    if ((st != NULL) && (newCh == 'n')) {
                        ConnectedComponentList cpl = st->getConnectedComponents();
                        if ((cpl.size() == 2) || ((cpl.size() > 2) && (cpl[2].area < cpl[1].area * 0.05))) {
                            // Single connected component
                            int totalCountLettersBefore = 0, totalCountLettersAfter = 0;
                            int countUpperBefore = OCRUtilsCountUpperBefore(r, totalCountLettersBefore);
                            int countUpperAfter = OCRUtilsCountUpperAfter(r->next, totalCountLettersAfter);
                            if ((countUpperBefore  + countUpperAfter > 0)
                                && (totalCountLettersBefore == countUpperBefore)
                                && (totalCountLettersAfter == countUpperAfter)
                                && (combinedRect.size.height > statsWithoutCurrentAndNext->averageHeightUppercase.average * (1 - OCR_ACCEPTABLE_ERROR))) {
                                newCh = 'A';
                            }
                        }
                    }
                }
//                // 'N'? See https://drive.google.com/open?id=0B4jSQhcYsC9VclZnNmVJSU9DbU0
//                if (!doit && !(r->flags6 & FLAGS6_TESTED_AS_N) && (combinedRect.size.width < results->globalStats.averageWidthDigits.average * 1.15) && (combinedRect.size.width > results->globalStats.averageWidthDigits.average * 0.85)) {
//                    r->flags6 |= FLAGS6_TESTED_AS_N;
//                    if (st == NULL)
//                        st = CreateSingleLetterTests(combinedRect, results);
//                        if (st != NULL) {
//                            // Left top bar thicker than right top bar, same at bottom
//                            SegmentList slTop25 = st->getHorizontalSegments(0.125, 0.25);
//                            SegmentList slBottom25 = st->getHorizontalSegments(0.875, 0.25);
//                            if ((slTop25.size() == 2) && (slBottom25.size() == 2)
//                                && (slTop25[0].endPos - slTop25[0].startPos > slTop25[1].endPos - slTop25[1].startPos)
//                                && (slBottom25[0].endPos - slBottom25[0].startPos < slBottom25[1].endPos - slBottom25[1].startPos)) {
//                                // Now require indent from bottom on left side + indent from top on right side
//                                CGRect topHalf = CGRect(rectLeft(combinedRect), rectBottom(combinedRect), combinedRect.size.width * 0.40, combinedRect.size.height * 0.50);
//                                CGRect bottomHalf = CGRect(rectLeft(combinedRect) + combinedRect.size.width * 0.60, rectBottom(combinedRect) + combinedRect.size.height * 0.50, combinedRect.size.width * 0.40, combinedRect.size.height * 0.50);
//                                SingleLetterTests *stTop = CreateSingleLetterTests(topHalf, results);
//                                SingleLetterTests *stBottom = CreateSingleLetterTests(bottomHalf, results);
//                                if ((stTop != NULL) && (stBottom != NULL)) {
//                                    OpeningsTestResults res;
//                                    bool success = stTop->getOpenings(res,
//                                        SingleLetterTests::Bottom,
//                                        0.00,      // Start of range to search (top/left)
//                                        1.00,      // End of range to search (bottom/right)
//                                        SingleLetterTests::Bound,   // Require start (top/left) bound
//                                        SingleLetterTests::Bound);  // Require end (bottom/right) bound
//                                    if (success) {
//                                        success = stBottom->getOpenings(res,
//                                            SingleLetterTests::Top,
//                                            0.00,      // Start of range to search (top/left)
//                                            1.00,      // End of range to search (bottom/right)
//                                            SingleLetterTests::Bound,   // Require start (top/left) bound
//                                            SingleLetterTests::Bound);  // Require end (bottom/right) bound
//                                        if (success) {
//                                            newCh = 'N';
//                                            doit = true;
//                                        }
//                                    }
//                                }
//                                if (stTop != NULL) delete stTop;
//                                if (stBottom != NULL) delete stBottom;
//                            }
//                        }
//                }
                if (doit) {
                    replaceTwoWithRect(r, newCh, combinedRect, "rule 0015");
                    makeAnotherPass = true;
                }
                if (st != NULL) delete st;
            }

            // UJ instead of W
            // ul instead of w (
            if (((r->ch == 'U') || (r->ch == 'u')) && (r->next != NULL) && ((r->next->ch == 'J') || isVerticalLine(r->next->ch)) && (rectSpaceBetweenRects(r->rect, r->next->rect) <= 0)
                // Also require that the 'l' NOT be much taller, see genuine "ul"
                && (r->next->rect.size.height < r->rect.size.height * 1.20)
                )
            {
                wchar_t newCh = '\0';
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                if ((SingleLetterTestW(r, combinedRect, statsWithoutCurrentAndNext, results, newCh) > 0) && (newCh != r->ch) && (newCh != '\0'))
                {
                    replaceTwoWithRect(r, newCh, combinedRect, "rule 0116");
                    makeAnotherPass = true;
                }
            }

            // "IQ" instead of 'R'
            if ((r->ch == 'I') && (r->next != NULL) && (r->next->ch == 'Q') && ((spaceBetween = rectSpaceBetweenRects(r->rect, r->next->rect)) <= 0) && (results->imageTests) && (round == 0)) 
            {
                float minY = MIN(rectBottom(r->rect), rectBottom(r->next->rect));
                float maxY = MAX(rectTop(r->rect), rectTop(r->next->rect));
                CGRect combinedRect(rectLeft(r->rect), minY, rectRight(r->next->rect) - rectLeft(r->rect) + 1, maxY - minY + 1);
                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
                if (st != NULL) {
                    ConnectedComponentList cpl = st->getConnectedComponents();
                    if ((cpl.size() == 2) || ((cpl.size() >= 3) && (cpl[2].area < cpl[1].area * 0.05))) {
                        // Test that at the bottom we find the legs of the R, nothing else
                        SegmentList sl = st->getHorizontalSegments(0.92, 0.15);
                        if (sl.size() == 2) {
                            Segment leftLeg = sl[0];
                            Segment rightLeg = sl[1];
                            if ((leftLeg.endPos < combinedRect.size.width * 0.30) && (rightLeg.startPos > combinedRect.size.width * 0.40)) {
                                replaceTwoWithRect(r, 'R', combinedRect);
                            }
                        }
                    }
                    delete st;
                } // st != NULL
            }

            // r: instead of r. (in italics line)
            if ((r->ch == 'r') && (r->next!= NULL) && (r->next->ch == ':') && (rectSpaceBetweenRects(r->rect, r->next->rect) <= 0) && (results->imageTests) && !(r->next->flags5 & FLAGS5_TESTED_AS_DOT)) {
                r->next->flags5 |= FLAGS5_TESTED_AS_DOT;
                float minY = MIN(rectBottom(r->rect), rectBottom(r->next->rect));
                float maxY = MAX(rectTop(r->rect), rectTop(r->next->rect));
                CGRect combinedRect (rectLeft(r->rect), minY, rectRight(r->next->rect) - rectLeft(r->rect) + 1, maxY - minY + 1);
                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
                if (st != NULL) {
                    ConnectedComponentList cpl = st->getConnectedComponents();
                    if ( ((cpl.size() == 3) || ((cpl.size() > 3) && (cpl[3].area < cpl[2].area * 0.15)))
                         // Dot is below
                         && (cpl[2].ymin - cpl[1].ymin > cpl[1].getHeight() * 0.40) ) {
                            char newCh = '.';
                        ReplacingLog("Validate: rule 0078 replacing [%c] with [%c] in word [%s]", (unsigned short)r->next->ch, (unsigned short)newCh, toUTF8(r->word->text()).c_str());
                        CGRect newRect(rectLeft(combinedRect) + cpl[2].xmin, rectBottom(combinedRect) + cpl[2].ymin, cpl[2].getWidth(), cpl[2].getHeight());
                        r->word->updateLetterWithNewCharAndNewRect(r->next, newCh, newRect);
                        makeAnotherPass = true; 
                    }
                    // Single component case (where it's a 'c') is handled later
                    delete st;
                } // st != NULL
            }

            // I instead of M
            if ((r->ch == 'I') && !(r->flags5 & FLAGS5_TESTED_AS_M) && (r->rect.size.width > r->rect.size.height))
            {
                int res = SingleLetterTestAsM(r, r->rect, results);
                r->flags5 |= FLAGS5_TESTED_AS_M;
                if (res == 1) {
                    char newCh = 'M';
                    ReplacingLog("Validate: rule 0511 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)newCh, toUTF8(r->word->text()).c_str());
                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                    makeAnotherPass = true;                    
                }
            }
            
            // _ entirely subsumed within the preceeding or next letter X range + below => eliminate
            if (((r->ch == '_') || (r->ch == '.'))
                && ( ((r->next != NULL) && (r->next->ch != ' ') && (rectLeft(r->rect) >= rectLeft(r->next->rect)) && (rectRight(r->rect) <= rectRight(r->next->rect)) && (rectTop(r->next->rect) < rectBottom(r->rect)))
                   || ((r->previous != NULL) && (r->previous->ch != ' ') && (rectLeft(r->rect) >= rectLeft(r->previous->rect)) && (rectRight(r->rect) <= rectRight(r->previous->rect)) && (rectTop(r->previous->rect) < rectBottom(r->rect))) ))
            {
                ReplacingLog("Validate: rule 0292 replacing - removing [%c] in word [%s]", (unsigned short)r->ch, toUTF8(r->word->text()).c_str());
                SmartPtr<OCRRect> tmpR = r->next;
                r->word->removeLetter(r);
                r = tmpR;
                makeAnotherPass = true;
                continue;
            }
 
            // _- instead of -
            if (((r->ch == '_') || (r->ch == '-')) && (r->next != NULL) && ((r->next->ch == '_') || (r->next->ch == '-'))
                && (rectLeft(r->rect) == rectLeft(r->next->rect)) && (rectRight(r->rect) == rectRight(r->next->rect))) {
                char newCh = '-';
                float minY = MIN(rectBottom(r->rect), rectBottom(r->next->rect));
                float maxY = MAX(rectTop(r->rect), rectTop(r->next->rect));
                CGRect newRect (rectLeft(r->rect), minY, r->rect.size.width, maxY - minY + 1); 
                if ((r->ch == '_') || (r->next->ch == '_')) {
                    if ( ((r->previous != NULL) && isLetterOrDigit(r->previous->ch) && (rectTop(r->previous->rect) - rectTop(newRect) < r->previous->rect.size.height * 0.10)) 
                        || ((r->next->next != NULL) && isLetterOrDigit(r->next->next->ch) && (rectTop(r->next->next->rect) - rectTop(newRect) < r->next->next->rect.size.height * 0.10)) ) {
                        newCh = '_';
                    }
                }
                replaceTwoWithRect(r, newCh, newRect, "rule 0066"); // = '_' or = '-'
            }
            
            // spurious '_' entirely included in preceding 'o'
            if ((r->ch == '_') && (r->previous != NULL) 
                // Almost included in previous letter
                && (rectRight(r->rect) - rectRight(r->previous->rect) < r->rect.size.width * 0.20)
                // Entirely below next letter by more than its height
                && ((r->next == NULL) || (isNormalChar(r->next->ch) && (rectBottom(r->rect) - rectTop(r->next->rect) >= r->rect.size.height))) 
                // Abnormally narrow
                && (r->rect.size.width < statsWithoutCurrent->averageWidthNormalLowercase.average * 0.50)
                )
            {
                bool doit = false;
                // Testing that it's below the previous letter is tricky because the rect of the previous letter may include the '_'
                // Entirely below previous letter by more than its height
                if (isNormalChar(r->previous->ch)) {
                    if (rectBottom(r->rect) - rectTop(r->previous->rect) > r->rect.size.height) 
                    {
                        doit = true;
                    } else if (results->imageTests) 
                    {
                        SingleLetterTests *st = CreateSingleLetterTests(r->previous->rect, results);
                        if (st != NULL) {
                            ConnectedComponentList cpl = st->getConnectedComponents();
                            if (cpl.size() >= 2) {
                                ConnectedComponent mainCC = cpl[1];
                                CGRect mainCCRect (rectLeft(r->previous->rect) + mainCC.xmin, rectBottom(r->previous->rect) + mainCC.ymin, mainCC.getWidth(), mainCC.getHeight());
                                // Now test again
                                if ((rectBottom(r->rect) - rectTop(mainCCRect) >= r->rect.size.height)) {
                                    doit = true;
                                }
                            }
                            delete st;
                        }
                    }
                }
                if (doit) {
                    ReplacingLog("Validate: replacing - removing [%c] in word [%s]", (unsigned short)r->ch, toUTF8(r->word->text()).c_str());
                    SmartPtr<OCRRect> tmpR = r->next;
                    r->word->removeLetter(r);
                    r = tmpR;
                    makeAnotherPass = true;
                    continue;
                }
            }

            // 11 instead of 4 and 14 instead of 4
            if ((r->ch == '1') && (r->next != NULL) && ((r->next->ch == '1') || (r->next->ch == '4'))
                && results->imageTests
                && (round == 0)
                // First letter smaller, 2nd much smaller
                && (statsWithoutCurrentAndNext->averageHeightDigits.count >= 2) && (r->rect.size.height < line->averageHeightDigits.average * 0.90) && (r->next->rect.size.height < line->averageHeightDigits.average * 0.80)
                && (rectSpaceBetweenRects(r->rect, r->next->rect) < 0))
            {
                float minY = MIN(rectBottom(r->rect), rectBottom(r->next->rect));
                float maxY = MAX(rectTop(r->rect), rectTop(r->next->rect));
                float newHeight = maxY - minY + 1;
                float newWidth = rectRight(r->next->rect) - rectLeft(r->rect) + 1;
                CGRect newRect (rectLeft(r->rect), minY, newWidth, newHeight);
                // Verify the combined letter is wide enough
                if (newWidth > statsWithoutCurrentAndNext->averageWidthDigits.average * 0.93) {
                    SingleLetterTests *st = CreateSingleLetterTests(newRect, results);
                    if (st != NULL) {
                        ConnectedComponentList cpl = st->getConnectedComponents();
                        if ((cpl.size() == 2) || ((cpl.size() > 2) && (cpl[2].area < cpl[1].area * 0.05))) {
                            replaceTwoWithRect(r, '4', newRect);
                            makeAnotherPass = true;
                        }
                        delete st;
                    } // st != NULL
                }
            }

            // ii instead of t
            if ((r->ch == 'i') && (r->next != NULL) && (r->next->ch == 'i') && (rectSpaceBetweenRects(r->rect, r->next->rect) <= 0) && (r->rect.size.height > r->next->rect.size.height * 1.06) && (r->rect.size.width > r->next->rect.size.width * 1.20)
                // And next letter is below top of first letter
                && (rectBottom(r->next->rect) - rectBottom(r->rect) > r->rect.size.height * 0.06))
            {
                bool doit = true;
                float xMin = rectLeft(r->rect);
                float newWidth = rectRight(r->next->rect) - xMin + 1;
                float yMin = MIN(rectBottom(r->rect), rectBottom(r->next->rect));
                float yMax = MAX(rectTop(r->rect), rectTop(r->next->rect));
                float newHeight = yMax - yMin + 1;
                CGRect combinedRect(xMin, yMin, newWidth, newHeight);
                if (results->imageTests && !(r->flags2 & FLAGS2_TESTED)) {
                    r->flags2 |= FLAGS2_TESTED;
                    SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
                    if (st != NULL) {
                        ConnectedComponentList cpl = st->getConnectedComponents();
                        if ((cpl.size() > 2) && (cpl[2].area > cpl[1].area * 0.05)) {
                            doit = false;
                        }
                        delete st;
                    } // st != NULL
                } // single-letter
                
                if (doit) {
                    replaceTwoWithRect(r, 't', combinedRect);
                    r->confidence += 500; // Request 2nd opinion, could be a 'f'
                    makeAnotherPass = true;
                }
            }

            // n1 instead of m
            if ((r->ch == 'n') && (r->next != NULL) && (r->next->ch == '1') && (r->rect.size.height < r->next->rect.size.height * 1.1) && (r->rect.size.height > r->next->rect.size.height * 0.90) && (rectSpaceBetweenRects(r->rect, r->next->rect) <= 0) && !(r->flags3 & FLAGS3_TESTED_AS_m)) 
            {
                bool doit = true;
                if (results->imageTests) {
                    r->flags3 |= FLAGS3_TESTED_AS_m;
                    char ch1 = '0';
                    char ch2 = '\0';
                    CGRect rect1, rect2;
                    bool recommend = SingleLetterTestAsm(r, results, &ch1, &rect1, &ch2, &rect2);
                    r->flags3 |= FLAGS3_TESTED_AS_m;
                    if (!recommend || (ch2 != '\0')) {
                        doit = false;
                    }
                }
                if (doit) {
                    replaceTwo(r, 'm', "rule 0022"); // = 'm'
                    makeAnotherPass = true;
                }
            }

            // FI instead of R
            if ((r->ch == 'F') && (r->next != NULL) 
                && ((r->next->ch == 'I') 
                    // If vertical line, be more caution and eliminate patters that are not narrow and tall
                    || (isVerticalLine(r->next->ch) && (r->next->rect.size.height > r->next->rect.size.width * 2.4)))
                // Check tallness to ignore Fi - even then the 'i' may be considered tall but no worries, single letter tetsting will catch
                && (tallHeightTest(statsWithoutCurrent.getPtr(), r->next->rect.size.height, '\0', false, 0, false) == 1)
                && ((spaceBetween = rectSpaceBetweenRects(r->rect, r->next->rect)) <= 0)
                && (spaceBetween < statsWithoutCurrent->averageSpacing.average)
                && (round == 0))
            {
                bool doit = true;
                if (results->imageTests) {
                    float minY = MIN(rectBottom(r->rect), rectBottom(r->next->rect));
                    float maxY = MAX(rectTop(r->rect), rectTop(r->next->rect));
                    float newHeight = maxY - minY + 1;
                    CGRect rectCombined(rectLeft(r->rect),minY, rectRight(r->next->rect) - rectLeft(r->rect) + 1, newHeight);
                    SingleLetterTests *st = CreateSingleLetterTests(rectCombined, results);
                    if (st != NULL) 
                    {
                        ConnectedComponentList cpl = st->getConnectedComponents();
                        if ((cpl.size() >= 3) && (cpl[2].area > cpl[1].area * 0.15)) {
                            doit = false;
                        }
                        if (doit) {
                            ConnectedComponentList invertCpl = st->getInverseConnectedComponents();
                            DebugLog("FI test: main invert area=%d, rectCombined = [%f,%f]", invertCpl[1].area, rectCombined.size.width, rectCombined.size.height);
                            if ((invertCpl.size() < 2) || (invertCpl[1].area < rectCombined.size.width * rectCombined.size.height * 0.05)) {
                                doit = false;
                            }
                        }
                        delete st;
                    } // st != NULL
                    if (doit) {
                        replaceTwoWithRect(r, 'R', rectCombined); // = 'R'
                        makeAnotherPass = true;
                    }
                } // results->imageTests
            }

            // "/4" instead of 'A'
            if ((r->ch == '/') && (r->next != NULL) && (r->next->ch == '4') && results->imageTests && (rectSpaceBetweenRects(r->rect, r->next->rect) < 0) && ((r->previous == NULL) || !isDigit(r->previous->ch)) && ((r->next->next == NULL) || !isDigit(r->next->next->ch)) && !(r->flags2 & FLAGS2_TESTED)) 
            {
                r->flags |= FLAGS2_TESTED;
                // Just verify there is really just one large major component => 'A'
                float minY = MIN(rectBottom(r->rect), rectBottom(r->next->rect));
                float maxY = MAX(rectTop(r->rect), rectTop(r->next->rect));
                float newHeight = maxY - minY + 1;
                CGRect rectCombined(rectLeft(r->rect),minY, rectRight(r->next->rect) - rectLeft(r->rect) + 1, newHeight);
                SingleLetterTests *st = CreateSingleLetterTests(rectCombined, results);
                if (st != NULL) 
                {
                    ConnectedComponentList cpl = st->getConnectedComponents();
                    if ((cpl.size() < 3) || (cpl[2].area < cpl[1].area * 0.15))
                    {
                        // One more check: need to find an inverted component above 35% line
                        ConnectedComponent mainComp = cpl[1];
                        ConnectedComponentList invertCpl = st->getInverseConnectedComponents();
                        if (invertCpl.size() >= 2) {
                            ConnectedComponent  mainInvert = invertCpl[1];
                            if ((mainInvert.area > mainComp.area * 0.03) && (mainInvert.ymax > rectCombined.size.height * 0.35)  && (mainInvert.xmin > rectCombined.size.width * 0.20))
                            {
                                replaceTwo(r, 'A', "rule 0023", minY, newHeight);
                                makeAnotherPass = true;
                            }
                        }
                    }
                    delete st;
                } // st != NULL
            }

            // Map n/ to rv
            if ((r->ch == 'n') && (r->next != NULL) && (r->next->ch == '/') && (results->imageTests) && !(r->next->flags2 & FLAGS2_TESTED)
                // Not much taller than normal lowercase (unlike a real /)
                && (r->next->rect.size.height < statsWithoutCurrentAndNext->averageHeightNormalLowercase.average * (1 + OCR_ACCEPTABLE_ERROR)) && (rectSpaceBetweenRects(r->rect, r->next->rect))) {
                r->flags2 |= FLAGS2_TESTED;
                float minY = MIN(rectBottom(r->rect), rectBottom(r->next->rect));
                float maxY = MAX(rectTop(r->rect), rectTop(r->next->rect));
                CGRect newRect(rectLeft(r->rect), minY, rectRight(r->next->rect) - rectLeft(r->rect) + 1, maxY - minY + 1);
                SingleLetterTests *st = CreateSingleLetterTests(newRect, results);
                if (st != NULL) {
                    bool abortTest = false;
                    ConnectedComponentList cpl = st->getConnectedComponents();
                    if (cpl.size() > 2) {
                        ConnectedComponent cp1, cp2;
                        if (cpl[2].xmin > cpl[1].xmin) {
                            cp1 = cpl[1];
                            cp2 = cpl[2];
                        } else {
                            cp1 = cpl[2];
                            cp2 = cpl[1];
                        }
                        // This is the case where the letter are not connected - test differently
                        CGRect letter1Rect (rectLeft(newRect) + cp1.xmin, rectBottom(newRect) + cp1.ymin, 
                                cp1.getWidth(), cp1.getHeight()); 
                        CGRect letter2Rect (rectLeft(newRect) + cp2.xmin, rectBottom(newRect) + cp2.ymin, 
                                cp2.getWidth(), cp2.getHeight());        
                        SingleLetterTests *st1 = CreateSingleLetterTests(letter1Rect, results);
                        if (st1 != NULL) 
                        {
                            OpeningsTestResults bottom;
                            bool success = st1->getOpenings(bottom, 
                                SingleLetterTests::Bottom, 
                                0.00,      // Start of range to search (top/left)
                                1.00,      // End of range to search (bottom/right)
                                SingleLetterTests::Bound,   // Require start (top/left) bound
                                SingleLetterTests::Unbound);  // Require end (bottom/right) bound
                                // Tall right opening expected from 'r'
                            if (success && (bottom.maxDepth > letter1Rect.size.height * 0.65)) 
                            {
                                SingleLetterTests *st2 = CreateSingleLetterTests(letter2Rect, results);
                                if (st2 != NULL) 
                                {
                                    OpeningsTestResults top;
                                    bool success = st2->getOpenings(top, 
                                        SingleLetterTests::Top, 
                                        0.00,      // Start of range to search (top/left)
                                        1.00,      // End of range to search (bottom/right)
                                        SingleLetterTests::Bound,   // Require start (top/left) bound
                                        SingleLetterTests::Bound);  // Require end (bottom/right) bound
                                        // Tall top opening expected from 'v'
                                    if (success && (top.maxDepth > letter2Rect.size.height * 0.65)) {
                                        char newCh1 = 'r';
                                        char newCh2 = 'v';
                                        ReplacingLog("Validate: replacing [%c%c] with [%c%c] in word [%s]", (unsigned short)r->ch, (unsigned short)r->next->ch, (unsigned short)newCh1, (unsigned short)newCh2, toUTF8(r->word->text()).c_str());
                                        r->word->updateLetterWithNewCharAndNewRect(r, newCh1, letter1Rect);
                                        r->word->updateLetterWithNewCharAndNewRect(r->next, newCh2, letter2Rect);
                                        makeAnotherPass = true;
                                        r = r->next;
                                        delete st;
                                        delete st1;
                                        delete st2;
                                        continue;                                    
                                    }
                                    delete st2;
                                }
                            }
                            delete st1;
                        }                         
                        abortTest = true;    
                    }
                    
                    if (!abortTest) {
                        // If we get here, it's the case where the letter are touching
                        OpeningsTestResults bottom;
                        bool success = st->getOpenings(bottom, 
                            SingleLetterTests::Bottom, 
                            0.00,      // Start of range to search (top/left)
                            1.00,      // End of range to search (bottom/right)
                            SingleLetterTests::Bound,   // Require start (top/left) bound
                            SingleLetterTests::Bound);  // Require end (bottom/right) bound
                        // Large bottom opening (expected from 'r' (and 'n' so not determinant yet)
                        if (success && (bottom.maxDepth > newRect.size.height * 0.65)) {
                            //Now check that the 'n' has a much wider opening at the bottom than say mid-way up
                            SegmentList midPoint = st->getHorizontalSegments(1 - bottom.maxDepth / 2 / newRect.size.height, 0.01);
                            SegmentList bottomPoint = st->getHorizontalSegments(0.9, 0.01);
                            // Expect 3 intersection mid-height because of the 'v'
                            if ((midPoint.size() >= 3)
                                && (bottomPoint.size() >= 2)) {
                                float midWidth = midPoint[1].startPos - midPoint[1].endPos;
                                float bottomWidth = bottomPoint[1].startPos - bottomPoint[1].endPos;
                                // Check that the slope of the left side of the v is no steeper than minus 67.5 degrees
                                if (bottomWidth > midWidth * (1 + (0.9 * newRect.size.height - bottom.maxDepth / 2) * 0.50)) {
                                    char newCh1 = 'r';
                                    char newCh2 = 'v';
                                    CGRect newRect1(rectLeft(newRect), rectBottom(newRect), newRect.size.width - r->next->rect.size.width * 2, newRect.size.height);
                                    CGRect newRect2(rectRight(newRect) - r->next->rect.size.width * 2, rectBottom(newRect), r->next->rect.size.width * 2, newRect.size.height);
                                    ReplacingLog("Validate: replacing [%c%c] with [%c%c] in word [%s]", (unsigned short)r->ch, (unsigned short)r->next->ch, (unsigned short)newCh1, (unsigned short)newCh2, toUTF8(r->word->text()).c_str());
                                    r->word->updateLetterWithNewCharAndNewRect(r, newCh1, newRect1);
                                    r->word->updateLetterWithNewCharAndNewRect(r->next, newCh2, newRect2);
                                    makeAnotherPass = true;
                                    r = r->next;
                                    continue;
                                }
                            }
                        }
                    } // !abortTest
                    delete st;
                }
            }

            // Map /I to 4 or A
            if ((r->ch == '/') && !(r->flags2 & FLAGS2_TESTED) && (r->next != NULL) && isVerticalLine(r->next->ch, results, true)
                && (rectSpaceBetweenRects(r->rect, r->next->rect) <= 0)) 
            {
                bool doit = false;
                char newCh = '\0';
                r->flags2 |= FLAGS2_TESTED;
                if (results->imageTests) {
                    float minY = MIN(rectBottom(r->rect), rectBottom(r->next->rect));
                    float maxY = MAX(rectTop(r->rect), rectTop(r->next->rect));
                    CGRect newRect (rectLeft(r->rect), minY,
                        rectRight(r->next->rect) - rectLeft(r->rect) + 1,
                        maxY - minY + 1);
                                           
                    SingleLetterTests *st = CreateSingleLetterTests(newRect, results);
                    if (st != 0) {
                        SegmentList sl = st->getVerticalSegments(0.50, 0.10); 
                        if (sl.size() >= 2) {
                            doit = true;
                            // Could still be a 'A', test that by looking for bounded opening at the bottom
                            OpeningsTestResults bottom;
                            bool success = st->getOpenings(bottom, 
                                SingleLetterTests::Bottom, 
                                0.00,      // Start of range to search (top/left)
                                1.00,      // End of range to search (bottom/right)
                                SingleLetterTests::Bound,   // Require start (top/left) bound
                                SingleLetterTests::Bound);  // Require end (bottom/right) bound
                        
                            if (success && (bottom.maxDepth > newRect.size.height * 0.20)) {
                                newCh = 'A';
                            } else {
                                newCh = '4';
                            }
                            // Check if a '.' was absorbed here
                            if ((r->previous != NULL) && (r->previous->ch != '.')) {
                                ConnectedComponentList cpl = st->getConnectedComponents();
                                // There is something else
                                if (cpl.size() > 2) {
                                    ConnectedComponent dot = cpl[2];
                                    ConnectedComponent main = cpl[1];
                                        // Not too small
                                    if ((dot.area > main.area * 0.08) 
                                        // Not too wide & on the left
                                        && (dot.xmax < newRect.size.width * 0.30) 
                                        // At the bottom
                                        && (dot.ymin > newRect.size.height * 0.75)) 
                                    {
                                        // Insert a '.'
                                        CGRect extraRect(rectLeft(r->rect) + dot.xmin,
                                            rectBottom(r->rect) + dot.ymin,
                                            dot.getWidth(), dot.getHeight());
                                        ReplacingLog("Validate: replacing - inserting a [.] in word [%s]", toUTF8(r->word->text()).c_str());
                                        r->word->addLetterWithRectConfidenceAfterRect('.', extraRect, r->confidence, r->previous);
                                    }
                                }
                            }
                        } else if ((sl.size() == 1) && (sl[0].endPos < newRect.size.height * 0.10)) {
                            doit = true;
                            newCh = '1';
                        }
                        delete st;
                    }
                } else {
                    float gapAbove = rectTop(r->next->rect) - rectTop(r->rect);
                    if (gapAbove  > r->next->rect.size.height * 0.10) {
                        doit = true;
                        newCh = '4';
                        if (gapAbove  > r->next->rect.size.height * 0.60) {
                            newCh = '1';
                        }
                    }
                }
                     
                if (doit && (newCh != '\0')) {
                    replaceTwo(r, newCh);
                }
            }
            
            // Map "l." or "L."
            if (((r->ch == 'L') || isVerticalLine(r->ch)) && (r->next != NULL)
                && ((r->next->ch == '_') || (r->next->ch == '.'))  
                // Tall - but skip that test if all letters are of same height except first (based on enough data)
                && ((sameHeightExceptFirst && (heightExceptFirst.count > 2)) || (tallHeightTest(statsWithoutCurrentAndNext.getPtr(), r->rect.size.height, 'L', false, 1, true) == 1))
                // Glued
                && (rectSpaceBetweenRects(r->rect, r->next->rect) <= 0)) {
                bool useTwo = false, useThree = false, useFour = false;  // Combine 2, 3 or 4 letters?
                
                // L + at least one dot?
                if ((r->next != NULL) && ((r->next->ch == '_') || (r->next->ch == '.'))
                    // glued together
                    && (rectSpaceBetweenRects(r->rect, r->next->rect) <= 0))
                    useTwo = true;
                
                // L + two dots?
                if (useTwo && (r->next->next != NULL) && ((r->next->next->ch == '_') || (r->next->next->ch == '.'))
                    // glued together
                    && (rectSpaceBetweenRects(r->next->rect, r->next->next->rect) <= 0))
                    useThree = true;
                
                // If we decided not to include two dots, verify that 2-letters hypothesis still valid
                if (useTwo && !useThree) {
                    if ( !((r->next->next ==  NULL)
                        // Not glued to following character
                        || (rectSpaceBetweenRects(r->next->rect, r->next->next->rect) > 0)
                        // Or next character has space under it on left side
                        || isLeftOverhangUppercase(r->next->next->ch)) )
                        useTwo = false;
                }
                
                // L + 3 dots?
                if (useThree && (r->next->next->next != NULL) && ((r->next->next->next->ch == '_') || (r->next->next->next->ch == '.'))
                    // glued together
                    && (rectSpaceBetweenRects(r->next->next->rect, r->next->next->next->rect) <= 0)
                    && ((r->next->next->next->next ==  NULL)
                       // Not glued to following character
                        || (rectSpaceBetweenRects(r->next->next->next->rect, r->next->next->next->next->rect) > 0)
                        // Or next character has space under it on left side
                        || isLeftOverhangUppercase(r->next->next->next->next->ch)) )
                    useFour = true;
                
                // If we decided not to include 3 dots, verify that L + 2 dots hypothesis still valid
                if (useThree && !useFour) {
                    if ( !((r->next->next->next ==  NULL)
                           // Not glued to following character
                           || (rectSpaceBetweenRects(r->next->next->rect, r->next->next->next->rect) > 0)
                           // Or next character has space under it on left side
                           || isLeftOverhangUppercase(r->next->next->next->ch)) )
                        useThree = false;
                }
                
                if (useTwo || useThree || useFour)
                {
                    // Measure width of bottom-right leg of the alleged 'L'
                    float rightPartWidth;
                    if (useFour)
                        rightPartWidth = (rectRight(r->next->next->next->rect) - rectLeft(r->next->rect));
                    else if (useThree)
                        rightPartWidth = (rectRight(r->next->next->rect) - rectLeft(r->next->rect));
                    else
                        rightPartWidth = r->next->rect.size.width;
                    
                    if ((rightPartWidth > r->rect.size.width) || (r->ch == 'L'))
                    {
                        float minY = MIN(rectBottom(r->rect), rectBottom(r->next->rect));
                        if (useThree || useFour)
                            minY = MIN(minY, rectBottom(r->next->next->rect));
                        if (useFour)
                            minY = MIN(minY, rectBottom(r->next->next->next->rect));
                        float maxY = MAX(rectTop(r->rect), rectTop(r->next->rect));
                        if (useThree || useFour)
                            maxY = MAX(maxY, rectTop(r->next->next->rect));
                        if (useFour)
                            maxY = MAX(maxY, rectTop(r->next->next->next->rect));
                        float newHeight = maxY - minY + 1;
                        if (results->imageTests
                            // Test that top of first '.' starts below mid-point of 'L'
                            && (rectBottom(r->next->rect) - rectBottom(r->rect) > r->rect.size.height * 0.60)) {
                            float newWidth;
                            if (useThree)
                                newWidth = rectRight(r->next->next->rect) - rectLeft(r->rect) + 1;
                            else if (useFour)
                                newWidth = rectRight(r->next->next->next->rect) - rectLeft(r->rect) + 1;
                            else
                                newWidth = rectRight(r->next->rect) - rectLeft(r->rect) + 1;
                            CGRect bothRect(rectLeft(r->rect), minY, newWidth, newHeight);
                            SingleLetterTests *st = CreateSingleLetterTests(bothRect, results);
                            if (st != NULL) {
                                ConnectedComponentList cpl = st->getConnectedComponents();
                                if (cpl.size() <= 2) {
                                    if (useFour)
                                        replaceFourWithRect(r, 'L', bothRect);
                                    else if (useThree)
                                        replaceThreeWithRect(r, 'L', bothRect);
                                    else
                                        replaceTwoWithRect(r, 'L', bothRect);
                                    makeAnotherPass = true;
                                }
                                delete st;
                            } // st != NULL
                        } // results -> singletter
                    }
                } // use 2, 3 or 4 characters
            }

            // Map "nn" to "rm" if glued and there is a bridge above connecting them but an opening from the bottom
            if ((round == 0) && (r->ch == 'n') && (r->next != NULL) && (r->next->ch == 'n') && (rectSpaceBetweenRects(r->rect, r->next->rect) <= 0) && (results->imageTests))
            {
                float minY = MIN(rectBottom(r->rect), rectBottom(r->next->rect));
                float maxY = MAX(rectTop(r->rect), rectTop(r->next->rect));
                float newHeight = maxY - minY + 1;
                CGRect newRect(rectLeft(r->rect), minY, rectRight(r->next->rect) - rectLeft(r->rect) + 1, newHeight);
                
                SingleLetterTests *st = CreateSingleLetterTests(newRect, results);
                
                OpeningsTestResults bottom1;
                bool success = st->getOpenings(bottom1, 
                    SingleLetterTests::Bottom, 
                    0,      // Start of range to search (top/left)
                    0.30,      // End of range to search (bottom/right)
                    SingleLetterTests::Bound,   // Require start (top/left) bound
                    SingleLetterTests::Bound  // Require end (bottom/right) bound
                    );
                        
                if (success && (bottom1.maxDepth > newRect.size.height * 0.40)) {
                    OpeningsTestResults bottom3;
                    bool success = st->getOpenings(bottom3, 
                        SingleLetterTests::Bottom, 
                        0.70,      // Start of range to search (top/left)
                        1.00,      // End of range to search (bottom/right)
                        SingleLetterTests::Bound,   // Require start (top/left) bound
                        SingleLetterTests::Bound  // Require end (bottom/right) bound
                        );
                    if (success && (bottom3.maxDepth > newRect.size.height * 0.40) && (bottom1.maxWidth > bottom3.maxWidth * 1.25)) {
                        CGRect newRect1(rectLeft(r->rect), rectBottom(r->rect), r->rect.size.width * 0.80, newRect.size.height);
                        CGRect newRect2(rectRight(r->rect) + 1, rectBottom(r->next->rect), newRect.size.width - (r->rect.size.width + 1) - 1, r->next->rect.size.height);
                        char newCh1 = 'r';
                        char newCh2 = 'm';
                        ReplacingLog("Validate: replacing [%c%c] with [%c%c] in word [%s]", (unsigned short)r->ch, (unsigned short)r->next->ch, (unsigned short)newCh1, (unsigned short)newCh2, toUTF8(r->word->text()).c_str());
                        r->word->updateLetterWithNewCharAndNewRect(r, newCh1, newRect1);
                        r->flags2 |= NO_SPACE;
                        r->word->updateLetterWithNewCharAndNewRect(r->next, newCh2, newRect2);
                        makeAnotherPass = true;
                    }
                }
 
                delete st;
            }

            // Map glued "(3" to 'G'
            if ((r->ch == '(') && (r->next != NULL) && !(r->next->flags & TESTED_OPENING_RIGHT) && (r->next->ch == '3') && ((spaceBetween = rectSpaceBetweenRects(r->rect,r->next->rect)) <= 0) && (statsWithoutCurrentAndNext->averageSpacing.average > 0)) {
                int doit = -1;
                if (results->imageTests) {
                    
                    CGRect newRect (rectLeft(r->rect),
                        rectBottom(r->rect),
                        rectRight(r->next->rect) - rectLeft(r->rect) + 1,
                        r->rect.size.height);
                    
                    SingleLetterTests* st = CreateSingleLetterTests(newRect, results);
                
                    // Pretend we tested the '3' from the rights o that next round doesn't do it
                    r->next->flags |= TESTED_OPENING_RIGHT;
            
                    if (st != NULL) {
                        ConnectedComponentList cpl = st->getConnectedComponents();
                        // Check that we have a main component
                        if (cpl.size() > 1) {
                            // Get main component dimensions
                            ConnectedComponent mainComp = cpl[1];
                        
                            if (mainComp.getHeight() * mainComp.getWidth() > newRect.size.height * newRect.size.width * 0.75) { 
                                OpeningsTestResults resRight;
                                bool success = st->getOpenings(resRight, SingleLetterTests::Right, 
                                    0.2,      // Start of range to search (top/left)
                                    0.8,      // End of range to search (bottom/right)
                                    SingleLetterTests::Bound,   // Require start (top/left) bound
                                    SingleLetterTests::Bound  // Require end (bottom/right) bound
                                    );
                            
                                if (success && resRight.maxDepth > r->next->rect.size.width * 0.10) {
                                    doit = 1;
                                } else {
                                    doit = 0;
                                }
                            }
                        }
                    } // st != NULL                    
                } // Singleletter
                if (doit == -1) {
                    // Single letter was not ran - may accept still but be cautious
                    if (!OCRLine::isPresentInLineAfterRect(')', r->next))
                        doit = 1;
                }
                if (doit == 1) {
                    replaceTwo(r, 'G');
                    makeAnotherPass = true;
                }
            }

            // "!-" -> 'T'
            // [T (0x54)] at [388,145 - 418,167] [w=31,h=23]
            // [! (0x21)] at [417,145 - 427,167] [w=11,h=23]
            // [0x2018 - UTF8=e2 80 98] at [426,161 - 433,167] [w=8,h=7]
            if (isVerticalLine(r->ch, results, true) && (r->next != NULL) && (isDash(r->next->ch) || isQuote(r->next->ch)) && (rectSpaceBetweenRects(r->rect, r->next->rect) <= 0)) {
                SmartPtr<OCRRect> p;
                if ((r->previous != NULL) && isUpper(r->previous->ch)) {
                    p = r->previous;
                } else if ((r->next->next != NULL) && isUpper(r->next->next->ch)) {
                    p = r->next->next;
                }
                if ((p != NULL) 
                    // The "dash" (roof of the alleged 'T') is close to the roof of the reference uppercase letter
                    && (abs(rectDeltaBetweenBottoms(r->next->rect, p->rect)) < OCR_ACCEPTABLE_ERROR)) {
                    float minBottom = MIN(rectBottom(r->rect), rectBottom(r->next->rect));
                    float maxTop = MAX(rectTop(r->rect), rectTop(r->next->rect));
                    float newHeight = maxTop - minBottom + 1;
                    float newWidth = rectRight(r->next->rect) - rectLeft(r->rect) + 1;
                    if ((abs(newHeight - p->rect.size.height) < OCR_ACCEPTABLE_ERROR) && (abs(newWidth - statsWithoutCurrent->averageWidthUppercase.average) < OCR_ACCEPTABLE_ERROR)){
                        // Final test: verify that the new combined letter really does have a top
                        float kosher = true;
                        if (results->imageTests) {
                            CGRect newRect(rectLeft(r->rect),
                                        minBottom,
                                        newWidth,
                                        newHeight);
                            bool hasTop;
                            bool success = OCRUtilsTopTest(newRect, results, &hasTop);
                            
                            if (success && !hasTop) {
                                kosher = false;
                            }
                        }
                        if (kosher) {
                            replaceTwo(r, 'T', "rule 0024", minBottom, newHeight);
                            makeAnotherPass = true;
                        }
                    }
                }
            }
            
            // Map "1" to "rt" or "r1" to "rt" (if lowercase letters after that)
            // U+0131		c4 b1	LATIN SMALL LETTER DOTLESS I
            if ((r->next != NULL) 
                && ((r->ch == 0x0131) 
                  || ((r->ch == 'r') && (r->next->next != NULL) && isLower(r->next->next->ch)))
                 && (r->next->ch == '1') && (r->next->rect.size.height > r->rect.size.height * (1+OCR_ACCEPTABLE_ERROR)) && (rectSpaceBetweenRects(r->rect, r->next->rect) <= 0)) {
                wchar_t newCh1 = 'r';
                wchar_t newCh2 = 't';
                ReplacingLog("Validate: rule 0508 replacing [%c%c] with [%c%c] in word [%s]", (unsigned short)r->ch, (unsigned short)r->next->ch, (unsigned short)newCh1, (unsigned short)newCh2, toUTF8(r->word->text()).c_str());
                r->word->updateLetterWithNewCharAndNewRect(r, newCh1, r->rect);
                r->word->updateLetterWithNewCharAndNewRect(r->next, newCh2, r->next->rect);
                r = r->next->next;
                makeAnotherPass = true;
                continue;                
            }
            
            // Any letter followed by a dash overlapping and glued means it's a bad dash, to be eliminated
            if ((r->next != NULL) && (results->imageTests) && isDash(r->next->ch) && !(r->next->flags2 & FLAGS2_TESTED_AS_DASH) && isLetter(r->ch)
                && (rectSpaceBetweenRects(r->rect, r->next->rect) < 0)
                && (statsWithoutCurrentAndNext->averageSpacing.average > 0))
            {
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                r->next->flags2 |= FLAGS2_TESTED_AS_DASH;
                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results, true, SINGLE_LETTER_VALIDATE_COMP_SIZE | SINGLE_LETTER_VALIDATE_SINGLE_COMP);
                if (st != NULL) {
                    // One more test: check for little notches top & bottom
                    bool doit = true;
                    OpeningsTestResults resBottom;
                    bool success = st->getOpenings(resBottom, SingleLetterTests::Bottom,
                                                   0.50,      // Start of range to search (top/left)
                                                   1.00,      // End of range to search (bottom/right)
                                                   SingleLetterTests::Bound,   // Require start (top/left) bound
                                                   SingleLetterTests::Bound  // Require end (bottom/right) bound
                                                   );
                    if (success) {
                        OpeningsTestResults resTop;
                        bool success = st->getOpenings(resTop, SingleLetterTests::Top,
                                                       0.50,      // Start of range to search (top/left)
                                                       1.00,      // End of range to search (bottom/right)
                                                       SingleLetterTests::Bound,   // Require start (top/left) bound
                                                       SingleLetterTests::Bound  // Require end (bottom/right) bound
                                                       );
                        if (success && (resTop.maxDepthCoord > 0)
                            && (resTop.maxDepthCoord < combinedRect.size.width)
                            && (abs(resTop.maxDepthCoord - resBottom.maxDepthCoord) < combinedRect.size.width * 0.15)) {
                            float dashWidth = (combinedRect.size.width - resTop.maxDepthCoord - 1);
                            SegmentList slDash = st->getVerticalSegments((combinedRect.size.width - dashWidth/2) / combinedRect.size.width, dashWidth/combinedRect.size.width);
                            if (slDash.size() == 1) {
#if DEBUG
                                SingleLetterPrint(slDash, combinedRect.size.height);
#endif
                                float dashHeight = (slDash[0].endPos - slDash[0].startPos + 1);
                                float dashYmin = slDash[0].startPos;
                                float dashYmax = slDash[0].endPos;
                                if ((dashWidth > dashHeight * 1.5)
                                    && (dashYmin > combinedRect.size.height * 0.30)
                                    && (dashYmax < combinedRect.size.height * 0.70)
                                    && (dashWidth > statsWithoutCurrent->averageWidth.average * 0.40)
                                    && (dashWidth > statsWithoutCurrent->averageWidth.average * 0.35)) {
                                    doit = false;
                                }
                            }
                        } // Opening top
                    } // Opening bottom
                    if (doit) {
                        ReplacingLog("Validate: rule 0043 replacing - removing [%c] in word [%s]", (unsigned short)r->next->ch, toUTF8(r->word->text()).c_str());
                        // Wait, could be a 'r' if we had "x-"
                        wchar_t replacementChar = r->ch;
                        if (r->ch == 'x') {
                            SegmentList slTop = st->getHorizontalSegments(0.10, 0.20);
                            SegmentList slBottom = st->getHorizontalSegments(0.925, 0.15);
                            if ((slTop.size() == 1) && (slBottom.size() == 1)) {
                                if ((slTop[0].endPos - slTop[0].startPos + 1) > (slBottom[0].endPos - slBottom[0].startPos + 1) * 1.30) {
                                    replacementChar = 'r';
                                }
                            }
                        }
                        // Need to update current rect (will get larger because of the glued dash)
                        r->word->updateLetterWithNewCharAndNewRect(r, replacementChar, combinedRect);
                        r->word->removeLetter(r->next);
                        makeAnotherPass = true;
                        // Don't skip that letter just yet, there might be a rule below we need to apply to it
                    }
                    delete st; 
                }
            }
            
            
            // Test G next to digits if looks like 0 or 6
            if ((r->ch == 'G') && (results->imageTests) && !(r->flags3 & FLAGS3_TESTED_AS_6)
                && (r->rect.size.height > r->rect.size.width * 1.4)
                && digitsNearby(r)) 
            {
                r->flags3 |= FLAGS3_TESTED_AS_6;
                int testResult = SingleLetterTestAs6(r, results, true, NULL);
                if ((testResult == 1) || (testResult == -1)) {
                    char newCh = '6';
                    ReplacingLog("ValidateLine: rule 0129 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                    makeAnotherPass = true;
                }
            }
            
            // Replace "rn" with 'm' when glued and rest of the line is well separated
            if ((r->ch == 'r') && (r->next != NULL) && (r->next->ch == 'n') && ((spaceBetween=rectLeft(r->next->rect) - rectRight(r->rect) - 1) <= 0)
               && (results->imageTests) && !(r->flags3 & FLAGS3_TESTED_AS_m)
               && ((statsWithoutCurrentAndNext->averageWidthNormalLowercase.count == 0) || (statsWithoutCurrentAndNext->averageSpacing.average >     statsWithoutCurrentAndNext->averageWidthNormalLowercase.average * 0.18))
                  ) {
                // OK to replace with 'm' even if tightly packed line because right below we test this 'm' for a possible 'rn'!
                replaceTwo(r, 'm');
                makeAnotherPass = true;
            }
            if ((r->ch == 'm') && (results->imageTests) && !(r->flags3 & FLAGS3_TESTED_AS_m)) 
            {
//#if DEBUG
//                if (((r->next != NULL) && (r->next->ch == 'e'))
//                    || ((r->previous != NULL) && (r->previous->ch == 'o'))) {
//                    DebugLog("Found in word [%s]", toUTF8(r->word->text()).c_str());
//                    DebugLog("");
//                }
//#endif
                char ch1, ch2;
                CGRect rect1, rect2;
                bool recommend = SingleLetterTestAsm(r, results, &ch1, &rect1, &ch2, &rect2);
                r->flags3 |= FLAGS3_TESTED_AS_m;
                if (recommend) {
                    if (ch2 != '\0') {
                        // Replace with two chars
                        ReplacingLog("ValidateLine: rule 0054 replacing [%c] with [%c%c] in word [%s]", (unsigned short)r->ch, ch1, ch2, toUTF8(r->word->text()).c_str());
                        r->word->updateLetterWithNewCharAndNewRect(r, ch1, rect1);
                        r->word->addLetterWithRectConfidenceAfterRect(ch2, rect2, r->confidence, r);
                        makeAnotherPass = true;
                    } else if (ch1 != r->ch) {
                        ReplacingLog("ValidateLine: rule 0054 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, ch1, toUTF8(r->word->text()).c_str());
                        r->word->updateLetterWithNewCharAndNewRect(r, ch1, rect1);
                        makeAnotherPass = true;
                    }
                }
            } // 'm' and results->imageTests
            
            // "F!" instead of "P."
            // Don't replace if at end of word (could be a legit !) unless spacing is positive on line
            if ((r->ch == 'F') && (r->next != NULL) && (r->next->ch == '!') && (rectLeft(r->next->rect) - rectRight(r->rect) - 1 <= 0) && ((r->next->next != NULL) || (statsWithoutCurrentAndNext->averageSpacing.average > 0))) {
                char newCh1 = 'P';
                char newCh2 = '.';
                ReplacingLog("Validate: rule 0079 replacing [%c%c] with [%c%c] in word [%s]", (unsigned short)r->ch, (unsigned short)r->next->ch, (unsigned short)newCh1, (unsigned short)newCh2, toUTF8(r->word->text()).c_str());
                r->word->updateLetterWithNewCharAndNewRect(r, newCh1, r->rect);
                r->word->updateLetterWithNewCharAndNewRect(r->next, newCh2, r->next->rect);
                r = r->next->next;
                makeAnotherPass = true;
                continue;
            }            
            // "i-" instead of 'r'
            else if (isVerticalLine(r->ch) && (r->next != NULL) && ((r->next->ch == ':') || isDash(r->next->ch)) && (rectBottom(r->next->rect) - rectBottom(r->rect) <= r->rect.size.height * 0.10) && (rectLeft(r->next->rect) - rectRight(r->rect) - 1 <= 0)) {
                float minBottom = MIN(rectBottom(r->rect), rectBottom(r->next->rect));
                float maxTop = MAX(rectTop(r->rect), rectTop(r->next->rect));
                float newHeight = maxTop - minBottom + 1;
                if (lowHeightTest(statsWithoutCurrentAndNext.getPtr(), newHeight, 0, true, results) == 1) {
                    char newCh = 'r';
                    replaceTwo(r, newCh, "rule 0025", minBottom, newHeight);
                    makeAnotherPass = true;
                }
            }
            // "|:" instead of 'c'
            if (!(r->flags2 & FLAGS2_TESTED) && (r->next != NULL)
                && (results->imageTests)
                && ((isVerticalLine(r->ch) && (r->next->ch == ':'))
                    || (((r->ch == 'c') || (r->ch == 'C') || (r->ch == 'r')) && ((r->next->ch == ':') || (r->next->ch == '.') || (r->next->ch == '_'))))
                && (rectSpaceBetweenRects(r->rect, r->next->rect) <= 0)) {
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                r->flags2 |= FLAGS2_TESTED;  
                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
                //SingleLetterTests *stFirst = CreateSingleLetterTests(r->rect, results);
                if ((st != NULL) /*&& (stFirst != NULL)*/) {
                    ConnectedComponentList cpl = st->getConnectedComponents();
                    if (cpl.size() == 2)
                    {
                        char newCh = '\0';
                        bool doit = false;
                        if (combinedRect.size.width > statsWithoutCurrentAndNext->averageWidthNormalLowercase.average * (1 - OCR_ACCEPTABLE_ERROR_LOWHURDLE)) {
                            doit = true;
                            newCh = 'c';
                            if (tallHeightTest(statsWithoutCurrent.getPtr(), r->rect.size.height, '\0', false, 0, false) == 1) 
                                newCh = 'C';
                        } // wide
                        // Possible 't', only if tall
                        else if (isVerticalLine(r->ch) && (tallHeightTest(statsWithoutCurrentAndNext.getPtr(), combinedRect.size.height, 't', false, 1, true) == 1)) {
                            newCh = 't';
                            doit = true;
                            r->confidence += 500; // Force single-letter test
                        }
                        if (doit && (newCh != '\0')) {
                            replaceTwoWithRect(r, newCh, combinedRect, "rule 0026");
                            makeAnotherPass = true;          
                            if ((r->next != NULL) && ((r->next->ch == ':') || (r->next->ch == '.') || (r->next->ch == '_'))) {
                                delete st;
                                continue; // give curremt rule a chance to apply again
                            }
                        } // wide
                    } // cpl OK
                    delete st;
                    //delete stFirst;
                } // st != NULL
            }
            // Replace "u=" with 'LF'
            else if (((r->ch == 'u') || (r->ch == 'U'))
                && (r->next != NULL) && (r->next->ch == '=')
                && (statsWithoutCurrentAndNext->averageHeightUppercase.count > 0)
                && ((spaceBetween = rectLeft(r->next->rect) - rectRight(r->rect) - 1) <= 0)
                && (rectTop(r->rect) - rectTop(r->next->rect) > r->rect.size.height * 0.25)) {
                char newCh1 = 'L';
                char newCh2 = 'F';
                float maxTop = MAX(rectTop(r->rect), rectTop(r->next->rect));
                float minBottom = MIN(rectBottom(r->rect), rectBottom(r->next->rect));
                float newHeight = maxTop - minBottom + 1;
                float totalWidth = rectRight(r->next->rect) - rectLeft(r->rect) + 1;
                float newWidth = totalWidth - statsWithoutCurrentAndNext->averageSpacing.average;
                CGRect newRect1(rectLeft(r->rect),
                               minBottom,
                               newWidth,
                               newHeight);
                CGRect newRect2(rectRight(r->next->rect) - newWidth + 1,
                                minBottom,
                                newWidth,
                                newHeight);                
                ReplacingLog("Validate: rule 0507 replacing [%c%c] with [%c%c] in word [%s]", (unsigned short)r->ch, (unsigned short)r->next->ch, newCh1, newCh2, toUTF8(r->word->text()).c_str());
                r->word->updateLetterWithNewCharAndNewRect(r, newCh1, newRect1);
                r->word->updateLetterWithNewCharAndNewRect(r->next, newCh2, newRect2);
                makeAnotherPass = true;	
            }
            else if (isVerticalLine(r->ch)
                    && (r->next != NULL) && (r->next->ch == '=')
                    && (statsWithoutCurrentAndNext->averageHeightUppercase.count > 0)
                    && ((spaceBetween = rectLeft(r->next->rect) - rectRight(r->rect) - 1) <= 0)
                    && (rectTop(r->rect) - rectTop(r->next->rect) > r->rect.size.height * 0.25)) {
                char newCh = 'F';
                replaceTwo(r, newCh);
                makeAnotherPass = true;
            }
            // '.' entirely within preceding '2'
            else if ((r->ch == '2') && (r->next != NULL) && ((r->next->ch == '.') || isDash(r->next->ch))
                     && (rectRight(r->next->rect) <= rectRight(r->rect))) {
                ReplacingLog("Validate: rule 0094 replacing - eliminating [%c] in word [%s]", (unsigned short)r->next->ch, toUTF8(r->word->text()).c_str());
                r->word->removeLetter(r->next);
                makeAnotherPass = true;
            }
            // Replace "r -> t
            if (isQuote(r->ch) && (r->next != NULL) && (r->next->ch == 'r')
                && ((spaceBetween = rectLeft(r->next->rect) - rectRight(r->rect) - 1) <= 0)) {
                float minBottom = MIN(rectBottom(r->rect), rectBottom(r->next->rect));
                float maxTop = MAX(rectTop(r->rect), rectTop(r->next->rect));
                float newHeight = maxTop - minBottom + 1;
                if (tallHeightTest(statsWithoutCurrentAndNext.getPtr(), newHeight, 't', false, 2, false) == 1) {
                    char newCh = 't';
                    if (((r->next->next != NULL) && isUpper(r->next->next->ch))
                        || (uppercaseFirstLetters && ((r->previous == NULL) || (r->previous->ch == ' ')))) {
                        newCh = 'T';
                    }
                    replaceTwo(r, newCh, "rule 0027", minBottom, newHeight); // = 'T'
                    makeAnotherPass = true;
                }
            }
			// Matching: "/\"
			// Replacing with: 'A'
			else if ((r->ch == '/')
				&& (r->next!= NULL) 
                &&  ((r->next->ch == 'X')
#if !TARGET_IPHONE                
                || (r->next->ch == '\\')
#endif                
                    )) {
				float spacingBetween = rectLeft(r->next->rect) - rectRight(r->rect) - 1;
				float spacingAfter = ((r->next->next == NULL)? 1000.0:rectLeft(r->next->next->rect) - rectRight(r->next->rect) - 1);
                    // Either spacing is zero or negative and / is lower than X (can't happen)
				if (((spacingBetween <= 0) && (r->rect.size.height < r->next->rect.size.height))
                     || ((spacingBetween == 0) && ((r->previous == NULL) || (r->previous->ch != '/')))
                     || ( ((r->next->next != NULL) && (r->next->next->ch == ' ')) 
                     || (((statsWithoutCurrent->averageSpacing.count == 0) || (spacingBetween < statsWithoutCurrent->averageSpacing.average))
					       && ((statsWithoutCurrent->averageWidth.count == 0) || ((spacingAfter - spacingBetween) > statsWithoutCurrent->averageWidth.average * 0.2)) 
                          ))
					) {
                    replaceTwo(r, 'A');
					makeAnotherPass = true;
					r = r->next; continue;
				}
			}
            // "Cl" instead of 'O'
            else if ((r->ch == 'C')
                     && (r->next != NULL) && isVerticalLine(r->next->ch)
                     && (((r->next->next != NULL) && isUpper(r->next->next->ch)) 
                         || ((r->previous != NULL) && isUpper(r->previous->ch))) 
                     && (rectSpaceBetweenRects(r->rect, r->next->rect) <= 0)) 
            {
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results, true, SINGLE_LETTER_VALIDATE_COMP_SIZE);
                if (st != NULL) {
                    // One more test: require a large invert comp
                    ConnectedComponentList invertCpl = st->getInverseConnectedComponents();
                    if (invertCpl.size() == 2) {
                        wchar_t newCh1 = 'O';
                        if (digitsNearby(r)) {
                            newCh1 = '0';
                        }
                        // And one more thing: perhaps we have an apostrophe after the 'O'?
                        ConnectedComponentList cpl = st->getConnectedComponents();
#if DEBUG
                        if (cpl.size() >= 3)
                            DebugLog("validate: testing [C+accented I], aposCC area=%d, letterCC area=%d", cpl[2].area, cpl[1].area);
#endif                        
                        if ((cpl.size() >= 3)
                            && (cpl[2].area > cpl[1].area * 0.03) 
                            && (cpl[2].xmin > combinedRect.size.width * 0.65) 
                            && (cpl[2].ymax < combinedRect.size.height * 0.35)) 
                        {
                            wchar_t newCh2 = '\'';
                            CGRect newRect1(rectLeft(combinedRect) + cpl[1].xmin,
                                            rectBottom(combinedRect) + cpl[1].ymin,
                                            cpl[1].getWidth(), cpl[1].getHeight());
                            CGRect newRect2(rectLeft(combinedRect) + cpl[2].xmin,
                                            rectBottom(combinedRect) + cpl[2].ymin,
                                            cpl[2].getWidth(), cpl[2].getHeight());                                            
                            ReplacingLog("Validate: rule 00506 replacing [%c0x%x] with [%c%c] in word [%s]", (unsigned short)r->ch, (unsigned short)r->next->ch,
                                (unsigned short)newCh1, (unsigned short)newCh2, toUTF8(r->word->text()).c_str());
                            r->word->updateLetterWithNewCharAndNewRect(r, newCh1, newRect1);
                            r->word->updateLetterWithNewCharAndNewRect(r->next, newCh2, newRect2);
                            makeAnotherPass = true;
                        } else {
                            replaceTwoWithRect(r, newCh1, combinedRect);
                            makeAnotherPass = true;		
                        }
                    } 
#if DEBUG
                    else {
                        // Not a single invert comp?
                        DebugLog("validate: testing [C+accented I], got %d invert components", (unsigned short)invertCpl.size());
                        SingleLetterPrint(invertCpl, combinedRect);
                    }
#endif                    
                    delete st;
                }  // st != NULL
            }
			// c+x -> a
			else if ((r->ch == 'c') && (r->next != NULL) && (r->next->ch == 'x')
					&& ((spaceBetween = (rectLeft(r->next->rect) - rectRight(r->rect) - 1)) <= 0)
					&& (statsWithoutCurrentAndNext->averageWidthNormalLowercase.count > 0)
					// Abnormally narrow 'x'
					&& (r->next->rect.size.width < statsWithoutCurrentAndNext->averageWidthNormalLowercase.average * 0.50)) {
                replaceTwo(r, 'a', "rule 0296");
				makeAnotherPass = true;						
			}
			// Wide 'l' following a uppercase letter and followed by '.'
			else if ((r->ch == 'l') && (r->next != NULL)) {
                if ((r->next->ch == '.')
                    && (rectLeft(r->next->rect) - rectRight(r->rect) - 1 <= 0)
                    && (tallHeightTest(statsWithoutCurrent.getPtr(), r->rect.size.height, 'L', false, 0, true) == 1)
                    && ((r->previous == NULL) || isUpper(r->previous->ch)) 
                    && (statsWithoutCurrent->averageWidthUppercase.count > 0)
                    ) 
                {
                    float newWidth;
                    if ((r->next->next != NULL) && (r->next->next->ch == '.')
                        && ((newWidth=rectRight(r->next->next->rect) - rectLeft(r->rect) + 1) > statsWithoutCurrent->averageWidthUppercase.average * 0.80)
                        && (rectLeft(r->next->next->rect) - rectRight(r->next->rect) - 1 <= 0)
                     ) 
                    {
                        char newCh = 'L';
                        float minBottom = MIN(rectBottom(r->rect), rectBottom(r->next->rect));
                        float maxTop = MAX(rectTop(r->rect), rectTop(r->next->rect));
                        float newHeight = maxTop - minBottom + 1;
                        CGRect newRect(rectLeft(r->rect),
                                                    minBottom,
                                                    newWidth,
                                                    newHeight);
                        ReplacingLog("Validate: replacing [%c%c%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)r->next->ch, (unsigned short)r->next->next->ch, newCh, toUTF8(r->word->text()).c_str());
                        r->word->removeLetter(r->next->next);
                        r->word->removeLetter(r->next);
                        r->word->updateLetterWithNewCharAndNewRect(r, newCh, newRect);
                        makeAnotherPass = true;				
                    } else if (rectRight(r->next->rect) - rectLeft(r->rect) + 1 > statsWithoutCurrent->averageWidthUppercase.average * 0.80)
                    {
                        replaceTwo(r, 'L');
                        makeAnotherPass = true;				
                    }
                }
                // Replace l + short T with "tr"
                else if ((r->next->ch == 'T')
                    && (tallHeightTest(statsWithoutCurrentAndNext.getPtr(), r->next->rect.size.height, 'T', false, 0, true) == 0)
                    && (rectLeft(r->next->rect) - rectRight(r->rect) - 1 <= 0)) {
                    // Note: 't' will still get tested by single letter testing, could revert back to 'l'
                    char newCh1 = 't';
                    char newCh2 = 'r';
                    ReplacingLog("Validate: replacing [%c%c] with [%c%c] in word [%s]", (unsigned short)r->ch, (unsigned short)r->next->ch, newCh1, newCh2, toUTF8(r->word->text()).c_str());
                    r->word->updateLetterWithNewCharAndNewRect(r, newCh1, r->rect);
                    r->word->updateLetterWithNewCharAndNewRect(r->next, newCh2, r->next->rect);
                    makeAnotherPass = true;
                }
            }
			// Replacing 'tJ' -> 'b'
			else if ((r->ch == 't') && (r->next !=  NULL) && (r->next->ch == 'J')
				&& (r->next->rect.size.height < r->rect.size.height * 0.80)
				&& ((spaceBetween = rectLeft(r->next->rect) - rectRight(r->rect) - 1) <= 0)) 
			{
                replaceTwo(r, 'b');
				makeAnotherPass = true;				
			}
			// Check for "C-" and replace with 'G'
			else if ((r->ch == 'C')
				&& (tallHeightTest(statsWithoutCurrent.getPtr(), r->rect.size.height, 0, false, 0, true) == 1)
				&& (r->next != NULL) && (r->next->ch == '-')) {
				// Replace with 'G' if zero (or negative spacing) and average spacing > 0
				float spacingBetween = rectLeft(r->next->rect) - rectRight(r->rect) - 1;
				if (((statsWithoutCurrent->averageSpacing.count == 0) || (statsWithoutCurrent->averageSpacing.average > 0))
					  && (spacingBetween <= 0)) {
                    replaceTwo(r, 'G');
					makeAnotherPass = true;
				}
			}
            
            // quote + I => 1
            if (isQuote(r->ch) && (r->next != NULL) && ((r->next->ch == 'I') || (r->next->ch == '|') || (r->next->ch == 'l'))
                && ((spaceBetween = rectLeft(r->next->rect) - rectRight(r->rect) - 1) <= 0)) 
            {
                // Check that the quote is suitably small and placed high (but not too high)
                float minY = rectBottom(r->next->rect) - (r->next->rect.size.height * 0.15);
                // And dip as low as 0.20 of the height of the digit
                float maxY = rectBottom(r->next->rect) + (0.31 * r->next->rect.size.height);
                float maxHeight = r->next->rect.size.height * 0.31;
                if ((rectBottom(r->rect) > minY) && (rectTop(r->rect) < maxY) && (r->rect.size.height <= maxHeight)
                    && ((r->next->next == NULL) || (r->next->next->ch == ' ') || !isQuote(r->next->next->ch) 
                        || (rectLeft(r->next->next->rect) - rectRight(r->next->rect) - 1 > 0))) 
                {
                    if (statsWithoutCurrent->averageHeightDigits.count > 0) {
                        replaceTwo(r, '1', "rule 0449"); // = '1'
                        makeAnotherPass = true;
                    } else {
                        SmartPtr<OCRRect> p = r->next; // Save r->next
                        r->word->removeLetter(r);
                        makeAnotherPass = true;
                        r = p;
                        continue; 
                    }
                }
            }
            
			// Check for "NI" and replace with 'M'
			if ((r->ch == 'N') && (r->next != NULL) && ((r->next->ch == 'I') || (r->next->ch == '|'))
				&& ( (((spaceBetween = rectLeft(r->next->rect) - rectRight(r->rect) - 1) < -1 * r->next->rect.size.width * 0.167)
				       && ((statsWithoutCurrentAndNext->averageSpacing.count == 0) || (statsWithoutCurrentAndNext->averageSpacing.average > 0)))
					|| ((spaceBetween <= 0) && (statsWithoutCurrentAndNext->averageSpacing.average >= 2)
							&& (statsWithoutCurrentAndNext->averageSpacing.average >= r->rect.size.width * 0.09)) )
			    )
			{
                replaceTwo(r, 'M');
				makeAnotherPass = true;
			}

			// Check for "-\" and replace with 'A'
			if ((r->ch == '-') && (r->next != NULL) && (r->next->ch == '\\')
				&& (tallHeightTest(statsWithoutCurrent.getPtr(), r->next->rect.size.height, 0, false, 0, true) == 1)) {
				float spacingBetween = rectLeft(r->next->rect) - rectRight(r->rect) - 1;
				if ((spacingBetween < 0) && (statsWithoutCurrent->averageSpacing.average > spacingBetween)) {
                    replaceTwo(r, 'A');
                    makeAnotherPass = true;
				}
			}
			else if (isVerticalLine(r->ch)) {
				// Check for "\_" or "I_" or "|_" or "|." and replace with 'L'
				if ((tallHeightTest(statsWithoutCurrent.getPtr(), r->rect.size.height, 0, false, 0, true) == 1)
					&& (r->next != NULL) && ((r->next->ch == '_')
									   || ((r->next->ch == '.') && (r->next->rect.size.width > r->next->rect.size.height * 1.5)
											&& (r->next->rect.size.width > r->rect.size.width * 1.25)))) 
				{
					float spacingBetween = rectLeft(r->next->rect) - rectRight(r->rect) - 1;
                    // Replace with 'L' only if start of word or preceeding letter was uppercase
					if ( ((r->previous == NULL) || (r->previous->ch == ' ') || isUpper(r->previous->ch))
                        && (((r->next->next == NULL) || (r->next->next->ch == ' ')) 
							|| ((spacingBetween <= 0)
										&& ((statsWithoutCurrent->averageSpacing.count == 0)
												|| (statsWithoutCurrent->averageSpacing.average > 0))))
                        // Make sure the '_' connects vertically with the bottom of the previous letter
                        && (rectBottom(r->next->rect) - rectTop(r->rect) - 1 <= 0))
                    {
                        replaceTwo(r, 'L');
						makeAnotherPass = true;
					}
				}
				// "1;" instead of 't'
				else if ((r->next != NULL) && (r->next->ch == ';')
					&& ((spaceBetween=(rectLeft(r->next->rect) - rectRight(r->rect) - 1)) <= 0)
					// Replace only if ; lies above previous char (to be tolerant, we allow it to dip below a bit)
					// Assuming upsideDown=true
					&& (rectTop(r->next->rect) - rectTop(r->rect) < r->rect.size.height * 0.15)) 
				{
					// TODO could be other letters like 'f'
                    replaceTwo(r, 't');
					makeAnotherPass = true;
				}
				// |} instead of R
				else if ((r->next != NULL) && (r->next->ch == '}')
				&& ((spaceBetween=(rectLeft(r->next->rect) - rectRight(r->rect) - 1)) <= 0)
				&& ((statsWithoutCurrentAndNext->averageSpacing.count == 0) || (spaceBetween < statsWithoutCurrentAndNext->averageSpacing.average))
				&& (tallHeightTest(statsWithoutCurrentAndNextTwo.getPtr(), r->rect.size.height, 'R', false, 0, true) == 1)
				&& (tallHeightTest(statsWithoutCurrentAndNextTwo.getPtr(), r->next->rect.size.height, 'R', false, 0, true) == 1)
				) {
                    replaceTwo(r, 'R');
					makeAnotherPass = true;
				}
					
			}
            
//#if DEBUG
//            if (isVerticalLine(r->ch) && (r->next != NULL) && isQuote(r->next->ch)) {
//                DebugLog("");
//            }
//#endif
			
			// Map diminutive '|' or 'l' etc followed by glued ' etc to 'r'
			if (isVerticalLine(r->ch) && (r->next != NULL) && isQuote(r->next->ch)
				// Low height
				&& (tallHeightTest(statsWithoutCurrentAndNext.getPtr(), r->rect.size.height, '\0', 0, 3, true) == 0)
				// quote near the top part
				&& (gapAboveBaselineOfOtherRect(r->next, r) > r->rect.size.height * 0.50)
				// Glued
				&& ((spaceBetween = rectLeft(r->next->rect) - rectRight(r->rect) -1) <= 0)
				// Other letters not glued
				&& ((statsWithoutCurrentAndNext->averageSpacing.count == 0) || (statsWithoutCurrentAndNext->averageSpacing.count > spaceBetween))
				)
			{
                // First test if it's a 'i'
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                char newCh = SingleLetterTestAsi(r, combinedRect, statsWithoutCurrentAndNext, results);
                if (newCh == '\0')
                    newCh = 'r';
                
                replaceTwo(r, newCh, "rule 0021");
				makeAnotherPass = true;			
			}
            
            // Now that we tested '|' to be low, try "|'" instead of 'F' or 'P'
			if (results->imageTests && isVerticalLine(r->ch) && (r->next != NULL) && ((r->next->ch == '=') || isQuote(r->next->ch))
				// Tall
				&& (tallHeightTest(statsWithoutCurrentAndNext.getPtr(), r->rect.size.height, '\0', 0, 2, true) == 1)
                // Glued
                && ((spaceBetween = rectLeft(r->next->rect) - rectRight(r->rect) -1) <= 0)
				// quote near the top part
                // skipping gap test if spacing negative
				&& ((spaceBetween < 0) || (gapAboveBaselineOfOtherRect(r->next, r) > r->rect.size.height * 0.50))
				// Other letters not glued
				&& ((statsWithoutCurrentAndNext->averageSpacing.count == 0) || (statsWithoutCurrentAndNext->averageSpacing.count > spaceBetween))
				)
			{
                // Create combined rect
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results, false, SINGLE_LETTER_VALIDATE_COMP_SIZE | SINGLE_LETTER_VALIDATE_SINGLE_COMP);
                if (st != NULL)
                {
                    wchar_t newCh = SingleLetterTestAsFP(r, combinedRect, results, ((r->next == NULL)? false:true), &st);
                    if ((newCh != '\0') && (newCh != r->ch))
                    replaceTwo(r, newCh);
                    makeAnotherPass = true;
                    delete st;
                }
			}
            
            // Map "Ii" 'G'
			if (results->imageTests && isVerticalLine(r->ch) && (r->next != NULL) && (r->next->ch == 'i')
				// Tall
				&& (tallHeightTest(statsWithoutCurrentAndNext.getPtr(), r->rect.size.height, '\0', 0, 2, true) == 1)
                // Glued
                && ((spaceBetween = rectLeft(r->next->rect) - rectRight(r->rect) -1) <= 0)
				// Other letters not glued
				&& ((statsWithoutCurrentAndNext->averageSpacing.count == 0) || (statsWithoutCurrentAndNext->averageSpacing.count > spaceBetween))
				)
			{
                // Create combined rect
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results, false, SINGLE_LETTER_VALIDATE_COMP_SIZE | SINGLE_LETTER_VALIDATE_SINGLE_COMP);
                if (st != NULL)
                {
                    wchar_t newCh = SingleLetterTestAsGC(r, combinedRect, results, ((r->next == NULL)? false:true), &st);
                    if ((newCh != '\0') && (newCh != r->ch))
                        replaceTwo(r, newCh);
                    makeAnotherPass = true;
                    delete st;
                }
			}

			if (r->ch == '/') {
				if (r->next != NULL) {
					// testing: "/v\"
					// Replacing with: "M"
					if ((toLower(r->next->ch) == 'v') && (r->next->next != NULL) && (r->next->next->ch == '\\')) {
						char newCh = 'M';
						if (tallHeightTest(statsWithoutCurrent.getPtr(), r->rect.size.height, 'm', false, 2, false) == 0) {
							newCh = 'm';
						}
						float newWidth = rectRight(r->next->next->rect) - rectLeft(r->rect);
						float minY = MIN(rectBottom(r->rect),rectBottom(r->next->rect));
						minY = MIN(minY, rectBottom(r->next->next->rect));
						float maxY = MAX(rectTop(r->rect),rectTop(r->next->rect));
						maxY = MIN(maxY, rectTop(r->next->next->rect));
						float newHeight = maxY - minY + 1;
						CGRect newRect(rectLeft(r->rect), minY, newWidth, newHeight);
						ReplacingLog("Validate: replacing [%c%c%c] with [%c]", (unsigned short)r->ch, (unsigned short)r->next->ch, (unsigned short)r->next->next->ch, newCh);
						r->word->removeLetter(r->next->next);
						r->word->removeLetter(r->next);
						r->word->updateLetterWithNewCharAndNewRect(r, newCh, newRect);
						makeAnotherPass = true;
						r = r->next;
						continue;
					}
					// map "/1" to '4'
					else if ((r->next->ch == '1') 
						&& ((rectLeft(r->next->rect) - rectRight(r->rect) - 1) <= 0)
						&& (gapAboveBaselineOfOtherRect(r, r->next) > r->next->rect.size.height * 0.18))
					{
                        replaceTwo(r, '4');
						makeAnotherPass = true;
						r = r->next; continue;
					}
					else if ((lowHeightTest(statsWithoutCurrent.getPtr(), r->rect.size.height,1,false, results) == 1) && (r->next != NULL)) {
						if ((r->next->ch == '\'') || (r->next->ch == '`')) {
							float maxTop = MAX(rectTop(r->rect), rectTop(r->next->rect));
							float minBottom = MIN(rectBottom(r->rect), rectBottom(r->next->rect));
							float newHeight = maxTop - minBottom + 1;
							// Replacing with: 'r' or 'i'
							// Appostrophe above '/'? It's a 'i'
							char newCh;
							if (newHeight > r->rect.size.height * OCR_TALL_TO_LOWERCASE_RATIO) {
								newCh = 'i';
							} else {
								newCh = 'r';
							}
                            replaceTwo(r, newCh);
							makeAnotherPass = true;
						}
					}
				}
				// Slanted line
				// Don't replace if surrounded by spaces (e.g. "foo / bar"
				else if (line->isItalic()
					 // Required non-blank before or after
					 && (((r->previous == NULL) || (r->previous->ch != ' ')) || ((r->next == NULL) || (r->next->ch != ' ')))
					 // Check that it's not super wide compared to letters like 'l' and 'i'
					 && ((statsWithoutCurrent->averageWidthSuperNarrow1.count == 0) || (r->rect.size.width < statsWithoutCurrent->averageWidthSuperNarrow1.average * 1.5))
					 // Check that it's not super tall compared to normal lowercase
					 && ((statsWithoutCurrent->averageHeightNormalLowercase.count == 0) || (r->rect.size.height < statsWithoutCurrent->averageHeightNormalLowercase.average * 1.5))
					 && ((statsWithoutCurrent->averageHeightUppercase.count == 0) || (r->rect.size.height < statsWithoutCurrent->averageHeightUppercase.average * 1.19))
					 ) {
					// w/digit => replace with '1'
						if ((((r->previous != NULL) && isDigit(r->previous->ch))
						|| ((r->next != NULL) && isDigit(r->next->ch)))
					&& isCloseVal1ToVal2(line->averageHeightDigits.average, r->rect.size.height, 0.08)
					) {
						char newCh = '1';
						ReplacingLog("Validate: rule 0509 replacing [%c] with [%c]", (unsigned short)r->ch, newCh);
						r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
						r = r->next;
						continue;  // There are combos with '1' but here we are pretty sure it's a real digit so move on to the next char
					} else if ((((r->previous != NULL) && islower(r->previous->ch))
							   || ((r->next != NULL) && islower(r->next->ch)))
						&& !isCloseVal1ToVal2(line->averageHeightNormalLowercase.average, r->rect.size.height, 0.10)
						) {
							char newCh = 'l';
							ReplacingLog("Validate: rule 0510 replacing [%c] with [%c]", (unsigned short)r->ch, newCh);
							r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
							// Allow other combos
					}
				}
			} // ch == '/'

			if ((r->ch == '.')
				&& (r->next != NULL) && ((r->next->ch == 'C') || (r->next->ch == 'c'))
				&& (r->next->next != NULL) && ((r->next->next->ch == 'O') || (r->next->next->ch == 'o') || (r->next->next->ch == '0'))) {

				// ".COl'T\" -> .com
				if ((r->next->next->next != NULL) && ((r->next->next->next->ch == 'l') || (r->next->next->next->ch == 'i') || (r->next->next->next->ch == '/') || (r->next->next->next->ch == '\\') || (r->next->next->next->ch == '1'))
					&& (r->next->next->next->next != NULL) && ((r->next->next->next->next->ch == '\'') || (r->next->next->next->next->ch == '`'))
					&& (r->next->next->next->next->next != NULL) && (r->next->next->next->next->next->ch == 'T')
					&& (r->next->next->next->next->next->next != NULL) && ((r->next->next->next->next->next->next->ch == 'l') || (r->next->next->next->next->next->next->ch == 'i') || (r->next->next->next->next->next->next->ch == '/') || (r->next->next->next->next->next->next->ch == '\\') || (r->next->next->next->next->next->next->ch == '1'))
					)
				{
					char newCh = 'm';
					float newWidth = rectRight(r->next->next->next->next->next->next->rect) - rectLeft(r->next->next->next->rect);
					float newHeight = r->next->next->next->next->next->rect.size.height;
					float newBottom = rectBottom(r->next->next->next->next->next->rect);
					CGRect newRect(rectLeft(r->next->next->next->rect),
												newBottom,
												newWidth,
												newHeight);
					ReplacingLog("Validate: replacing [%c%c%c%c] with [%c] in word [%s]", (unsigned short)r->next->next->next->ch, (unsigned short)r->next->next->next->next->ch, (unsigned short)r->next->next->next->next->next->ch, (unsigned short)r->next->next->next->next->next->next->ch, newCh, toUTF8(r->word->text()).c_str());
					r->word->removeLetter(r->next->next->next->next->next->next);
					r->word->removeLetter(r->next->next->next->next->next);
					r->word->removeLetter(r->next->next->next->next);
					r->word->updateLetterWithNewCharAndNewRect(r->next->next->next, newCh, newRect);
					r = r->next->next->next->next;
					continue;	// We don't expect other substitutions
				} 
				// Two characters following & glued together & wide, then  followed by a non-letter or digit
				else if ((r->next->next->next != NULL) && (r->next->next->next->ch != ' ') && (r->next->next->next->next != NULL) && (r->next->next->next->next->ch != ' '))
				{
					float spaceBetween = rectLeft(r->next->next->next->next->rect) - rectRight(r->next->next->next->rect) - 1;
					float newWidth = rectRight(r->next->next->next->next->rect) - rectLeft(r->next->next->next->rect) + 1;
					if ((spaceBetween <= 0) && (statsWithoutCurrentAndNextTwo->averageSpacing.count > 2) 
						&& (statsWithoutCurrentAndNextTwo->averageSpacing.average > spaceBetween)
						&& (newWidth > statsWithoutCurrentAndNextTwo->averageWidth.average)
						&& ((r->next->next->next->next->next == NULL) || !isLetterOrDigit(r->next->next->next->next->next->ch))) 
					{
                        // Using height of "co" because next two glued may be messed up
						float maxTop = MAX(rectTop(r->next->rect), rectTop(r->next->next->rect));
						float minBottom = MIN(rectBottom(r->next->rect), rectBottom(r->next->next->rect));
						float newHeight = maxTop - minBottom + 1;
                        if ((r->next->next->next->ch == 'm') && ((statsWithoutCurrentAndNext->averageWidthNormalLowercase.count == 0) || (r->next->next->next->rect.size.width > statsWithoutCurrentAndNext->averageWidthNormalLowercase.average))) {
                            // Already set to 'm', and wide enough, just eliminate the next char
                            ReplacingLog("Validate: rule 0028 replacing eliminating [%c] in word [%s]", (unsigned short)r->next->next->next->next->ch,toUTF8(r->word->text()).c_str());
                            r->word->removeLetter(r->next->next->next->next);
                            r->confidence = r->next->confidence = r->next->next->confidence = r->next->next->next->confidence = 0; // Protect from inspections
                            r = r->next->next->next->next; // Skip entire ".com" and go to next letter
                            continue;	// We don't expect other substitutions
                        } else {
                            replaceTwo(r->next->next->next, 'm', "rule 0028", minBottom, newHeight);
                            r->confidence = r->next->confidence = r->next->next->confidence = r->next->next->next->confidence = 0; // Protect from inspections
                            r = r->next->next->next->next; // Skip entire ".com" and go to next letter
                            continue;	// We don't expect other substitutions
                        }
					}
				}
			}
//#if DEBUG
//			if ((r->ch =='1') && (r->next != NULL) && (r->next->ch== ')')) {
//				DebugLog("Found it");
//			}
//#endif

			// Matching: ">("
			// Replacing with: 'x'
			if (((r->ch == '>') || (r->ch == ')')) && (r->next != NULL) && ((r->next->ch == '(') || (r->next->ch == '<'))) {
				float spaceBetween = rectLeft(r->next->rect) - rectRight(r->rect) - 1;
				if ((spaceBetween <= 0) && (statsWithoutCurrent->averageSpacing.average > spaceBetween)) {
                    replaceTwo(r, 'x');
					makeAnotherPass = true;
					r = r->next;
					continue;
				}
			}
            
            // "l1" instead of 'b'
            if (isVerticalLine(r->ch) && (r->next != NULL) && ((r->next->ch == '1') || (r->next->ch == ')') || (r->next->ch == '>'))
                // Small 2nd part less than 70% of height of bar
                && (r->next->rect.size.height < r->rect.size.height * 0.70)
                && (rectSpaceBetweenRects(r->rect, r->next->rect) <= 0)
                && results->imageTests && !(r->flags6 & FLAGS6_TESTED_AS_b))
            {
                wchar_t newCh = '\0';
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                if (SingleLetterTestAsb(r, combinedRect, results, newCh) && (newCh != '\0') && (newCh != r->ch))
                {
                    ReplacingLog("ValidateLine: rule 0001 replacing [%c%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)r->next->ch, (unsigned short)newCh, toUTF8(r->word->text()).c_str());
                    replaceTwoWithRect(r, newCh, combinedRect);
                    makeAnotherPass = true;                
                }
            }
            
            // Quote glued to 'c' -> 't'
            // Combined letter would be 23 pixels tall versus normal lowercase 16 => 43% taller
            if (isQuote(r->ch) && (r->next != NULL) && (r->next->ch == 'c') && (rectSpaceBetweenRects(r->rect, r->next->rect) <= 0) && (results->imageTests)
                && !(r->flags4 & FLAGS4_TESTED_AS_t))
            {
                r->flags4 |= FLAGS4_TESTED_AS_t;
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
            
                // Quote should add stuff above 'c'
                if (rectBottom(combinedRect) < rectBottom(r->next->rect)
                    && (statsWithoutCurrentAndNext->averageHeightNormalLowercase.count >= 2) && (combinedRect.size.height > statsWithoutCurrentAndNext->averageHeightNormalLowercase.average * 0.25)) {
                    // Test that it's a single component
                    // Now test if our single-letter code also thinks it's a 't'
                    wchar_t tmpCh = r->ch; // Remember original code
                    r->ch = 't';
                    wchar_t replacementChar = OCRUtilsSuggestLetterReplacement(combinedRect, r->ch, 0, results, false, NULL);
                    if (replacementChar == 't') {
                        ReplacingLog("ValidateLine: rule 0002 replacing [%c%c] with [%c] in word [%s]", (unsigned short)tmpCh, (unsigned short)r->next->ch, (unsigned short)replacementChar, toUTF8(r->word->text()).c_str());
                        replaceTwoWithRect(r, replacementChar, combinedRect);
                        makeAnotherPass = true;  
                    } else {
                        r->ch = tmpCh;
                    }
                }
            }
			
            // Check for '|)' or 'I)' and replace with 'D' or 'p' or 'P'
			// Replace only if we didn't have an opening '(' in current word. Note: could check entire column?
			if ((isVerticalLine(r->ch) || (r->ch == 'f') || (r->ch == 'r')) && (tallHeightTest(statsWithoutCurrent.getPtr(), r->rect.size.height, '\0', false, 0, true) == 1)
				&& (r->next != NULL) && ((spaceBetween = (rectLeft(r->next->rect) - rectRight(r->rect) - 1)) <= 0)) 
			{
				if (((r->next->ch == ')') || (r->next->ch == '>'))
					&&!OCRLine::isPresentInLineBeforeRect('(', r)) 
				{
					float gap1 = gapAboveBaselineOfOtherRect(r->next, r);
					char newCh;
					if (gap1 < r->rect.size.height * 0.06) {
                        // [1 (0x31)] at [333,422 - 344,442] [w=12,h=21]
                        // [) (0x29)] at [341,422 - 352,441] [w=12,h=20]
                        float gapNextFromTopOfCurrent = rectBottom(r->next->rect) - rectBottom(r->rect);
                        // If next is as high or almost as high - must be a 'D'
                        if (gapNextFromTopOfCurrent < r->rect.size.height * 0.10) {
                            newCh = 'D';
                        } else {
                            if ((r->ch == 'f') && (spaceBetween < 0)) {
                                newCh = '6';
                            } else {
                                newCh = 'b';
                            }
                        }
					} else {
						newCh = 'P';				// Is is a 'P' or 'p'?
						float gapAboveBaseline = rectTop(r->rect) - rectTop(r->next->rect);
						if ((r->rect.size.height > r->next->rect.size.height*1.2) && (gapAboveBaseline > r->rect.size.height*0.25)) {
							// P or p
							float gapBelowLine = 0;
							if ((r->previous != NULL) && (isLetter(r->previous->ch) || isDigit(r->previous->ch))) {
								gapBelowLine = rectTop(r->previous->rect) - rectTop(r->rect);
							}
							if (gapBelowLine > r->rect.size.height * 0.25) {
								newCh = 'p';
							} else {
								newCh = 'P';
							}
						}
					}
                    replaceTwo(r, newCh);
					//r->word->needToUpdate = true;
					//ReplacingLog("Validate: result after replacing [%s]", toUTF8(r->word->text()).c_str());
					// Special hack: it's almost certainly a 'p' or 'P' here - make it known by influencing stats of current word
					for (int j=0; j<10; j++) {
						line->updateStatsAddOrRemoveLetterAddingSpacingOnly(r, true, false);
					}
					//r->word->needToUpdate = true;
					//ReplacingLog("Validate: result after special hack [%s]", toUTF8(r->word->text()).c_str());
					makeAnotherPass = true;
					r = r->next;
					continue;
				}
				// [I (0x49)] at [119,65 - 128,92] [w=10,h=28]
				// [0x2019 - UTF8=e2 80 99] at [127,79 - 139,92] [w=13,h=14]				 
				// Generic case of some character above 
				else if ((statsWithoutCurrentAndNext->averageSpacing.average > spaceBetween)
						&& (r->next->rect.size.width > r->rect.size.width) 
						&& (gapAboveBaselineOfOtherRect(r->next, r) > r->rect.size.height * 0.40)
                        && (!results->imageTests || !(r->flags2 & FLAGS2_TESTED))
                        ) 
				{
                    bool doit = true;
                    // Check if we have an inverted component on top
                    if (results->imageTests) {
                        r->flags2 |= FLAGS2_TESTED;
                        float minY = MIN(rectBottom(r->rect), rectBottom(r->next->rect));
                        float maxY = MAX(rectTop(r->rect), rectTop(r->next->rect));
                        CGRect combinedRect(rectLeft(r->rect), minY, rectRight(r->next->rect) - rectLeft(r->rect) + 1, maxY - minY + 1);
                        SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results); 
                        if (st != NULL) {
                            ConnectedComponentList invertedCpl = st->getInverseConnectedComponents();
                            if (invertedCpl.size() < 2) {
                                doit = false;
                            } else {
                                ConnectedComponent hole = invertedCpl[1];
                                DebugLog("Found hole: [%d,%d] - [%d,%d]", hole.xmin, hole.ymin, hole.xmax, hole.ymax);
                            }
                            delete st;
                        }
                    } // single letter
                    if (doit) 
                    {
                        char newCh = 'P';
                        // Is is a 'P' or 'p'?
                        float gapAboveBaseline = rectTop(r->rect) - rectTop(r->next->rect);
                        if ((r->rect.size.height > r->next->rect.size.height*1.2) && (gapAboveBaseline > r->rect.size.height*0.25)) {
                            // P or p
                            if (r->previous != NULL) {
                                float gapBelowLine = rectTop(r->previous->rect) - rectTop(r->rect);
                                if ((gapBelowLine > r->rect.size.height * 0.25) 
                                    || (isTallBelow(r->previous->ch) && (gapBelowLine > -0.10*r->previous->rect.size.height)) ) {
                                        newCh = 'p';
                                } 
                            }
                        }
                        replaceTwo(r, newCh); // = 'p'
                        makeAnotherPass = true;
                        r = r->next;
                        continue;				
                    }
				}
			}
			// Replace '}' with 'j'
			else if ((r->ch == '}') 
				&& (tallHeightTest(statsWithoutCurrent.getPtr(), r->rect.size.height, '\0', false, 0, false) == 1)
				&& !OCRLine::isPresentInLineBeforeRect('{', r)) {
				char newCh;
				if (indexCloserValToAv1OrAv2(r->rect.size.width, line->averageWidthUppercase, line->averageWidthNormalChars) == 1) {
					newCh = 'J';
				} else {
					newCh = 'j';
				}
				ReplacingLog("ValidateLine: rule 0130 replacing [%c] with [%c]", (unsigned short)r->ch, newCh);
				r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
				r = r->next;
				continue;
			}
            
//#if DEBUG
//			if ((r->ch =='1') && (r->next != NULL) && (r->next->ch =='1')) {
//				DebugLog("Found in [%s]", toUTF8(r->word->text()).c_str());
//			}
//#endif            
			
			// Testing: "11" or "l\"
			// Replacing with: 'h'
			if (isVerticalLine(r->ch)
				&& (r->next != NULL) && isVerticalLine(r->next->ch)
				&& (tallHeightTest(statsWithoutCurrent.getPtr(), r->rect.size.height,'h', false, 1, false) == 1)
				&& (r->next->rect.size.height < r->rect.size.height * 0.85) 
                // Not only lower but starts below
                && (rectBottom(r->next->rect) - rectBottom(r->rect) > r->rect.size.height * 0.15)
				&& ( ((spaceBetween = rectLeft(r->next->rect) - rectRight(r->rect) - 1) <= 0)
				     || ((r->next->ch == '\\') && (spaceBetween <= (rectRight(r->next->rect) - rectLeft(r->rect) + 1) * 0.25)) )
				&& ((statsWithoutCurrentAndNext->averageSpacing.count == 0) || (statsWithoutCurrentAndNext->averageSpacing.count > spaceBetween))
                // If single-letter, test only if not already done
                && (!results->imageTests || !(r->flags4 & FLAGS4_TESTED_AS_h))
				) 
            {
                bool doit = true;
                float minY = MIN(rectBottom(r->rect), rectBottom(r->next->rect)); 
                float maxY = MAX(rectTop(r->rect), rectTop(r->next->rect));
                CGRect combinedRect (rectLeft(r->rect), minY, rectRight(r->next->rect) - rectLeft(r->rect) + 1, maxY - minY + 1);
                if (results->imageTests) {
                    r->flags4 |= FLAGS4_TESTED_AS_h;
                    SingleLetterTests *st = CreateSingleLetterTests(combinedRect,results);
                    if (st != NULL) {
                        ConnectedComponentList cpl = st->getConnectedComponents();
                        // Big 2nd component
                        if ((cpl.size() > 2) && (cpl[2].area > cpl[1].area * 0.10)) 
                        {
                            doit = false;
                        }
                        if (doit && (cpl.size() > 1)) {
                            // Now demand bounded opening at bottom, to make sure it's not V
                            ConnectedComponent mainComp = cpl[1];
                            OpeningsTestResults resBottom;
                            bool success = st->getOpenings(resBottom, SingleLetterTests::Bottom, 
                                0.00,      // Start of range to search (top/left)
                                1.00,      // End of range to search (bottom/right)
                                SingleLetterTests::Bound,   // Require start (top/left) bound
                                SingleLetterTests::Bound  // Require end (bottom/right) bound
                                );
                            if (!success || (resBottom.maxDepth < mainComp.getHeight() * 0.20)) {
                                doit = false;
                            } else {
                                // Final test: check single segment on top (bar of the 'h'
                                SegmentList sl = st->getHorizontalSegments((mainComp.ymin + mainComp.getHeight() * 0.10)/combinedRect.size.height, 0.01);
                                if (sl.size() != 1) {
                                    doit = false;
                                } else {
                                    // Update rect
                                    combinedRect.origin.x += mainComp.xmin;
                                    combinedRect.origin.y += mainComp.ymin;
                                    combinedRect.size.width += mainComp.getWidth();
                                    combinedRect.size.height += mainComp.getHeight();
                                }
                            }
                        }
                    } // st != NULL
                } // single letter
                if (doit) {
                    replaceTwoWithRect(r, 'h', combinedRect); // = 'h'
                    makeAnotherPass = true;
                }
			}

			if (isCLookalike(r->ch) && (r->next != NULL))
			{
				// Testing: "c:" or "<;"
				// Replacing with: 'c'
				float c_column_space;
				if (((r->next->ch == ':') || (r->next->ch == ';'))
					&& ((c_column_space = rectLeft(r->next->rect)-rectRight(r->rect) - 1) <= 0)
					&& (statsWithoutCurrent->averageSpacing.average > c_column_space) ) 
				{
					ReplacingLog("Validate: replacing [%c%c] with [%c] in word [%s]",
						(unsigned short)r->ch, (unsigned short)r->next->ch, (unsigned short)r->ch, toUTF8(r->word->text()).c_str());
					CGRect newRect(rectLeft(r->rect),
									rectBottom(r->rect),
									rectRight(r->next->rect)-rectLeft(r->rect)+1,
									r->rect.size.height);
					r->word->removeLetter(r->next);
					r->word->updateLetterWithNewCharAndNewRect(r, r->ch, newRect);
					makeAnotherPass = true;
				}
			}

			// Testing: "d\"
			// Replacing with: 'ch'
			if ((r->ch == 'd')
				&& (r->next != NULL) && isVerticalLine(r->next->ch)
				&& (tallHeightTest(statsWithoutCurrent.getPtr(), r->rect.size.height,'h', false, 1, false) == 1)
					&& (lowHeightTest(statsWithoutCurrent.getPtr(), r->next->rect.size.height,1,false, results) == 1)) {
				float spaceBetween = rectLeft(r->next->rect) - rectRight(r->rect) - 1;
				if ((spaceBetween <= 0) 
				    && (statsWithoutCurrentAndNext->averageSpacing.count > 1) && (statsWithoutCurrentAndNext->averageSpacing.average > 0)) { 
					char newCh1 = 'c';
					char newCh2 = 'h';
					float maxTop = MAX(rectTop(r->rect), rectTop(r->next->rect));
					float minBottom = MIN(rectBottom(r->rect), rectBottom(r->next->rect));
					float newWidthTotal = rectRight(r->next->rect) - rectLeft(r->rect) + 1;
					float newWidth;
					if (statsWithoutCurrent->averageSpacing.count > 0) {
						newWidth = (newWidthTotal - statsWithoutCurrent->averageSpacing.average)/2;
						if (newWidth <= 0) {
							newWidth = (newWidthTotal - 2)/2;
						}
					} else {
						newWidth = (newWidthTotal - 2)/2;
					}
					float newHeight2 = maxTop - minBottom + 1;
					float newHeight1 = r->next->rect.size.height;
					CGRect newRect1(rectLeft(r->rect), maxTop-newHeight1+1, newWidth, newHeight1);
					CGRect newRect2(rectRight(r->next->rect)-newWidth+1, maxTop-newHeight2+1, newWidth,newHeight2);
					ReplacingLog("Validate: replacing [%c%c] with [%c%c] in word [%s]",
								 (unsigned short)r->ch, (unsigned short)r->next->ch, newCh1, newCh2, toUTF8(r->word->text()).c_str());
					r->word->updateLetterWithNewCharAndNewRect(r, newCh1, newRect1);
					r->confidence = 0;
					r->word->updateLetterWithNewCharAndNewRect(r->next, newCh2, newRect2);
					r->next->confidence = 0;
					makeAnotherPass = true;
				}
			}
            
//#if DEBUG
//			if (isQuote(r->ch) && (r->next != NULL) && (r->next->ch =='7') && (r->previous != NULL) && (r->previous->ch == '9')) {
//                CGRect combinedRect = CreateCombinedRect(r->previous->rect, r->next->rect);
//                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results, false);
//                if (st != NULL) {
//                    delete st;
//                }
//                st = CreateSingleLetterTests(r->rect, results, false);
//                if (st != NULL) {
//                    delete st;
//                }
//				DebugLog("Found in [%s]", toUTF8(r->word->text()).c_str());
//                DebugLog("");
//			}
//#endif
            
            // Eliminate glued quote in every case where it is literally touching the letter before or after. Do that by analyzing connected components in combined rect and detecting that the quote doesn't show up as its own CC
            //2015-10-26 10:13:28.243 Windfall[2780:138907] #614: 1 quality: 86 [515,444 - 525,463] w=10,h=20]
            //2015-10-26 10:13:28.243 Windfall[2780:138907] #615: . quality: 98 [532,459 - 535,462] w=3,h=4]
            //2015-10-26 10:13:28.243 Windfall[2780:138907] #616: 9 quality: 75 [538,445 - 549,462] w=11,h=18]
            //2015-10-26 10:13:28.243 Windfall[2780:138907] #617: ' quality: 74 [548,446 - 554,448] w=6,h=3]
            //2015-10-26 10:13:28.243 Windfall[2780:138907] #618: 7 quality: 82 [553,446 - 559,463] w=6,h=18]

            //  -----------------------
            //0|                       |
            //1|   1111             1  |
            //2|  111111   11111111111 |
            //3|  111  11  11111111111 |
            //4| 111    11    11   111 |
            //5|  11     1         111 |
            //6|  11     11        11  |
            //7|  11     11       111  |
            //8|  111     1       111  |
            //9|   111   111      111  |
            //a|   111111111      11   |
            //b|    11111111      11   |
            //c|          11     111   |
            //d|          11     111   |
            //e|   11     11     111   |
            //f|   111   111     111   |
            //#|    11111111     11    |
            //#|     111111      11    |
            //#|       11        11    |
            //#|                 11    |
            //#|                       |
            //  -----------------------
            //  0123456789abcdef#######
            //  01234567
            //  --------
            //0|        |
            //1| 111111 |
            //2| 111111 |
            //3|    11  |
            //4|        |
            //  --------
            
            if (isQuote(r->ch) && (results->imageTests)) {
                bool gluedToPrevious = false, gluedToNext = false;
                if ((r->previous != NULL) && (r->previous->ch != ' ') && (rectSpaceBetweenRects(r->previous->rect, r->rect) <= 0)) {
                    gluedToPrevious = true;
                }
                if ((r->next != NULL) && (r->next->ch != ' ') && (rectSpaceBetweenRects(r->rect, r->next->rect) <= 0)) {
                    gluedToNext = true;
                }
                // First we need to identify the quote element in the rect, just in case some elements of letter before or after got included
                CGRect quoteRect;
                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                if (st != NULL) {
                    ConnectedComponentList cl = st->getConnectedComponents();
                    if (cl.size() >= 2) {
                        if (cl.size() == 2) {
                            ConnectedComponent quoteCC = cl[1];
                            quoteRect.origin.x = rectLeft(r->rect) + quoteCC.xmin;
                            quoteRect.origin.y = rectBottom(r->rect) + quoteCC.ymin;
                            quoteRect.size.width = quoteCC.getWidth();
                            quoteRect.size.height = quoteCC.getHeight();
                        } else {
                            // Pick the CC that is top-most, left-most and/or largest
                            ConnectedComponent bestCC;
                            int bestYMin = 10000;
                            int bestXMin = 10000;
                            int bestArea = 0;
                            for (int k=1; k<cl.size(); k++) {
                                ConnectedComponent currentCC = cl[k];
                                if ((currentCC.area > bestArea * 0.75)
                                  && ((currentCC.ymin < bestYMin)
                                        || ((currentCC.xmin < bestXMin) && (currentCC.ymin < r->rect.size.height * 0.20)))) {
                                    bestCC = currentCC;
                                    bestArea = bestCC.area;
                                    bestYMin = bestCC.ymin;
                                    bestXMin = bestCC.xmin;
                                }
                            }
                            quoteRect.origin.x = rectLeft(r->rect) + bestCC.xmin;
                            quoteRect.origin.y = rectBottom(r->rect) + bestCC.ymin;
                            quoteRect.size.width = bestCC.getWidth();
                            quoteRect.size.height = bestCC.getHeight();
                        }
                    }
                    
                    // Glued to previous?
                    if (gluedToPrevious) {
                        CGRect combinedRect = CreateCombinedRect(r->previous->rect, r->rect);
                        if (isGluedRectInCombinedRect(combinedRect, quoteRect, results)) {
                            // Eliminate this glued quote!
                            OCRRectPtr p = r->next;
                            replaceTwo(r->previous, r->previous->ch, "rule 0460");
                            delete st;
                            r = p; continue;
                        }
                    }
                    // Glued to previous?
                    if (gluedToNext) {
                        CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                        if (isGluedRectInCombinedRect(combinedRect, quoteRect, results)) {
                            // Eliminate this glued quote!
                            OCRRectPtr p = r;
                            replaceTwo(r, r->next->ch, "rule 0460");
                            delete st;
                            r = p; continue;
                        }
                    }
                    delete st;
                } // st != NULL
            }
            
            // Eliminate glued quote
            // |' instead of 'r'
            // 2015-09-30 sometimes there is a (tiny) space, accept as well. "'1" instead of '4':
            // $ [493,180 w=11,h=19]
            // 1 [507,181 w=8,h=17]
            // ' [517,185 w=5,h=8] (space = 1 => less than 1/14 height = 0.07 * height
            // 1 [523,181 w=4,h=16]
            if (isQuote(r->ch))
            {
                float referenceHeight = statsWithoutCurrentAndNext->averageHeightDigits.average;
                if (statsWithoutCurrentAndNext->averageHeightUppercase.count > statsWithoutCurrentAndNext->averageHeightDigits.count)
                    referenceHeight = statsWithoutCurrentAndNext->averageHeightUppercase.average;
                float referenceWidth = statsWithoutCurrentAndNext->averageWidthDigits.average;
                if (referenceWidth == 0)
                    referenceWidth = statsWithoutCurrentAndNext->averageWidthUppercase.average;
                if (referenceWidth == 0)
                    referenceWidth = results->globalStats.averageWidthDigits.average;
                bool gluedtoPrevious = ((r->previous != NULL) && (rectSpaceBetweenRects(r->previous->rect, r->rect) <= referenceHeight * 0.07));
                bool gluedtoNext = ((r->next != NULL) && (rectSpaceBetweenRects(r->rect, r->next->rect) <= referenceHeight * 0.07));
                bool doneWithThisQuote = false;
                //"'1" instead of '4'
                // Glued to next, next looks like '1', line has digits (otherwise no need to bother creating a '4', useless on its own)
                if (!(r->flags2 & FLAGS2_TESTED_AS_4) && gluedtoNext && !gluedtoPrevious && (r->next != NULL) && isVerticalLine(r->next->ch) && (statsWithoutCurrentAndNext->averageHeightDigits.count > 0)
                    // Wide enough to be a '4'
                    && (rectRight(r->next->rect) - rectLeft(r->rect) + 1 > referenceWidth * 0.85)
                    // 4 left side "nose" extends below midpoint of '1'
                    && (rectTop(r->rect) - rectBottom(r->next->rect) > referenceHeight * 0.50)
                    // 4 left side "nose" not too small
                    && (r->rect.size.height > referenceHeight * 0.25)) {
                    r->flags2 |= FLAGS2_TESTED_AS_4;
                    // Now test that the pattern is curved left
                    SingleLetterTests *st = CreateSingleLetterTests(r->rect, results, false);
                    if (st != NULL) {
                        OpeningsTestResults resRight;
                        bool success = st->getOpenings(resRight, SingleLetterTests::Right,
                                            0.00,      // Start of range to search (top/left)
                                            1.00,      // End of range to search (bottom/right)
                                            SingleLetterTests::Bound,   // Require start (top/left) bound
                                            SingleLetterTests::Bound  // Require end (bottom/right) bound
                                            );
                        if (success) {
                            replaceTwo(r, '4', "rule 0454");
                            if (r->next == NULL) continue;
                            doneWithThisQuote = true;
                        }
                        delete st;
                    }
                }
                
                if (!doneWithThisQuote) {
                    bool doit = false;
                    if (results->imageTests && (gluedtoPrevious || gluedtoNext))
                    {
                        // Glued to previous and not above
                        if (gluedtoPrevious
                            // If URL or email remove as long a glued, no matter how high!
                            && ((rectBottom(r->rect) - rectBottom(r->previous->rect) < r->previous->rect.size.height * 0.05))) {
                            CGRect combinedRect = CreateCombinedRect(r->previous->rect, r->rect);
                            SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results, false);
                            if (st != NULL)
                            {
                                ConnectedComponentList cpl = st->getConnectedComponents();
                                if (cpl.size() == 2) {
                                    doit = true;
                                    // Attention: could be a 'r'!
                                    if (isVerticalLine(r->previous->ch) && (tallHeightTest(statsWithoutCurrent.getPtr(), combinedRect.size.height, 'r', false, 1, false) == 0)) {
                                        SegmentList slTop = st->getHorizontalSegments(0.075, 0.15);
                                        SegmentList slBottom = st->getHorizontalSegments(0.925, 0.15);
                                        if ((slTop.size() == 1) && (slBottom.size() == 1)
                                            // Ticker on top
                                            && (slTop[0].endPos - slTop[0].startPos + 1 > (slBottom[0].endPos - slBottom[0].startPos + 1) * 1.15)) {
                                                wchar_t newCh = 'r';
                                                replaceTwoWithRect(r->previous, newCh, combinedRect, "rule 0016");
                                                makeAnotherPass = true;
                                                continue;
                                        }
                                    }
                                } else if (cpl.size() == 3) {
                                    ConnectedComponent mainCC = cpl[1];
                                    ConnectedComponent minorCC = cpl[2];
                                        // Past middle
                                    if ((minorCC.xmin > combinedRect.size.width * 0.50)
                                        // To the right of the main CC
                                        && (minorCC.xmin > mainCC.xmin)
                                        // Below quote part
                                        && (minorCC.ymin > r->rect.size.height)) {
                                        doit = true;
                                    }
                                }
                                delete st;
                            }
                        }
                        // Glued to next and not above
                        if (!doit && gluedtoNext
                                && (rectBottom(r->rect) - rectBottom(r->next->rect) < referenceHeight * 0.05))
                        {
                            CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                            SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results, false);
                            if (st != NULL)
                            {
                                ConnectedComponentList cpl = st->getConnectedComponents();
                                if (cpl.size() == 2) {
                                    doit = true;
                                } else if (cpl.size() == 3) {
                                    ConnectedComponent mainCC = cpl[1];
                                    ConnectedComponent minorCC = cpl[2];
                                    // Before middle
                                    if ((minorCC.xmin < combinedRect.size.width * 0.50)
                                        // To the left of the main CC
                                        && (minorCC.xmin < mainCC.xmin)
                                        // In top 40%
                                        && (minorCC.ymax < combinedRect.size.height * 0.40)) {
                                        doit = true;
                                    }
                                }
                                delete st;
                            }
                        }
                    }
                    if (doit) {
                        ReplacingLog("Validate: rule 0016 replacing - eliminating glued quote in word [%s]",
                                     toUTF8(r->word->text()).c_str());
                        SmartPtr<OCRRect> p = r->next; // Save r->next
                        r->word->removeLetter(r);
                        r = p;
                        if (r == NULL)
                            continue;
                    }
                } // !done with this quote
            } // quote

//#if DEBUG
//            if ((r->next != NULL) && (r->next->ch =='1') && (r->previous != 0) && (r->previous->ch == '$') && (r->next->next != NULL) && (r->next->next->ch == '.')) {
//                DebugLog("Found in word [%s]", toUTF8(r->word->text()).c_str());
//                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
//                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results, SINGLE_LETTER_VALIDATE_SINGLE_COMP);
//                delete st;
//                DebugLog("");
//            }
//#endif
        
#if DEBUG
			if ((r->previous != NULL) && (r->previous->ch =='B') && (r->ch == 'S') && (r->next != NULL) && (r->next->ch == '.')) {
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results, false);
                delete st;
				DebugLog("Found in [%s]", toUTF8(r->word->text()).c_str());
                DebugLog("");
			}
#endif
            
            // 2015-09-30 "51" instead of '9'
            // $ [488,325 - 500,345] w=12,h=21]
            // 1 [503,326 - 512,343] w=9,h=18]
            // 9 [514,326 - 526,343] w=12,h=18] (12/9 = 1.33 - use +25%)
            // . [532,340 - 535,342] w=3,h=3]
            // 5 [540,325 - 547,341] w=7,h=17]
            // 1 547,326 - 552,341] w=5,h=16]
            // 9 [554,324 - 564,342] w=10,h=19]
            
            // "S." instead of '9'
            //2016-02-23 14:45:28.825 Windfall[50300:4716641] #212: B quality: 75 [599,236 - 610,255] w=12,h=20]
            //2016-02-23 14:45:28.825 Windfall[50300:4716641] #213: S quality: 68 [614,235 - 621,255] w=8,h=21]
            //2016-02-23 14:45:28.825 Windfall[50300:4716641] #214: . quality: 64 [623,240 - 625,249] w=3,h=10]
            
            if (((r->ch == '5') || (r->ch == 'S')) && (r->next != NULL) && ((r->next->ch == '1') || (r->next->ch == 'J') || (r->next->ch == '.'))) {
                // If next char is a '.', make sure it hangs high (above 40% mark)
                if ((r->next->ch != '.') || (rectTop(r->next->rect) < rectBottom(r->rect) + r->rect.size.height * 0.70)) {
                    CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                    if (((statsWithoutCurrentAndNext->averageWidthDigits.count == 0) || ((combinedRect.size.width < statsWithoutCurrentAndNext->averageWidthDigits.average * 1.15) && (combinedRect.size.width > statsWithoutCurrentAndNext->averageWidthDigits.average * 0.85)))
                        && ((combinedRect.size.width < results->globalStats.averageWidthDigits.average * 1.15) && (combinedRect.size.width > results->globalStats.averageWidthDigits.average * 0.85))) {
                        char newCh = '\0';
                        if (!(r->flags5 & FLAGS5_TESTED_AS_DISCONNECTED_DIGIT5)) {
                            r->flags5 |= FLAGS5_TESTED_AS_DISCONNECTED_DIGIT5;
                            newCh = testAsDisconnectedDigit(r, combinedRect, statsWithoutCurrent, results, '5', '\0', true);
                        }
                        if ((newCh == '\0') && !(r->flags3 & FLAGS3_TESTED_AS_DISCONNECTED_DIGIT9)) {
                            r->flags3 |= FLAGS3_TESTED_AS_DISCONNECTED_DIGIT9;
                            newCh = testAsDisconnectedDigit(r, combinedRect, statsWithoutCurrent, results, '9', '\0', true);
                        }
                        if (newCh != '\0') {
                            replaceTwoWithRect(r, newCh, combinedRect, "rule 0614 disconnected");
                            makeAnotherPass = true;
                        }
                        //replaceTwoWithRect(r, '9', combinedRect, "rule 0455");
                    }
                }
            }
        
        
#if DEBUG
            if ((r->ch=='3') && (r->next != NULL) && (r->next->ch=='7') && (r->previous != NULL) && (r->previous->ch=='7')) {
                //CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                if (st != NULL) delete st;
                DebugLog("Found in word [%s]", toUTF8(r->word->text()).c_str());
                DebugLog("Found");
            } 
#endif

            //  -------------
            //0|             |
            //1|    11 11    |
            //2|  1111 111   |
            //3|  11    111  |
            //4| 11      11  |
            //5|  1       1  |
            //6|  11     11  |
            //7|  111   111  |
            //8|   111 111   |
            //9|   111 111   |
            //a|   11   11   |
            //b|  11     11  |
            //c|  1       11 |
            //d| 11       11 |
            //e|  11     11  |
            //f|  111   111  |
            //#|  1111 1111  |
            //#|   111 111   |
            //#|             |
            //  -------------
            // "C3" instead of '8' see https://drive.google.com/open?id=0B4jSQhcYsC9VNjM0dUI3N2hFUFU
            // "L3" instead of '8'. See Target receipt sent by Darren 10/1/2015:
            //2015-10-20 17:22:34.303 Windfall[2064:73000] #902: $ quality: 55 [547,653 - 556,673] w=9,h=21]
            //2015-10-20 17:22:34.303 Windfall[2064:73000] #903: L quality: 60 [558,655 - 564,671] w=6,h=17]
            //2015-10-20 17:22:34.304 Windfall[2064:73000] #904: 3 quality: 73 [563,653 - 569,670] w=6,h=18]
            //2015-10-20 17:22:34.304 Windfall[2064:73000] #905: ' quality: 66 [572,653 - 574,654] w=2,h=2]
            //2015-10-20 17:22:34.304 Windfall[2064:73000] #906: . quality: 92 [575,669 - 578,671] w=3,h=3]
            //2015-10-20 17:22:34.304 Windfall[2064:73000] #907: 0 quality: 88 [583,652 - 595,671] w=12,h=20]
            //2015-10-20 17:22:34.304 Windfall[2064:73000] #908: 0 quality: 87 [596,652 - 608,670] w=12,h=19]
            //  -------------
            //0|             |
            //1|       1     |
            //2|        11   |
            //3| 11      11  |
            //4| 11      11  |
            //5| 11      11  |
            //6| 11      11  |
            //7|   1    11   |
            //8|   11 111    |
            //9|   11  111   |
            //a|   1    11   |
            //b|  11     11  |
            //c| 11      111 |
            //d| 11       11 |
            //e| 11       1  |
            //f| 11      111 |
            //#|  11     11  |
            //#|  111   111  |
            //#|   1111 11   |
            //#|     11      |
            //#|             |
            //  -------------
            // "L1" instead of '4', see 94100212 product in https://drive.google.com/open?id=0B4jSQhcYsC9VZzM1cmFITkx4MFU
            // TODO the below will replace "L3" with '8' even when it's a 'B'. For now we don't care since we don't care about abbreviations much
            if (((r->ch == 'C') || (r->ch == 'L') || isVerticalLine(r->ch)) && (r->next != NULL) && ((r->next->ch == '3') || isVerticalLine(r->next->ch))&& (results->imageTests)) {
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                char newCh = '\0';
                if (!(r->flags3 & FLAGS3_TESTED_AS_DISCONNECTED_DIGIT4) && (r->rect.size.height < (r->next->rect.size.height * 0.80))) {
                    r->flags3 |= FLAGS3_TESTED_AS_DISCONNECTED_DIGIT4;
                    newCh = testAsDisconnectedDigit(r, combinedRect, statsWithoutCurrent, results, '4', '\0', true);
                }
                if (!(r->flags4 & FLAGS4_TESTED_AS_DISCONNECTED_DIGIT8)) {
                    r->flags4 |= FLAGS4_TESTED_AS_DISCONNECTED_DIGIT8;
                    newCh = testAsDisconnectedDigit(r, combinedRect, statsWithoutCurrent, results, '8', '\0', true);
                }
                if ((newCh == '\0') && !(r->flags4 & FLAGS4_TESTED_AS_DISCONNECTED_DIGIT6)) {
                    r->flags6 |= FLAGS4_TESTED_AS_DISCONNECTED_DIGIT6;
                    newCh = testAsDisconnectedDigit(r, combinedRect, statsWithoutCurrent, results, '6', '\0', true);
                }
                if (newCh != '\0') {
                    replaceTwoWithRect(r, newCh, combinedRect, "rule 0583 disconnected");
                    makeAnotherPass = true;
                }
            }
            
//#if DEBUG
//            if ((r->ch=='C') && (r->next == NULL) && (r->previous != NULL) && (r->previous->ch=='2') && (r->previous->previous != NULL) && ((r->previous->previous->ch=='.'))) {
//                CGRect combinedRect = r->rect;
//                combinedRect.size.width += r->rect.size.width * 0.50;
//                combinedRect.size.height = 21;
//                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
//                if (st != NULL) delete st;
//                DebugLog("Found in word [%s]", toUTF8(r->word->text()).c_str());
//                DebugLog("Found");
//            } 
//#endif


            //  -------------
            //0|             |
            //1|     111     |
            //2|   11111     |
            //3|  111        |
            //4|  11       1 |
            //5| 11       111|
            //6| 11       111|
            //7| 11        11|
            //8| 11        11|
            //9| 111       11|
            //a|  111      11|
            //b|  111  11 111|
            //c|   111111 111|
            //d|      11   11|
            //e|           11|
            //f|           11|
            //#|           1 |
            //#|  1          |
            //#| 111   111   |
            //#| 111111111   |
            //#|  1111111    |
            //#|             |
            //  -------------
            // 'C' instead of '9' - see https://drive.google.com/open?id=0B4jSQhcYsC9VZWlxQkxvSWgtRkk

#if DEBUG
            if (((r->ch=='C') || (r->ch=='c')) && (r->next == NULL) && (r->previous != NULL) && (r->previous->ch=='9')) {
                CGRect combinedRect = r->rect;
                combinedRect.size.width = results->globalStats.averageWidthDigits.average;
                combinedRect.size.height = results->globalStats.averageHeightDigits.average;
                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
                if (st != NULL) delete st;
                DebugLog("Found in word [%s]", toUTF8(r->word->text()).c_str());
                DebugLog("Found");
            } 
#endif
            // Short and narrow 'C'
            if (((r->ch == 'C') || (r->ch == 'c')) && (statsWithoutCurrent->averageWidthDigits.count > 0) && (r->rect.size.width < statsWithoutCurrent->averageWidthDigits.average * 0.90) && (r->rect.size.width < results->globalStats.averageWidthDigits.average * 0.90) && (r->rect.size.height < statsWithoutCurrent->averageHeightDigits.average * 0.75) && !(r->flags3 & FLAGS3_TESTED_AS_DISCONNECTED_DIGIT9)) {
                // Make sure 'C' is high above baseline
                CGRect closestDigit = findClosestDigitLookAlike(r, statsWithoutCurrent, results);
                if (closestDigit.size.width > 0) {
                    float gapAbove = rectTop(closestDigit) - rectTop(r->rect);
                    if (gapAbove > statsWithoutCurrent->averageHeightDigits.average * 0.25) {
                        CGRect newRect = computeCapturingRectRight(r, statsWithoutCurrent, results);
                        // Also make it taller
                        newRect.size.height = statsWithoutCurrent->averageHeightDigits.average;
                        if (closestDigit.size.height > newRect.size.height)
                            newRect.size.height = closestDigit.size.height;
                        if (rectTop(newRect) > rectTop(results->imageRange))
                            newRect.size.height = rectTop(results->imageRange) - rectBottom(newRect) + 1;
                        if (newRect.size.width > 0) {
                            r->flags3 |= FLAGS3_TESTED_AS_DISCONNECTED_DIGIT9;
                            int nDigitLookalikesBefore = countDigitLookalikes(r->previous, false, results);
                            int nDigitLookalikesAfter = countDigitLookalikes(r->previous, true, results);
                            int laxLevel = ((nDigitLookalikesBefore + nDigitLookalikesAfter == results->retailerParams.productNumberLen -1)? 2:0);
                            wchar_t newCh = testAsDisconnectedDigit(r, newRect, statsWithoutCurrent, results, '9', '\0', false, laxLevel, true); // Indicate we are working with a single rect
                            if (newCh != '\0') {
                                ReplacingLog("ValidateLine: rule 0613 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                                r->word->updateLetterWithNewCharAndNewRect(r, newCh, newRect);
                                makeAnotherPass = true;
                            }
                        }
                    }
                }
            }
            
            //  -----------------------
            //0|                       |
            //1|   11111      11       |
            //2|  111111     1111111   |
            //3|  111111     11111111  |
            //4| 111111      1111 1111 |
            //5| 111     1   111   111 |
            //6| 111    11         111 |
            //7| 111    11        111  |
            //8| 111    11     111111  |
            //9| 111    11     111111  |
            //a| 111    11        111  |
            //b| 111    11        1111 |
            //c| 111    11        1111 |
            //d| 111  1 11        111  |
            //e| 111111      111  111  |
            //f|  11111      1111 1111 |
            //#|  11111      11111111  |
            //#|   1111      1111111   |
            //#|              1  11    |
            //#|                       |
            //  -----------------------
            // 'C' instead of '0'
            //2016-01-11 16:41:02.893 Windfall[90178:5923712] #659: O quality: 91 [278,485 - 286,501] w=9,h=17]
            //2016-01-11 16:41:02.893 Windfall[90178:5923712] #660: C quality: 79 [290,486 - 296,502] w=7,h=17]
            //2016-01-11 16:41:02.893 Windfall[90178:5923712] #661: 3 quality: 80 [302,486 - 310,503] w=9,h=18]
     
            
            if (((r->ch == 'C') || (r->ch == 'L') || (r->ch == 'I'))
                && ((((statsWithoutCurrent->averageWidthDigits.count == 0) || (r->rect.size.width <statsWithoutCurrent->averageWidthDigits.average * 0.85)) && ((statsWithoutCurrent->averageWidthUppercase.count == 0) || (r->rect.size.width < statsWithoutCurrent->averageWidthUppercase.average * 0.85))
                    )
                    || ((((r->previous != NULL) && isDigitLookalikeExtended(r->previous->ch)) || ((r->next != NULL) && isDigitLookalikeExtended(r->next->ch))) && ((statsWithoutCurrent->averageWidthDigits.count > 0)
                        && ((r->rect.size.width < statsWithoutCurrent->averageWidthDigits.average * 0.90)
                            || ((countDigitLookAlikesInCurrentWord >= 3) && (r->rect.size.width < statsWithoutCurrent->averageWidthDigits.average))
                            ))
                       )
                   )
                && !(r->flags4 & FLAGS4_TESTED_AS_DISCONNECTED_DIGIT0)
                //&& ((r->next == NULL) || (r->next->ch == ' ') || ((statsWithoutCurrentAndNext->averageSpacing.count == 0) || (rectSpaceBetweenRects(r->rect, r->next->rect) > statsWithoutCurrentAndNext->averageSpacing.average)))
                ) {
                CGRect newRect = computeCapturingRectRight(r, statsWithoutCurrent, results);
                if (newRect.size.width > 0) {
                    r->flags4 |= FLAGS4_TESTED_AS_DISCONNECTED_DIGIT0;
                    int laxLevel = 0;
                    if (countDigitLookAlikesInCurrentWord == results->retailerParams.productNumberLen -1)
                        laxLevel = 2;
                    wchar_t newCh = testAsDisconnectedDigit(r, newRect, statsWithoutCurrent, results, '0', '\0', false, laxLevel, true); // Indicate we are working with a single rect
                    if (newCh != '\0') {
                        ReplacingLog("ValidateLine: rule 0585 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                        r->word->updateLetterWithNewCharAndNewRect(r, newCh, newRect);
                        makeAnotherPass = true;
                    }
                }
            }
            
            
//2016-02-17 11:25:09.076 Windfall[37215:3159281] #67: 0 quality: 87 [96,110 - 107,130] w=12,h=21]
//2016-02-17 11:25:09.076 Windfall[37215:3159281] #68: 1 quality: 74 [110,110 - 115,129] w=6,h=20]
//2016-02-17 11:25:09.076 Windfall[37215:3159281] #69: / quality: 51 [117,110 - 121,120] w=5,h=11]
            
//#if DEBUG
//            // 055OIz1368
//            if ((r->ch=='I') && (r->previous != NULL) && (r->previous->ch=='O') && (r->next != NULL) && (r->next->ch=='z'))  {
//                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
//                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
//                if (st != NULL) delete st;
//                DebugLog("Found in [%s]", toUTF8(r->word->text()).c_str());
//                DebugLog("");
//            }
//#endif
            
            //  ----------------
            //0|                |
            //1|                |
            //2|   11111        |
            //3|  111111        |
            //4| 111111    1    |
            //5| 1111     11    |
            //6| 111      11    |
            //7| 111      11    |
            //8| 111      11    |
            //9| 111      11    |
            //a| 111      11    |
            //b| 1111     11    |
            //c| 111111   11    |
            //d|  11111   11    |
            //e|  11111   11    |
            //f|    11    11    |
            //#|          11    |
            //#|          11    |
            //#|          11    |
            //#|   1111         |
            //#|  111111        |
            //#| 1111111        |
            //#| 111111         |
            //#|   111          |
            //#|                |
            //  ----------------
            // 'S' instead of '9', see https://drive.google.com/open?id=0B4jSQhcYsC9VVHBuUkllcE0zUEk / https://www.pivotaltracker.com/story/show/111385126
            if (((r->ch == 'S') || (r->ch == '5')) && ((statsWithoutCurrent->averageWidthDigits.count == 0) || (r->rect.size.width < statsWithoutCurrent->averageWidthDigits.average * 0.85)) && ((statsWithoutCurrent->averageWidthUppercase.count == 0) || (r->rect.size.width < statsWithoutCurrent->averageWidthUppercase.average * 0.85)) && !(r->flags3 & FLAGS3_TESTED_AS_DISCONNECTED_DIGIT9)
                && ((r->next == NULL) || (r->next->ch == ' ') || ((statsWithoutCurrent->averageSpacing.count == 0) || (rectSpaceBetweenRects(r->rect, r->next->rect) > statsWithoutCurrent->averageSpacing.average * 1.10)))) {
                bool doit = true;
                CGRect newRect = computeCapturingRectRight(r, statsWithoutCurrent, results);
                if (doit) {
                    r->flags3 |= FLAGS3_TESTED_AS_DISCONNECTED_DIGIT9;
                    wchar_t newCh = testAsDisconnectedDigit(r, newRect, statsWithoutCurrent, results, '9', '\0', false, 0, true); // Indicate we are working with a single rect
                    if (newCh != '\0') {
                        ReplacingLog("ValidateLine: rule 0587 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                        CGRect adjustedRect = computeTrimmedRect(newRect, results); // Calculate tighter rect
                        r->word->updateLetterWithNewCharAndNewRect(r, newCh, adjustedRect);
                        makeAnotherPass = true;
                    }
                }
            }

            // "17" instead of '7'
            //  -------------
            //0|             |
            //1| 1111    1   |
            //2| 11111  1111 |
            //3| 11111  1111 |
            //4| 11      111 |
            //5|         111 |
            //6|        1111 |
            //7|        111  |
            //8|       111   |
            //9|       111   |
            //a|       11    |
            //b|             |
            //c|             |
            //d|    11       |
            //e|    11       |
            //f|    11       |
            //#|    11       |
            //#|    11       |
            //#|    11       |
            //#|    11       |
            //#|    11       |
            //#|             |
            //  -------------

            //  ----------
            //0|          |
            //1| 11  111  |
            //2| 11 11111 |
            //3| 1   1111 |
            //4|      11  |
            //5|     111  |
            //6|     11   |
            //7|     11   |
            //8|    111   |
            //9|    11    |
            //a|    11    |
            //b|    11    |
            //c|    11    |
            //d|    1     |
            //e|  1       |
            //f|  11      |
            //#| 111      |
            //#| 111      |
            //#| 11       |
            //#|          |
            //  ----------
            //2015-12-23 13:16:19.097 Windfall[38500:2705760] #140: . quality: 79 [106,232 - 108,236] w=3,h=5]
            //2015-12-23 13:16:19.097 Windfall[38500:2705760] #141: Z quality: 64 [109,219 - 113,231] w=5,h=13]
            //2015-12-23 13:16:19.097 Windfall[38500:2705760] #142: 6 quality: 89 [115,219 - 124,236] w=10,h=18]
            // ".Z" instead of '7', see https://www.pivotaltracker.com/story/show/110541064
            // Or ".Z" instead of '2'
            //  -----------
            //0|           |
            //1| 111  11   |
            //2| 111 1111  |
            //3| 111  1111 |
            //4| 111  1111 |
            //5|  1   1111 |
            //6|      111  |
            //7|      111  |
            //8|     1111  |
            //9|     111   |
            //a|     111   |
            //b|  11 11    |
            //c|  11       |
            //d| 111       |
            //e| 111       |
            //f| 111 11111 |
            //#| 111 11111 |
            //#|      111  |
            //#|           |
            //  -----------
            
#if DEBUG
            // 055OIz1368
            if ((r->ch=='.') && (r->next != NULL) && (r->next->ch=='Z'))  {
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
                if (st != NULL) delete st;
                DebugLog("Found in [%s]", toUTF8(r->word->text()).c_str());
                DebugLog("");
            }
#endif
            
            if ((r->next != NULL)
                && (((isVerticalLine(r->ch) || (r->ch == '.')) && ((r->next->ch == 'Z') || (r->next->ch == 'z')))
                    || (isVerticalLine(r->ch) && ((r->next->ch == '/') || (r->next->ch == '/')))) && (results->imageTests)) {
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                // Do this test both passes because it's co-dependent on other possible mistakes in a product number
                r->flags4 |= FLAGS4_TESTED_AS_DISCONNECTED_DIGIT7;
                int nDigitsLookalikesBefore = countDigitLookalikes(r->previous, false, results);
                int nDigitsLookalikesAfter = countDigitLookalikes(r->next->next, true, results);
                int laxLevel = ((nDigitsLookalikesBefore + nDigitsLookalikesAfter == results->retailerParams.productNumberLen - 1)? 2:0);
                wchar_t newCh = testAsDisconnectedDigit(r, combinedRect, statsWithoutCurrent, results, '7', '\0', true, laxLevel);
                if ((newCh == '\0') && !(r->flags5 & FLAGS5_TESTED_AS_DISCONNECTED_DIGIT2)) {
                    r->flags5 |= FLAGS5_TESTED_AS_DISCONNECTED_DIGIT2;
                    newCh = testAsDisconnectedDigit(r, combinedRect, statsWithoutCurrent, results, '2', '\0', true, laxLevel);
                }
                if (newCh != '\0') {
                    replaceTwoWithRect(r, newCh, combinedRect, "rule 0579 disconnected");
                    makeAnotherPass = true;
                }
            }
            
#if DEBUG
            if ((r->ch=='2') && (r->next != NULL) && (r->next->ch=='1') && (r->previous != NULL) && (r->previous->ch=='3') && (r->previous->previous != NULL) && (r->previous->previous->ch=='8'))  {
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
                if (st != NULL) delete st;
                DebugLog("Found in [%s]", toUTF8(r->word->text()).c_str());
                DebugLog("");
            }
#endif
            
            //  --------------
            //0|              |
            //1|    11        |
            //2|   111   11   |
            //3|  1111   111  |
            //4|  1111    111 |
            //5|  111     111 |
            //6|          111 |
            //7|          111 |
            //8|          111 |
            //9|          111 |
            //a|         111  |
            //b|         11   |
            //c|        11    |
            //d|     1        |
            //e|    111       |
            //f|   1111       |
            //#|  1111        |
            //#|  111         |
            //#| 111          |
            //#| 1111   111   |
            //#| 11111  1111  |
            //#|  111   1111  |
            //#|              |
            //  --------------
            // "11" instead of '2', see https://drive.google.com/open?id=0B4jSQhcYsC9VdlIwWHRoc3JoYWs
            // "21" instead of '2', see https://drive.google.com/open?id=0B4jSQhcYsC9VTHRsVGlSX2J5Y0k (1688832 product)
            if ((r->next != NULL)
                && ((isVerticalLine(r->ch) && isVerticalLine(r->next->ch))
                    || ((r->ch == '2') && isVerticalLine(r->next->ch) && (rectRight(r->next->rect) - rectLeft(r->rect) + 1 < results->globalStats.averageWidthDigits.average * 1.15) && (statsWithoutCurrentAndNext->averageWidthDigits.count > 0) && (rectRight(r->next->rect) - rectLeft(r->rect) + 1 < statsWithoutCurrentAndNext->averageWidthDigits.average * 1.15))
                    || ((r->ch == '.') && (isVerticalLine(r->next->ch))))
                && !(r->flags5 & FLAGS5_TESTED_AS_DISCONNECTED_DIGIT2)) {
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                r->flags5 |= FLAGS5_TESTED_AS_DISCONNECTED_DIGIT2;
                // If combining these two rects into one digit helps up make up a product number, be lax
                // PQTODO set lax also when it helps make up a valid price
                int lax = ((countDigitLookAlikesInCurrentWord == results->retailerParams.productNumberLen + 1)? 2:0);
                wchar_t newCh = testAsDisconnectedDigit(r, combinedRect, statsWithoutCurrent, results, '2', '\0', true, lax);
                if (newCh != '\0') {
                    replaceTwoWithRect(r, newCh, combinedRect, "rule 0583 disconnected");
                    makeAnotherPass = true;
                }
            }
            
            
            //  ----------
            //0|          |
            //1|   1 1    |
            //2|  11 11   |
            //3| 11   11  |
            //4| 11    11 |
            //5| 1     11 |
            //6|       11 |
            //7|      11  |
            //8|     111  |
            //9|      11  |
            //a|      11  |
            //b|       11 |
            //c|       11 |
            //d| 11   111 |
            //e| 111 111  |
            //f| 111 111  |
            //#|  1       |
            //#|          |
            //  ----------
            //2015-12-22 14:21:16.078 Windfall[33871:2338606] #224: 2 quality: 86 [337,270 - 346,285] w=10,h=16]
            //2015-12-22 14:21:16.078 Windfall[33871:2338606] #225: 1 quality: 63 [349,270 - 351,285] w=3,h=16]
            //2015-12-22 14:21:16.078 Windfall[33871:2338606] #226: 1 quality: 65 [353,270 - 356,284] w=4,h=15]
            //2015-12-22 14:21:16.079 Windfall[33871:2338606] #227: 6 quality: 85 [358,270 - 367,285] w=10,h=16]
            // "11" instead of '3' (disconnected by vertical line)
            
            //  ---------------
            //0|               |
            //1|       11111   |
            //2|    11 11111   |
            //3|   111  1111   |
            //4|  1111    11   |
            //5|  111     11   |
            //6| 1111      1   |
            //7| 1111      1   |
            //8| 1111      11  |
            //9| 111       11  |
            //a| 111       11  |
            //b| 111       11  |
            //c| 111       11  |
            //d| 111       111 |
            //e| 111       111 |
            //f| 111       11  |
            //#| 111       11  |
            //#| 111      111  |
            //#| 1111     11   |
            //#|  111    111   |
            //#|  111  11111   |
            //#|   11  11111   |
            //#|   11    11    |
            //#|               |
            //  ---------------
            //2015-12-22 15:42:16.215 Windfall[34267:2389640] #150: 2 quality: 80 [360,222 - 370,243] w=11,h=22]
            //2015-12-22 15:42:16.215 Windfall[34267:2389640] #151: 1 quality: 70 [374,223 - 378,243] w=5,h=21]
            //2015-12-22 15:42:16.215 Windfall[34267:2389640] #152: 1 quality: 72 [380,222 - 386,243] w=7,h=22]
            //2015-12-22 15:42:16.215 Windfall[34267:2389640] #153: 5 quality: 87 [389,222 - 400,243] w=12,h=22]
            // "11" instead of '0'
            
            //  --------------
            //0|              |
            //1|   111   111  |
            //2|  11111 11111 |
            //3|  1111   1111 |
            //4|  111     111 |
            //5|          111 |
            //6|         1111 |
            //7|        1111  |
            //8|       1111   |
            //9|       111    |
            //a|      1111    |
            //b|       111    |
            //c|       11111  |
            //d|         1111 |
            //e|          111 |
            //f|           11 |
            //#|           11 |
            //#|  11      111 |
            //#| 111     111  |
            //#| 1111   1111  |
            //#|  1111  111   |
            //#|   111 1111   |
            //#|    11  11    |
            //#|              |
            //  --------------
            // ".3" instead of '3'
            
            
#if DEBUG
            if ((r->ch=='l') && (r->next != NULL) && (r->next->ch==' ') && (r->next->next != NULL) && (r->next->next->ch=='I'))  {
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->next->rect);
                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
                if (st != NULL) delete st;
                DebugLog("Found in [%s]", toUTF8(r->word->text()).c_str());
                DebugLog("");
            }
#endif
            
            //  -----------------
            //0|                 |
            //1|      11  111    |
            //2|     1111 11111  |
            //3|    1111  111111 |
            //4|   1111     11   |
            //5|  1111           |
            //6|  111            |
            //7|  111            |
            //8|  111            |
            //9|  111111         |
            //a|  1111111 111    |
            //b|  11111   1111   |
            //c| 11111     1111  |
            //d| 1111      1111  |
            //e|  111       111  |
            //f| 1111       1111 |
            //#| 1111       1111 |
            //#| 1111       1111 |
            //#|  1111     1111  |
            //#|  11111   11111  |
            //#|  111111  1111   |
            //#|    1111 1111    |
            //#|      11  1      |
            //#|                 |
            //  -----------------
            // "CS" instead of '6' or "IS" instead of '6' or "IS" instead of '5'
            //  -------------
            //0|             |
            //1|       1111  |
            //2|   11  11111 |
            //3|  111  11111 |
            //4|  111    111 |
            //5|  111        |
            //6| 111         |
            //7| 111         |
            //8| 111         |
            //9| 111   11    |
            //a| 111   1111  |
            //b| 111   11111 |
            //c| 111     111 |
            //d| 111     111 |
            //e| 111      11 |
            //f| 111       1 |
            //#| 111       1 |
            //#| 111      11 |
            //#| 1111     11 |
            //#|  111    111 |
            //#|  111   1111 |
            //#|  111  11111 |
            //#|   1   1111  |
            //#|             |
            //  -------------
            // "IS" instead of '6'
            
            //  ------------
            //0|            |
            //1|    111     |
            //2|   1111     |
            //3|  11111     |
            //4| 11111      |
            //5| 1111       |
            //6| 1111       |
            //7| 11111      |
            //8| 111111     |
            //9| 11111   1  |
            //a| 1111   111 |
            //b| 111    111 |
            //c| 111    11  |
            //d| 111    11  |
            //e| 1111   11  |
            //f| 11111      |
            //#|  11111     |
            //#|   111      |
            //#|            |
            //  ------------
            // "E-" instead of '6'
            
#if DEBUG
            if ((r->ch=='C') && (r->next != NULL) && ((r->next->ch=='-') || (r->next->ch=='.')))  {
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
                if (st != NULL) delete st;
                DebugLog("Found in [%s]", toUTF8(r->word->text()).c_str());
                DebugLog("");
            }
#endif
            
            if ((r->next != NULL)
                && (((isCLookalike(r->ch) || (r->ch == 'I')) && (r->next != NULL) && ((r->next->ch == 'S') || (r->next->ch == '$')) && (results->imageTests))
                    || (((r->ch == 'E') || (r->ch == 'C') || (r->ch == 'c')) && ((r->next->ch == '.') || (r->next->ch == '-'))))
                && !(r->flags4 & FLAGS4_TESTED_AS_DISCONNECTED_DIGIT6)) {
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                r->flags4 |= FLAGS4_TESTED_AS_DISCONNECTED_DIGIT6;
                wchar_t newCh = testAsDisconnectedDigit(r, combinedRect, statsWithoutCurrent, results, '6', ((r->ch == 'E')? '\0':'5'), true);
                if (newCh != '\0') {
                    replaceTwoWithRect(r, newCh, combinedRect, "rule 0576 disconnected");
                    makeAnotherPass = true;
                }
            }
            
//#if DEBUG
//            if ((r->ch=='.') && (r->previous != NULL) && (r->previous->ch=='8'))  {
//                CGRect combinedRect = CGRect(rectLeft(r->rect), rectBottom(r->previous->rect), r->rect.size.width * 1.40, r->previous->rect.size.height);
//                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
//                if (st != NULL) delete st;
//                DebugLog("Found in [%s]", toUTF8(r->word->text()).c_str());
//                DebugLog("");
//            }
//#endif
            
            // 'E' instead of '6'
            if ((r->ch == 'E') && ((statsWithoutCurrent->averageWidthDigits.count == 0) || (r->rect.size.width < statsWithoutCurrent->averageWidthDigits.average * 0.85)) && ((statsWithoutCurrent->averageWidthUppercase.count == 0) || (r->rect.size.width < statsWithoutCurrent->averageWidthUppercase.average * 0.85)) && !(r->flags4 & FLAGS4_TESTED_AS_DISCONNECTED_DIGIT6)
                && ((r->next == NULL) || (r->next->ch == ' ') || ((statsWithoutCurrentAndNext->averageSpacing.count == 0) || (rectSpaceBetweenRects(r->rect, r->next->rect) > statsWithoutCurrentAndNext->averageSpacing.average)))) {
                bool doit = true;
                CGRect newRect = computeCapturingRectRight(r, statsWithoutCurrent, results);
                if (doit) {
                    r->flags4 |= FLAGS4_TESTED_AS_DISCONNECTED_DIGIT6;
                    wchar_t newCh = testAsDisconnectedDigit(r, newRect, statsWithoutCurrent, results, '6', '\0', false, 0, true); // Indicate we are working with a single rect
                    if (newCh != '\0') {
                        ReplacingLog("ValidateLine: rule 0581 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                        CGRect adjustedRect = computeTrimmedRect(newRect, results); // Calculate tighter rect
                        r->word->updateLetterWithNewCharAndNewRect(r, newCh, adjustedRect);
                        makeAnotherPass = true;
                    }
                }
            }
            
            //  -------------
            //0|             |
            //1|  1          |
            //2| 11111 1111  |
            //3| 1111  1111  |
            //4| 11          |
            //5| 11          |
            //6| 11    1     |
            //7| 11111 111   |
            //8|  111   11   |
            //9|  11    111  |
            //a|         11  |
            //b|          11 |
            //c|          11 |
            //d|          11 |
            //e|  1       11 |
            //f| 111     111 |
            //#|  111   111  |
            //#|  1111 1111  |
            //#|   111 111   |
            //#|             |
            //  -------------
            // "E5" instead of '5'
            if ((r->ch == 'E') && (r->next != NULL) && (r->next->ch == '5') && (results->imageTests) && !(r->flags5 & FLAGS5_TESTED_AS_DISCONNECTED_DIGIT5)) {
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                r->flags4 |= FLAGS5_TESTED_AS_DISCONNECTED_DIGIT5;
                wchar_t newCh = testAsDisconnectedDigit(r, combinedRect, statsWithoutCurrent, results, '5', '\0', true);
                if (newCh != '\0') {
                    replaceTwoWithRect(r, newCh, combinedRect, "rule 0577 disconnected");
                    makeAnotherPass = true;
                }
            }
            
            OCRVerboseLog("OCRValidate: about to check rule 0092");
            // [D (0x44)] at [368,383 - 393,410] [w=26,h=28]
            // Normal o on same line:   [o (0x6f)] at [69,384 - 87,404] [w=19,h=21]
            // Bad o (actually a .):    [o] [w=8, h=9]
            if (((r->ch == 'o') || (r->ch == '0') || (r->ch == 'O'))
                && ((statsWithoutCurrent->averageHeightUppercase.count >= 2) || (statsWithoutCurrent->averageHeightDigits.count >= 2) || (statsWithoutCurrent->averageHeightNormalLowercase.count >= 2))
                && (((statsWithoutCurrent->averageHeightUppercase.count == 0) || (r->rect.size.height < statsWithoutCurrent->averageHeightUppercase.average * 0.40))
                   && ((statsWithoutCurrent->averageHeightDigits.count == 0) || (r->rect.size.height < statsWithoutCurrent->averageHeightUppercase.average * 0.35))
                   && ((statsWithoutCurrent->averageHeightNormalLowercase.count == 0) || (r->rect.size.height < statsWithoutCurrent->averageHeightNormalLowercase.average * 0.50)))) {
                // No need for extra test below because we have strict visual tests below
                //int maxCount = MAX(statsWithoutCurrent->averageHeightUppercase.count, statsWithoutCurrent->averageHeightDigits.count);
                //maxCount = MAX(maxCount, statsWithoutCurrent->averageHeightNormalLowercase.count);
                //if (maxCount > 2) {
                char newCh = '.';
                bool doit = true;
                if (results->imageTests) {
                    SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                    if (st != NULL) {
                        ConnectedComponentList cpl = st->getConnectedComponents();
                        if (cpl.size() > 1) {
                            ConnectedComponent main = cpl[1];
                            DebugLog("hxw=%f, area=%d", main.getWidth() * main.getHeight(), main.area)
                            if (main.area < main.getWidth() * main.getHeight() * 0.65) {
                                // Not solid enough, abort. NOTE: just a sanity check, there are many legit 'o' where the density is above even 72%!
                                doit = false;
                            } else {
                                // Yet another test: solid, i.e. not inverted component
                                ConnectedComponentList invertedCpl = st->getInverseConnectedComponents();
                                if (invertedCpl.size() > 1) {
                                    doit = false;
                                }
                            }
                        }
                        delete st;
                    }
                }
                if (doit) {
                    ReplacingLog("ValidateLine: rule 0092 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                    makeAnotherPass = true;               
                }
#if DEBUG
                else {
                    ReplacingLog("ValidateLine: rule 0092 NOT replacing [%c] with [%c] in word [%s], failed visual tests", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                }
#endif
            }
            
            // Test for any two glued rects (with at least one of them not a digit), while other rects on this line are generally not glued, forming a single comp and surrounded by digits - likely a digit as well
            if (digitsOnly && (r->next != NULL) && (r->next->ch != ' ')
                && (!isDigit(r->ch) || !isDigit(r->next->ch))
                && (r->ch != '.') && (r->next->ch != '.')
                && (statsWithoutCurrentAndNext->averageSpacing.average > 0)
                // Saw a case where distance was 2 pixels (av. spacing = 3.8)
                // Also saw a case where distance is 1 pixel and av. spacing = 1.71 (58%)
                && ((rectSpaceBetweenRects(r->rect, r->next->rect) < statsWithoutCurrentAndNext->averageSpacing.average * 0.59)
                    || ((rectSpaceBetweenRects(r->rect, r->next->rect) < statsWithoutCurrentAndNext->averageSpacing.average * 0.75)
                            // Combined rect no wider than an average digit width (hints that the two are just one digit)
                            && ((rectRight(r->next->rect) - rectLeft(r->rect)) < statsWithoutCurrentAndNext->averageWidthDigits.average * 1.15)
                            && (countCharsInCurrentWord > results->retailerParams.productNumberLen)) )
                && (results->imageTests)) {
                // Verify single comp
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                // Verify the combined rect is not too wide to be a digit (narrower is OK, could be a '1')
                if (((statsWithoutCurrentAndNext->averageWidthDigits.count >= 2) && (combinedRect.size.width < statsWithoutCurrentAndNext->averageWidthDigits.average * 1.15))
                || ((results->globalStats.averageWidthDigits.count >= 2) && (combinedRect.size.width < results->globalStats.averageWidthDigits.average * 1.15))) {
                    char newCh = '\0';
                    // 2015-06-07 disconnected 2 comps returned as 1+J
                    if (((r->ch == '1') || (r->ch == 'C') || isOpenBracket(r->ch)) && ((r->next->ch == 'J') || isClosingBracket(r->next->ch)) && (countCharsInCurrentWord > results->retailerParams.productNumberLen)) {
                        newCh = '0';
                        countCharsInCurrentWord--;
                    }
                    else {
                        SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results, false,SINGLE_LETTER_VALIDATE_SINGLE_COMP);
                        if (st != NULL) {
                            newCh = SingleLetterTestSAsDigit(r, combinedRect, 2, results);
                            delete st;
                        }
                        // Bogus small / at the bottom, just remove the /
                        else if ((r->ch == '/') && isVerticalLine(r->next->ch) && (r->rect.size.height < r->next->rect.size.height * 0.70) && (rectTop(r->rect) > rectBottom(r->next->rect) + r->next->rect.size.height * 0.50)) {
                            newCh = r->next->ch;
                        }
                    }
                    
                    if (newCh != '\0') {
                        countCharsInCurrentWord--;
                        if (isDigitLookalikeExtended(r->next->ch))
                            countDigitLookAlikesInCurrentWord--;
                        if (isDigitLookalikeExtended(newCh) && !isDigitLookalikeExtended(r->ch))
                            countDigitLookAlikesInCurrentWord++;
                        else if (!isDigitLookalikeExtended(newCh) && isDigitLookalikeExtended(r->ch))
                            countDigitLookAlikesInCurrentWord--;
                        replaceTwoWithRect(r, newCh, combinedRect, "rule 0520");
                        r->flags |= FLAGS_SUSPECT;
                        makeAnotherPass = true;
                    }
                }
            }
            
            // "-4" instead of '4'
            if ((r->ch == '-') && (r->next != NULL) && (r->next->ch == '4')) {
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                if (combinedRect.size.width < results->globalStats.averageWidthDigits.average * 1.15) {
                    replaceTwoWithRect(r, r->next->ch, combinedRect, "rule 0641");
                    makeAnotherPass = true;
                }
            }
            
            //  -------------
            //0|             |
            //1|     11      |
            //2|     11      |
            //3|     11      |
            //4|     11      |
            //5| 1111111111  |
            //6| 11111111111 |
            //7| 1111111111  |
            //8|     11      |
            //9|     11      |
            //a|     11      |
            //b|     111     |
            //c|     111     |
            //d|     11      |
            //e|             |
            //  -------------
            // "-F" instead of '+'
            if ((r->ch == '-') && (r->next != NULL) && (r->next->ch == 'F')) {
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                if (combinedRect.size.width < results->globalStats.averageWidthDigits.average * 1.15) {
                    // Check that top part just has one horiz segment (more or less in the middle)
                    bool doit = false;
                    SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
                    if (st != NULL) {
                        SegmentList sl = st->getHorizontalSegments(0.125, 0.25);
                        if ((sl.size() == 1) && (sl[0].startPos > combinedRect.size.width * 0.20) && (sl[0].endPos < combinedRect.size.width * 0.80))
                            doit = true;
                        delete st;
                    }
                    if (doit) {
                        wchar_t newCh = '+';
                        replaceTwoWithRect(r, newCh, combinedRect, "rule 0642");
                        makeAnotherPass = true;
                    }
                }
            }
            
            // "JJ" instead of 'D'
            if ((r->ch == 'J') && (r->next != NULL) && (r->next->ch == 'J')) {
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                if ((combinedRect.size.width < results->globalStats.averageWidthDigits.average * 1.15)
                    // Or, touches next and next-next rect + width of all 3 chars is > 2x average width
                    || ((r->previous != NULL) && (r->previous->ch != ' ') && (rectSpaceBetweenRects(r->previous->rect, combinedRect) <= 0) && (rectSpaceBetweenRects(r->rect, r->next->rect) <= 0) && (rectRight(combinedRect) - rectLeft(r->previous->rect) + 1 > results->globalStats.averageWidthDigits.average * 2) && (rectRight(combinedRect) - rectLeft(r->previous->rect) + 1 < results->globalStats.averageWidthDigits.average * 3))) {
                    // Check that we have one tall inverted comp
                    bool doit = false;
                    SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
                    if (st != NULL) {
                        ConnectedComponentList invertCpl = st->getInverseConnectedComponents();
                        if ((invertCpl.size() == 2)
                            && (invertCpl[1].getHeight() > combinedRect.size.height * 0.70)
                            && (invertCpl[1].getWidth() > combinedRect.size.width * 0.20))
                            doit = true;
                        delete st;
                    }
                    if (doit) {
                        wchar_t newCh = 'D';
                        replaceTwoWithRect(r, newCh, combinedRect, "rule 0643");
                        makeAnotherPass = true;
                    }
                }
            }
            
#if DEBUG
            if ((r->ch=='I') && (r->next != NULL) && (r->next->ch=='C'))  {
                //CGRect combinedRect = CGRect(rectLeft(r->rect), rectBottom(r->previous->rect), r->rect.size.width * 1.40, r->previous->rect.size.height);
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
                if (st != NULL) delete st;
                DebugLog("Found in [%s]", toUTF8(r->word->text()).c_str());
                DebugLog("");
            }
#endif

            // "VI" instead of 'N'
            if ((r->ch == 'V') && (r->next != NULL) && isVerticalLine(r->next->ch)) {
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                if (combinedRect.size.width < results->globalStats.averageWidthDigits.average * 1.15) {
                    wchar_t newCh = 'N';
#if DEBUG
                    SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
                    if (st != NULL) delete st;
#endif
                    replaceTwoWithRect(r, newCh, combinedRect, "rule 0646");
                    makeAnotherPass = true;
                }
            }
            
            
            //  ----------
            //0|          |
            //1| 1      1 |
            //2| 1     11 |
            //3| 11   111 |
            //4| 11   11  |
            //5| 1   11   |
            //6| 1   1    |
            //7| 1  11    |
            //8| 11 11    |
            //9| 11 11    |
            //a| 11  11   |
            //b| 11   11  |
            //c| 11   11  |
            //d| 11    11 |
            //e| 11    11 |
            //f| 11     1 |
            //#|          |
            //  ----------
            // "IC" instead of 'K' or "IK" instead of 'K'
            if (isVerticalLine(r->ch) && (r->next != NULL) && ((r->next->ch == 'C') || (r->next->ch == 'K')) && (rectSpaceBetweenRects(r->rect, r->next->rect) < results->globalStats.averageWidthDigits.average * 0.12)) {
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                if (combinedRect.size.width < results->globalStats.averageWidthDigits.average * 1.15) {
                    wchar_t newCh = 'K';
                    replaceTwoWithRect(r, newCh, combinedRect, "rule 0650");
                    makeAnotherPass = true;
                }
            }

#if DEBUG
            if ((r->ch=='C') && (r->next != NULL) && (r->next->ch=='I') && (r->next->next != NULL) && (r->next->next->ch=='-'))  {
                //CGRect combinedRect = CGRect(rectLeft(r->rect), rectBottom(r->previous->rect), r->rect.size.width * 1.40, r->previous->rect.size.height);
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
                if (st != NULL) delete st;
                DebugLog("Found in [%s]", toUTF8(r->word->text()).c_str());
                DebugLog("");
            }
#endif
            
            
            // "CI" instead of 'O'
            // "CI" instead of 'G', see https://drive.google.com/open?id=0B4jSQhcYsC9VNjM0dUI3N2hFUFU
            if ((r->ch == 'C') && (r->next != NULL) && isVerticalLine(r->next->ch)) {
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                bool doit = false;
                wchar_t newCh = '0';
                if (((combinedRect.size.width < results->globalStats.averageWidthDigits.average * 1.15))
                    && (combinedRect.size.width > results->globalStats.averageWidthDigits.average * 0.85)) {
                    doit = true;
                    
                    // Could be this:
                    //  ------------
                    //0|            |
                    //1|    11      |
                    //2|  1111 11   |
                    //3|  111  111  |
                    //4| 111    11  |
                    //5| 11      11 |
                    //6| 11      1  |
                    //7| 11         |
                    //8| 11         |
                    //9| 11         |
                    //a| 11    1111 |
                    //b| 11    1111 |
                    //c| 11      11 |
                    //d| 11      11 |
                    //e| 11      11 |
                    //f| 111    111 |
                    //#|  111  1111 |
                    //#|  1111  111 |
                    //#|     1   11 |
                    //#|            |
                    //  ------------
                    // Gap on right side = 3/18 = 16.7%
                    SingleLetterTests *stRight = CreateSingleLetterTests(r->next->rect, results);
                    if (stRight != NULL) {
                        SegmentList slRight = stRight->getVerticalSegments(0.75, 0.50);
                        if (slRight.size() == 2) {
                            float gap = slRight[1].startPos - slRight[0].endPos - 1;
                            if ((gap > combinedRect.size.height * 0.11))
                                newCh = 'G';
                        }
                        delete stRight;
                    }
                    
                }
                if (doit) {
                    replaceTwoWithRect(r, newCh, combinedRect, "rule 0645");
                    makeAnotherPass = true;
                }
            }
            
        
            OCRVerboseLog("OCRValidate: about to check 1-letter sequences");
            // ==================== STAGE WITH 1 LETTER SEQUENCES (one letter sequences) ========================
            
            // Elimate glued dots - no receipts really has any. Note: we should have been handling combinations with glued dots (e.g. "I." -> 'L') in the 2 or 3 letter combos above, but just to be on the safe side, defer the removal of glued dots to round 2
			if ((r->ch=='.') && (r->previous != NULL) && (r->previous->ch != ' ') && (rectSpaceBetweenRects(r->previous->rect, r->rect) <= results->globalStats.averageWidthDigits.average * 0.12)) {
                if (round == 0) {
                    makeAnotherPass = true;
                } else {
#if DEBUG
                    CGRect combinedRect = CreateCombinedRect(r->previous->rect, r->rect);
                    SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
                    if (st != NULL) delete st;
                    DebugLog("Got it");
#endif
                    ReplacingLog("ValidateLine: rule 0659 removing glued dot after [%c] in word [%s]", (unsigned short)r->previous->ch, toUTF8(r->word->text()).c_str());
                    SmartPtr<OCRRect> p = r->next;
                    r->word->removeLetter(r);
                    r = p; continue;
                }
			} else if ((r->ch=='.') && (r->next != NULL) && (r->next->ch != ' ') && (rectSpaceBetweenRects(r->rect, r->next->rect) <= results->globalStats.averageWidthDigits.average * 0.12)) {
                if (round == 0) {
                    makeAnotherPass = true;
                } else {
#if DEBUG
                    CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                    SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
                    if (st != NULL) delete st;
                    DebugLog("Got it");
#endif
                    ReplacingLog("ValidateLine: rule 0659 removing glued dot before [%c] in word [%s]", (unsigned short)r->next->ch, toUTF8(r->word->text()).c_str());
                    SmartPtr<OCRRect> p = r->next;
                    r->word->removeLetter(r);
                    r = p; continue;
                }
			}
            
            
            // '.' instead of '+', see https://drive.google.com/open?id=0B4jSQhcYsC9VYTlnSUZCQWpjZTQ (in "DRTS. HCVIEV", corrected to "DRTS. HONEV")
            // Height was 9/14.53 (62%)
            if (((r->ch == '.') || (r->ch == '-') || (r->ch == '4')) && (r->rect.size.height > results->globalStats.averageHeightDigits.average * 0.40) && (r->rect.size.height < results->globalStats.averageHeightDigits.average * 0.75)) {
                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                if (st != NULL) {
                    SegmentList slRight = st->getVerticalSegments(0.90, 0.20);
                    SegmentList slLeft = st->getVerticalSegments(0.10, 0.20);
                    SegmentList slTop = st->getHorizontalSegments(0.10, 0.20);
                    SegmentList slBottom = st->getHorizontalSegments(0.90, 0.20);
                    if ((slRight.size() == 1) && (slLeft.size() == 1) && (slTop.size() == 1) && (slRight.size() == 1)
                        && (slLeft[0].startPos > r->rect.size.height * 0.20)
                        && (slLeft[0].endPos + 1 < r->rect.size.height * 0.80)
                        && (slRight[0].startPos > r->rect.size.height * 0.20)
                        && (slLeft[0].endPos + 1 < r->rect.size.height * 0.80)
                        && (slTop[0].startPos > r->rect.size.width * 0.20)
                        && (slTop[0].endPos + 1 < r->rect.size.width * 0.80)
                        && (slBottom[0].startPos > r->rect.size.width * 0.20)
                        && (slBottom[0].endPos + 1 < r->rect.size.width * 0.80)) {
                        wchar_t newCh = '+';
                        ReplacingLog("ValidateLine: rule 0648 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                        r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                        makeAnotherPass = true;
                    }
                    delete st;
                }
            }
            
#if DEBUG
        if ((r->ch=='X') && (r->next != NULL) && (r->next->ch==' ')) {
//            CGRect newRect = computeCapturingRectRight(r, statsWithoutCurrent, results);
            SingleLetterTests *st = CreateSingleLetterTests(r->rect, results); if (st != NULL) delete st;
            DebugLog("Found it in [%s]", toUTF8(r->word->text()).c_str());
            DebugLog("");
        }
#endif
            
            //  ---------------
            //0|               |
            //1|    111     11 |
            //2|   1111    111 |
            //3|  111111   11  |
            //4|  111111  11   |
            //5|  111111  111  |
            //6|  111111 1111  |
            //7|  11 111 111   |
            //8|  11 1111111   |
            //9|  111111111    |
            //a|  11111111     |
            //b|  11111111     |
            //c|  11111111     |
            //d|    11111      |
            //e|     11111     |
            //f|     1111111   |
            //#|     1111111   |
            //#|     11111111  |
            //#|    111111111  |
            //#|    111111111  |
            //#|   1111111111  |
            //#|  11111111111  |
            //#|  111  111111  |
            //#|  11   111111  |
            //#| 111   111111  |
            //#| 111   11111   |
            //#|  1     1111   |
            //#|          1    |
            //#|               |
            //  ---------------
            // 'X' instead of '%' (at end of line of before space) PQ912
            if ((r->ch == 'X') && ((r->next == NULL) || (r->next->ch == ' ')) && !(r->flags7 & FLAGS7_TESTED_AS_PERCENT)) {
                bool doit = false; wchar_t newCh = '\0';
                r->flags7 |= FLAGS7_TESTED_AS_PERCENT;
                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                if (st != NULL) {
                    SegmentList slTop = st->getHorizontalSegments(0.15, 0.05);
                    SegmentList slBottom = st->getHorizontalSegments(0.85, 0.05);
                    if ((slTop.size() >= 2) && (slBottom.size() >= 2)) {
                        float widthTopLeftBranch = slTop[(int)slTop.size()-2].endPos - slTop[0].startPos + 1;
                        float widthTopRightBranch = slTop[(int)slTop.size()-1].endPos - slTop[(int)slTop.size()-1].startPos + 1;
                        float widthBottomLeftBranch = slBottom[0].endPos - slBottom[0].startPos + 1;
                        float widthBottomRightBranch = slBottom[(int)slBottom.size()-1].endPos - slBottom[1].startPos + 1;
                        if ((widthTopLeftBranch > widthTopRightBranch * 1.5)
                            && (widthBottomRightBranch > widthBottomLeftBranch * 1.5)
                            && (widthTopLeftBranch > widthBottomLeftBranch * 1.5)
                            && (widthBottomRightBranch > widthTopRightBranch * 1.5)) {
                            doit = true;
                            newCh = '%';
                        }
                    }
                    delete st;
                }
                if (doit && (newCh != '\0')) {
                    ReplacingLog("ValidateLine: rule 0675 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                    makeAnotherPass = true;
                }
            }
            
            
            // Eliminate spurious quote above comma
            if (isQuote(r->ch) && (r->next != NULL) && (r->next->ch == ',')
                // Comma overlaps at least 75% of quote width
                && (rectSpaceBetweenRects(r->rect, r->next->rect) < r->rect.size.width * 0.75)
                // Too small compared to the comma
                && (r->rect.size.height < r->next->rect.size.height * 0.70)
                && !OCRLine::isPresentInLineBeforeRect('\'', r)) {
                ReplacingLog("ValidateLine: rule 0299 replacing eliminating spurious quote in word [%s]", toUTF8(r->word->text()).c_str());
                SmartPtr<OCRRect> p = r->next; // Save r->next
                r->word->removeLetter(r);
                r = p; if (r == NULL) continue;
                makeAnotherPass = true;
            }
            
#if DEBUG
            if ((r->ch=='H') && (r->word->text() == L"HID. 694542 TID:001 RRN: 311215"))  {
                //CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                if (st != NULL) delete st;
                DebugLog("Found in [%s]", toUTF8(r->word->text()).c_str());
                DebugLog("");
            }
#endif

            // 'H' instead of 'W', see YELLOH in https://drive.google.com/open?id=0B4jSQhcYsC9VS0luaTdJcGdNbGM (blur radius 6)
            if ((r->ch == 'H') && !(r->flags7 & FLAGS7_TESTED_AS_DISCONNECTED_UPPERCASE_ALL)) {
                r->flags7 |= FLAGS7_TESTED_AS_DISCONNECTED_UPPERCASE_ALL;
                wchar_t newCh = testForUppercase(r, r->rect, results, false);
                if ((newCh != '\0') && (newCh != 'H')) {
                    ReplacingLog("ValidateLine: rule 0680 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                }
            }

            //  ---------------
            //0|               |
            //1| 11  111111111 |
            //2| 1111111111111 |
            //3| 111 111 11111 |
            //4| 1        1111 |
            //5| 1        111  |
            //6|          11   |
            //7|         111   |
            //8|        111    |
            //9|       111     |
            //a|       111     |
            //b|      111      |
            //c|     111       |
            //d|     11        |
            //e|    111        |
            //f|   111         |
            //#|   111         |
            //#|  11111     1  |
            //#|  111111111111 |
            //#|  11111111111  |
            //#|               |
            //  ---------------
            // '2' instead of 'Z'
            // Wide top is 2 out of 19 => 10.5%
            if ((r->ch == '2') && !(r->flags3 & FLAGS3_TESTED_AS_Z) && (results->imageTests) && (results->retailerParams.noProductNumbers)) {
                r->flags3 |= FLAGS3_TESTED_AS_Z;
                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                if (st != NULL) {
                    SegmentList slTop = st->getHorizontalSegments(0.0525, 0.105);
                    if ((slTop.size() == 1) && (slTop[0].endPos - slTop[0].startPos + 1 > r->rect.size.width * 0.90)) {
                        //  --------------
                        //0|              |
                        //1|   11111111   |
                        //2| 11111111111  |
                        //3| 11111  11111 |
                        //4| 1111    1111 |
                        //5|   1      111 |
                        //6|          111 |
                        //7|          111 |
                        //8|         1111 |
                        //9|        11111 |
                        //a|      111111  |
                        //b|     111111   |
                        //c|     11111    |
                        //d|   11111      |
                        //e|  11111       |
                        //f| 11111        |
                        //#| 11111        |
                        //#| 111111111111 |
                        //#| 111111111111 |
                        //#| 11111111111  |
                        //#|              |
                        //  --------------
                        // Avoid replacing the above: require that left or right sides start at very top
                        SegmentList slVeryTop = st->getHorizontalSegments(0.00, 0.00);
                        if ((slVeryTop.size() >= 1)
                            && ((slVeryTop[0].startPos < r->rect.size.width * 0.10)
                                || (r->rect.size.width - slVeryTop[(int)slVeryTop.size()-1].endPos - 1 < r->rect.size.width  * 0.10))) {
                            char newCh = 'Z';
                            ReplacingLog("ValidateLine: rule 0644 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                            r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                        }
                    }
                    delete st;
                }
            }
            
//#if DEBUG
//        if ((r->ch =='J') && (r->previous != NULL) && (r->previous->ch == 'A') && (r->next != NULL) && (r->next->ch =='M')) {
//            SingleLetterTests *st = CreateSingleLetterTests(r->rect, results); if (st != NULL) delete st;
//            DebugLog("Found in [%s]", toUTF8(line->text()).c_str());
//            DebugLog("");
//        }
//#endif

            //  -----------
            //0|           |
            //1|   11  11  |
            //2|  1111  11 |
            //3| 1 11111 1 |
            //4|     111   |
            //5|     111   |
            //6|     111   |
            //7|     111   |
            //8|     111   |
            //9|     111   |
            //a|     111   |
            //b|     111   |
            //c|     111   |
            //d|     111   |
            //e|     111   |
            //f|      11   |
            //#|     111   |
            //#|     111   |
            //#|      11   |
            //#|      11   |
            //#|     111   |
            //#|     111   |
            //#|     111   |
            //#|     111   |
            //#|     111   |
            //#|     11    |
            //#|      1    |
            //#|           |
            //  -----------
            // 'J' instead of 'T', see OAJMEAL in https://drive.google.com/open?id=0B4jSQhcYsC9VMzU3cEhxeGx0dlk
            if ((r->ch == 'J') && !(r->flags7 & FLAGS7_TESTED_AS_T)) {
                if (round == 0) {
                    makeAnotherPass = true;
                } else {
                    r->flags7 |= FLAGS7_TESTED_AS_T;
                    wchar_t newCh = '\0';
                    bool doit = false;
                    SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                    if (st != NULL) {
                        SegmentList slTop = st->getHorizontalSegments(0.10, 0.20);
                        SegmentList slBottom25 = st->getHorizontalSegments(0.875, 0.25);
                        if ((slTop.size() >= 1) && (slBottom25.size() >= 1)) {
                            float widthTop = totalWidth(slTop);
                            float widthBottom = totalWidth(slBottom25);
                            float rightGapBottomRelativeToTop = slTop[(int)slTop.size()-1].endPos - slBottom25[(int)slBottom25.size()-1].endPos;
                            float leftGapBottomRelativeToTop = slBottom25[0].startPos - slTop[0].startPos;
                            if ((widthTop > r->rect.size.width * 0.80)
                                && (widthBottom < r->rect.size.width * 0.50)
                                && (rightGapBottomRelativeToTop >= r->rect.size.width * 0.20)
                                && (leftGapBottomRelativeToTop >= r->rect.size.width * 0.20)) {
                                doit = true;
                                newCh = 'T';
                            }
                        }
                        delete st;
                    }
                    if (doit && (newCh != '\0')) {
                        ReplacingLog("ValidateLine: rule 0665 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                        r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                        makeAnotherPass = true;
                    }
                }
            }
            
#if DEBUG
            // EEI
			if ((r->ch=='I') && (r->previous != NULL) && (r->previous->ch =='E') && (r->previous->previous != NULL) && (r->previous->previous->ch =='E')) {
                //CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                CGRect combinedRect = computeCapturingRectRight(r, statsWithoutCurrent, results);
                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results); if (st != NULL) delete st;
                DebugLog("Found in word [%s]", toUTF8(r->word->text()).c_str());
				DebugLog("Got it");
			}
#endif
            
            //  ------------
            //0|            |
            //1|  1         |
            //2|  11        |
            //3|  11        |
            //4|  11        |
            //5| 111        |
            //6| 111        |
            //7| 111        |
            //8| 111        |
            //9| 111        |
            //a|  11        |
            //b|  11        |
            //c|  11        |
            //d|  11        |
            //e|  11        |
            //f|  11        |
            //#|  11        |
            //#|  11        |
            //#|  11        |
            //#|  11        |
            //#|  11111     |
            //#|  11111 1 1 |
            //#|  11111   1 |
            //#|            |
            //  ------------
            // r->rect only included the pattern on the left
            // 'I' instead of 'L', see "STEEI" in https://drive.google.com/open?id=0B4jSQhcYsC9VTHl2X0tjbC13Nlk
            if (isVerticalLine(r->ch)) {
                bool doit = false;
                wchar_t newCh = '\0';
                CGRect newRect = r->rect;
                // Before we try to detect pixels on the right side, make sure the base of the pattern is wider on the right + next letter is not touching
                if ((r->next == NULL)
                    || (r->next->ch == ' ')
                    || (rectSpaceBetweenRects(r->rect, r->next->rect) > 0)) {
                    if (round == 0) {
                        makeAnotherPass = true;
                    } else {
                    
                        //  --------------
                        //0|              |
                        //1|      111     |
                        //2|     1111     |
                        //3|  111  11     |
                        //4| 111   11     |
                        //5| 11    11     |
                        //6|  1    11     |
                        //7|       11     |
                        //8|       11     |
                        //9|       11     |
                        //a|       11     |
                        //b|       11     |
                        //c|       11     |
                        //d|       11     |
                        //e|       11     |
                        //f|       11     |
                        //#| 111111111111 |
                        //#| 111111111111 |
                        //#|              |
                        //  --------------
                        // Do NOT replace the above!
                        SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                        if (st != NULL) {
                            SegmentList slTop = st->getHorizontalSegments(0.10, 0.20);
                            SegmentList slMiddle = st->getHorizontalSegments(0.50, 0.20);
                            SegmentList slBottom = st->getHorizontalSegments(0.90, 0.20);
                            if ((slTop.size() == 1) && (slBottom.size() == 1) && (slMiddle.size() == 1)) {
                                float gapBottomRightRelativeToToMiddle = slBottom[0].endPos - slMiddle[0].endPos;
                                float gapBottomRightRelativeToTopRight = slBottom[0].endPos - slTop[0].endPos;
                                float gapBottomLeftRelativeToToMiddle = slMiddle[0].startPos - slBottom[0].startPos;
                                if ((gapBottomRightRelativeToToMiddle > r->rect.size.width * 0.20)
                                    && (gapBottomRightRelativeToTopRight > r->rect.size.width * 0.20)
                                    && (gapBottomRightRelativeToToMiddle > gapBottomLeftRelativeToToMiddle * 2)) {
                                    CGRect rightRect = computeCapturingRectRight(r, statsWithoutCurrent, results);
                                    if (testAsL(r, rightRect, results, true)) {
                                        doit = true; newCh = 'L'; newRect = rightRect;
                                    }
                                }
                            }
                            delete st;
                        }
                    }
                }
                if (doit && (newCh != '\0')) {
                    ReplacingLog("ValidateLine: rule 0666 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, newRect);
                    makeAnotherPass = true;
                }
			}
            
#if DEBUG
            if ((r->ch=='R') && (r->next != NULL) && (r->next->ch=='E') && (r->previous != NULL) && (r->previous->ch=='T'))  {
                //CGRect newRect = computeCapturingRectLeft(r, statsWithoutCurrent, results);
                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                if (st != NULL) delete st;
                DebugLog("Found in [%s]", toUTF8(r->word->text()).c_str());
                DebugLog("");
            }
#endif

            //  --------------
            //0|              |
            //1|     11       |
            //2|    11111     |
            //3|   1111111    |
            //4|  1111 1111   |
            //5| 111    1111  |
            //6| 11       11  |
            //7| 11       11  |
            //8| 11       11  |
            //9| 11       11  |
            //a| 11111111111  |
            //b| 11111111111  |
            //c| 111     111  |
            //d| 11       11  |
            //e| 11       11  |
            //f| 11       11  |
            //#| 11       11  |
            //#| 11       11  |
            //#| 11       111 |
            //#| 11       111 |
            //#| 11       11  |
            //#| 11           |
            //#|              |
            //  --------------
            // 'R' instead of 'A', see CVS https://drive.google.com/open?id=0B4jSQhcYsC9VU1U3OG1EY0V0NlE
            
            //  -------------
            //0|             |
            //1|       11    |
            //2|  11111111   |
            //3|  11111111   |
            //4| 111      11 |
            //5| 111      11 |
            //6| 111      11 |
            //7| 111      11 |
            //8| 111      11 |
            //9| 111      11 |
            //a| 11      111 |
            //b| 111    111  |
            //c|  111111111  |
            //d| 1111 111    |
            //e| 111   11    |
            //f| 111   11    |
            //#| 11    111   |
            //#| 11    111   |
            //#| 11     11   |
            //#| 11      11  |
            //#| 111     11  |
            //#| 11      111 |
            //#| 11      111 |
            //#| 11       1  |
            //#|             |
            //  -------------
            // Careful with this one: has aceptable gaps on top / left, but also has a suspicious large indent on right side
            
            //  -----------
            //0|           |
            //1|    111    |
            //2|  111111   |
            //3| 11111111  |
            //4| 111  111  |
            //5|  1    11  |
            //6| 11    11  |
            //7| 11    11  |
            //8| 111  111  |
            //9| 1111111   |
            //a| 1111111   |
            //b| 111 111   |
            //c| 111  11   |
            //d| 111  111  |
            //e| 111  111  |
            //f| 111   111 |
            //#| 111  1111 |
            //#| 111   11  |
            //#|           |
            //  -----------
            // Careful with this one
            
            if ((r->ch == 'R') && (results->imageTests) && !(r->flags2 & FLAGS2_TESTED_AS_A)) {
                r->flags2 |= FLAGS2_TESTED_AS_A;
                // In above pattern the "hat" is in range 0-3 out of height 21 (14%)
                bool doit = false;
                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                if (st != NULL) {
                    // First test that we DON'T have a large indentation on the right side
                    if (!hasRightRIndent(r->rect, st, true)) {
                        SegmentList slTop = st->getHorizontalSegments(0.01, 0.01);
                        SegmentList slTop6 = st->getHorizontalSegments(0.06, 0.01);
                        SegmentList slTop12 = st->getHorizontalSegments(0.12, 0.01);
                        if ((slTop.size() == 1) && (slTop6.size() >= 1) && (slTop12.size() >= 1)) {
                            float gapLeftTop = slTop[0].startPos, gapRightTop = r->rect.size.width - slTop[0].endPos - 1;
                            float gapLeftTop6 = slTop6[0].startPos, gapRightTop6 = r->rect.size.width - slTop6[slTop6.size()-1].endPos - 1;
                            float gapLeftTop12 = slTop12[0].startPos, gapRightTop12 = r->rect.size.width - slTop12[slTop12.size()-1].endPos - 1;
                            if ((gapLeftTop > r->rect.size.width * 0.25)
                                && (gapRightTop > r->rect.size.width * 0.25)
                                && (gapLeftTop6 > r->rect.size.width * 0.10)
                                && (gapRightTop6 > r->rect.size.width * 0.10)
                                && (gapLeftTop12 > r->rect.size.width * 0.05)
                                && (gapRightTop12 > r->rect.size.width * 0.05)
                                && (gapRightTop >= gapRightTop6) && (gapLeftTop >= gapLeftTop6)
                                && (gapRightTop6 >= gapRightTop12) && (gapLeftTop6 >= gapLeftTop12)
                                && (gapRightTop > gapRightTop12) && (gapLeftTop > gapLeftTop12))
                                    doit = true;
                            // Or, be less strict about the magnitude of the gaps (smaller on top ... none on the 12% level) as long as the gaps are strictly decreasing (not >=)
                            //  ------------
                            //0|            |
                            //1|    111     |
                            //2|   111111   |
                            //3| 111   111  |
                            //4| 11     11  |
                            //5| 11     11  |
                            //6| 11     11  |
                            //7| 111111111  |
                            //8| 111111111  |
                            //9| 11     11  |
                            //a| 11     11  |
                            //b| 11     11  |
                            //c| 11     11  |
                            //d| 11     11  |
                            //e| 11     111 |
                            //f| 11     11  |
                            //#|            |
                            //  ------------
                            
                            else if ((gapLeftTop > r->rect.size.width * 0.20)
                                && (gapRightTop > r->rect.size.width * 0.20)
                                && (gapLeftTop6 > r->rect.size.width * 0.05)
                                && (gapRightTop6 > r->rect.size.width * 0.05)
                                // Below test weeds out the above pattern (found in https://drive.google.com/open?id=0B4jSQhcYsC9VdWtwVEtGakpwbmc, BLACKBERRIES product)
                                && !((gapLeftTop < gapRightTop) && (gapLeftTop6 < gapRightTop6))
                                && (gapRightTop > gapRightTop6) && (gapLeftTop > gapLeftTop6)
                                && (gapRightTop6 > gapRightTop12) && (gapLeftTop6 > gapLeftTop12)
                                && (gapRightTop > gapRightTop12) && (gapLeftTop > gapLeftTop12))
                                    doit = true;
                        }
                    } // No indent on right side
                    delete st;
                }
                if (doit) {
                    char newCh = 'A';
                    ReplacingLog("ValidateLine: rule 0636 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                    makeAnotherPass = true;
                }
            }
            
#if DEBUG
            if ((r->ch=='R') && (r->previous != NULL) && (r->next != NULL) && (r->next->ch=='E') && (r->next->next != NULL) && (r->next->next->ch == 'D'))  {
                //CGRect newRect = computeCapturingRectLeft(r, statsWithoutCurrent, results);
                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                if (st != NULL) delete st;
                DebugLog("Found in [%s]", toUTF8(r->word->text()).c_str());
                DebugLog("");
            }
#endif
            
            //  ---------
            //0|         |
            //1|  11   1 |
            //2|  1   11 |
            //3|  1   1  |
            //4|  1  11  |
            //5|  1  1   |
            //6|  1111   |
            //7|  11 11  |
            //8|  1  11  |
            //9|  1   11 |
            //a| 111   1 |
            //b|  11   1 |
            //c|         |
            //  ---------
            // 'R' instead of 'K', see "NRBED" instead of "NAKED" in https://drive.google.com/open?id=0B4jSQhcYsC9VLWNSTXFPalQ1bkU (apparently we first convert the 'B' to 'R')
            // Test presence of wide gap on top (and a little below that) + deep enough opening on top. Here gap = 3/6 (50%)
            if (((r->ch == 'R') || (r->ch == 'A')) && !(r->flags3 & FLAGS3_TESTED_AS_K)) {
                r->flags3 |= FLAGS3_TESTED_AS_K;
                bool doit = false;
                wchar_t newCh = '\0';
                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                if (st != NULL) {
                    SegmentList slTop = st->getHorizontalSegments(0.00, 0.00);
                    float gapTop = largestGap(slTop);
                    float widthTop = totalWidth(slTop);
                    SegmentList slTop15 = st->getHorizontalSegments(0.15, 0.00);
                    float widthTop15 = totalWidth(slTop15);
                    float gapTop15 = largestGap(slTop15);
                    //  -----------
                    //0|           |
                    //1| 11    1   |
                    //2| 111 1111  |
                    //3| 11    111 |
                    //4| 11     11 |
                    //5| 11      1 |
                    //6| 11     11 |
                    //7| 11     11 |
                    //8| 11    111 |
                    //9| 11111111  |
                    //a| 111  11   |
                    //b| 11   11   |
                    //c| 11   11   |
                    //d| 11    11  |
                    //e| 11    11  |
                    //f| 11    111 |
                    //#| 11     11 |
                    //#| 11     11 |
                    //#| 1      11 |
                    //#|           |
                    //  -----------
                    // Don't trigger in this case by testing top15 wider than top
                    if ((gapTop > r->rect.size.width * 0.25) && (gapTop15 > r->rect.size.width * 0.25)
                        && (widthTop > widthTop15)) {
                            OpeningsTestResults res;
                            bool success = st->getOpenings(res, SingleLetterTests::Top,
                                    0.00,      // Start of range to search (top/left)
                                    1.00,      // End of range to search (bottom/right)
                                    SingleLetterTests::Bound,   // Require start (top/left) bound
                                    SingleLetterTests::Bound  // Require end (bottom/right) bound
                                );
                            if (success && (res.maxDepth > r->rect.size.height * 0.20)) {
                                newCh ='K';
                                doit = true;
                            }
                    }
                    delete st;
                }
                if (doit && (newCh != '\0')) {
                    ReplacingLog("ValidateLine: rule 0649 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                    makeAnotherPass = true;
                }
            }
            
#if DEBUG
            if ((r->ch=='2') && (r->previous != NULL) && ((r->previous->ch=='0') || (r->previous->ch=='O')) && (r->previous->previous != NULL) && (r->previous->previous->ch=='2'))  {
                //CGRect newRect = computeCapturingRectLeft(r, statsWithoutCurrent, results);
                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                if (st != NULL) delete st;
                DebugLog("Found in [%s]", toUTF8(r->word->text()).c_str());
                DebugLog("");
            }
#endif
            
            //  ------------
            //0|            |
            //1|    1   1   |
            //2| 1111111111 |
            //3|  111111111 |
            //4|        111 |
            //5|        111 |
            //6|       111  |
            //7|       11   |
            //8|      111   |
            //9|     111    |
            //a|    1111    |
            //b|    111     |
            //c|   111      |
            //d|   11       |
            //e|  11        |
            //f|  11        |
            //#| 111        |
            //#| 1111111111 |
            //#| 1111111111 |
            //#|            |
            //  ------------
            
            // TODO : avoid flagging this as a 'Z':
            //  ---------------
            //0|               |
            //1|     11111111  |
            //2|  11111111111  |
            //3| 111111  11111 |
            //4| 111111   1111 |
            //5|  111      111 |
            //6|            1  |
            //7|           11  |
            //8|          111  |
            //9|         1111  |
            //a|         1111  |
            //b|       1111    |
            //c|       1111    |
            //d|      1111     |
            //e|     1111      |
            //f|    1111       |
            //#|    11         |
            //#|   111         |
            //#|  1111         |
            //#| 111111   111  |
            //#| 111111111111  |
            //#| 111111111111  |
            //#|           11  |
            //#|               |
            //  ---------------

// Replaced with more lax test
//            // '2' instead of 'Z', see CVS https://drive.google.com/open?id=0B4jSQhcYsC9VcG5WSnFLNmNPTUU
//            if ((r->ch == '2') && (results->imageTests)) {
//                bool doit = hasFlatTop(r->rect, results);
//                if (doit) {
//                    char newCh = 'Z';
//                    ReplacingLog("ValidateLine: rule 0638 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
//                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
//                    makeAnotherPass = true;
//                }
//            }
            
            //  ------------
            //0|            |
            //1|   11  11   |
            //2|  111  111  |
            //3|  111  1111 |
            //4|  111   111 |
            //5|  111   111 |
            //6|  111   111 |
            //7|  111   111 |
            //8|  111   111 |
            //9|  111  1111 |
            //a|  111  1111 |
            //b|   1   1111 |
            //c|       1111 |
            //d|       111  |
            //e|       111  |
            //f|       111  |
            //#|  11  1111  |
            //#|  111 111   |
            //#|  111 111   |
            //#|   1  11    |
            //#|            |
            //  ------------
            // 'J' instead of '9'
            
            if ((r->ch == 'J') && ((statsWithoutCurrent->averageWidthDigits.count == 0) || (r->rect.size.width < statsWithoutCurrent->averageWidthDigits.average * 0.85)) && ((statsWithoutCurrent->averageWidthUppercase.count == 0) || (r->rect.size.width < statsWithoutCurrent->averageWidthUppercase.average * 0.85)) && (!(r->flags3 & FLAGS3_TESTED_AS_DISCONNECTED_DIGIT9) || !(r->flags4 & FLAGS4_TESTED_AS_DISCONNECTED_DIGIT8)) && ((r->previous == NULL) || (r->previous->ch == ' ') || (rectSpaceBetweenRects(r->previous->rect, r->rect) > statsWithoutCurrent->averageSpacing.average * 1.10))) {
                bool doit = true;
                CGRect newRect = computeCapturingRectLeft(r, statsWithoutCurrent, results);
                if (doit) {
                    r->flags3 |= FLAGS3_TESTED_AS_DISCONNECTED_DIGIT9;
                    wchar_t newCh = testAsDisconnectedDigit(r, newRect, statsWithoutCurrent, results, '9', '\0', false, 1, true); // Indicate we are working with a single rect
                    if ((newCh == '\0') && !(r->flags4 & FLAGS4_TESTED_AS_DISCONNECTED_DIGIT8)) {
                        r->flags4 |= FLAGS4_TESTED_AS_DISCONNECTED_DIGIT8;
                        newCh = testAsDisconnectedDigit(r, newRect, statsWithoutCurrent, results, '8', '\0', false, 1, true); // Indicate we are working with a single rect
                    }
                    if (newCh != '\0') {
                        ReplacingLog("ValidateLine: rule 0583 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                        // Calculate correct rect
                        CGRect adjustedRect = computeTrimmedRect(newRect, results);
                        r->word->updateLetterWithNewCharAndNewRect(r, newCh, adjustedRect);
                        makeAnotherPass = true;
                    }
                }
            }
            
//#if DEBUG
//            if ((r->ch=='/') && (r->previous != NULL) && (r->previous->ch=='0') && (r->next != NULL) && (r->next->ch=='1'))  {
//                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
//                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
//                if (st != NULL) delete st;
//                DebugLog("Found in [%s]", toUTF8(r->word->text()).c_str());
//                DebugLog("");
//            }
//#endif
            
            //  ----------
            //0|          |
            //1|      111 |
            //2|     1111 |
            //3|     1111 |
            //4|     1111 |
            //5|   1  111 |
            //6|  11  111 |
            //7|  11  111 |
            //8| 111  111 |
            //9| 111  111 |
            //a| 111  111 |
            //b| 111  111 |
            //c| 111 1111 |
            //d| 11  1111 |
            //e|     1111 |
            //f|     111  |
            //#|     111  |
            //#|     111  |
            //#|          |
            //  ----------
            // 'I' instead of '4'
            if ((r->ch == 'I') && ((statsWithoutCurrent->averageWidthDigits.count == 0) || (r->rect.size.width < statsWithoutCurrent->averageWidthDigits.average * 0.85)) && ((statsWithoutCurrent->averageWidthUppercase.count == 0) || (r->rect.size.width < statsWithoutCurrent->averageWidthUppercase.average * 0.85)) && !(r->flags3 & FLAGS3_TESTED_AS_DISCONNECTED_DIGIT4) && ((r->previous == NULL) || (r->previous->ch == ' ') || (rectSpaceBetweenRects(r->previous->rect, r->rect) > statsWithoutCurrent->averageSpacing.average * 1.10))) {
                bool doit = true;
                CGRect newRect = computeCapturingRectLeft(r, statsWithoutCurrent, results);
                if (doit) {
                    r->flags3 |= FLAGS3_TESTED_AS_DISCONNECTED_DIGIT4;
                    wchar_t newCh = testAsDisconnectedDigit(r, newRect, statsWithoutCurrent, results, '4', '\0', false, false, true); // Indicate we are working with a single rect
                    if (newCh != '\0') {
                        ReplacingLog("ValidateLine: rule 0586 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                        r->word->updateLetterWithNewCharAndNewRect(r, newCh, newRect);
                        makeAnotherPass = true;
                    }
                }
            }
            
#if DEBUG
            // 21203CJ884
            if ((r->ch=='3') && (r->previous != NULL) && (r->previous->ch=='0') && (r->previous->previous != NULL) && (r->previous->previous->ch=='2') && (r->previous->previous->previous != NULL) && (r->previous->previous->previous->ch=='1'))  {
                CGRect combinedRect = computeCapturingRectLeft(r, statsWithoutCurrent, results);
//                if ((r->previous != NULL) && (r->previous->ch != ' ')) {
//                    float newOrigin = rectRight(r->previous->rect) + 1;
//                    combinedRect.size.width = rectRight(combinedRect) - newOrigin + 1;
//                    combinedRect.origin.x = newOrigin;
//                } else {
//                    float oldEnd = rectRight(combinedRect);
//                    combinedRect.origin.x = rectRight(combinedRect) - results->globalStats.averageWidthDigits.average * 1.15 + 1;
//                    if (rectLeft(combinedRect) < rectLeft(results->imageRange))
//                        combinedRect.origin.x = rectLeft(results->imageRange);
//                        combinedRect.size.width = oldEnd - combinedRect.origin.x + 1;
//                }
                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
                if (st != NULL) delete st;
                DebugLog("Found in [%s]", toUTF8(r->word->text()).c_str());
                DebugLog("");
            }
#endif
            
            //  ----------
            //0|          |
            //1|      111 |
            //2|     1111 |
            //3|     1111 |
            //4|     1111 |
            //5|   1  111 |
            //6|  11  111 |
            //7|  11  111 |
            //8| 111  111 |
            //9| 111  111 |
            //a| 111  111 |
            //b| 111  111 |
            //c| 111 1111 |
            //d| 11  1111 |
            //e|     1111 |
            //f|     111  |
            //#|     111  |
            //#|     111  |
            //#|          |
            //  ----------
            // '3' instead of '8'
            if ((r->ch == '3') && !(r->flags4 & FLAGS4_TESTED_AS_DISCONNECTED_DIGIT8)) {
            CGRect newRect = computeCapturingRectLeft(r, statsWithoutCurrent, results);
                r->flags4 |= FLAGS3_TESTED_AS_DISCONNECTED_DIGIT4;
                wchar_t newCh = testAsDisconnectedDigit(r, newRect, statsWithoutCurrent, results, '8', '\0', false, false, true); // Indicate we are working with a single rect
                if (newCh != '\0') {
                    ReplacingLog("ValidateLine: rule 0586 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, newRect);
                    makeAnotherPass = true;
                }
            }
            
#if DEBUG
            if ((r->ch=='4') && (r->next != NULL) && isVerticalLine(r->next->ch) && (r->previous != NULL) && (r->previous->ch==' ') && (r->previous->previous != NULL) && (r->previous->previous->ch=='D'))  {
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
                if (st != NULL) delete st;
                DebugLog("Found in [%s]", toUTF8(r->word->text()).c_str());
                DebugLog("");
            }
#endif
            
            //2016-02-25 13:54:34.394 Windfall[55399:5485004] #314: 9 quality: 87 [381,218 - 390,234] w=10,h=17]
            //2016-02-25 13:54:34.395 Windfall[55399:5485004] #315: 4 quality: 45 [393,221 - 397,230] w=5,h=10]
            //2016-02-25 13:54:34.395 Windfall[55399:5485004] #316: I quality: 86 [399,218 - 401,234] w=3,h=17]
            // "4I" instead of '4', see https://drive.google.com/open?id=0B4jSQhcYsC9VTEtDZ29PVXNTSms
            if ((r->ch == '4') && (r->next != NULL) && isVerticalLine(r->next->ch) && !(r->flags3 & FLAGS3_TESTED_AS_DISCONNECTED_DIGIT4)) {
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                if ((combinedRect.size.width < results->globalStats.averageWidthDigits.average * 1.15)
                    && ((statsWithoutCurrentAndNext->averageWidthDigits.count < 3) || (combinedRect.size.width < statsWithoutCurrentAndNext->averageWidthDigits.average * 1.15))) {
                    r->flags3 |= FLAGS3_TESTED_AS_DISCONNECTED_DIGIT4;
                    int nDigitsLookAlikesBefore = countDigitLookalikes(r->previous, false, results);
                    int nDigitsLookAlikesAfter = countDigitLookalikes(r->next->next, true, results);
                    int laxLevel = ((nDigitsLookAlikesBefore + nDigitsLookAlikesAfter == results->retailerParams.productNumberLen - 1)? 2:0);
                    // Also be lax if we can make a price up
                    if ((laxLevel < 2) && (r->previous != NULL) && isDigitLookalikeExtended(r->previous->ch) && (r->previous->previous != NULL) && (r->previous->previous->ch == '.') && (r->previous->previous->previous != NULL) && isDigitLookalikeExtended(r->previous->previous->previous->ch))
                        laxLevel = 2;
                    wchar_t newCh = testAsDisconnectedDigit(r, combinedRect, statsWithoutCurrent, results, '4', '\0', true, laxLevel, false);
                    if (newCh != '\0') {
                        replaceTwoWithRect(r, newCh, combinedRect, "rule 0617");
                        makeAnotherPass = true;
                    }
                }
            }

            //  -------------
            //0|             |
            //1|         11  |
            //2|         111 |
            //3|         111 |
            //4|         111 |
            //5|         111 |
            //6|    1    111 |
            //7|    11   111 |
            //8|   111   11  |
            //9|   11    11  |
            //a|   1     11  |
            //b|  1      11  |
            //c| 11      11  |
            //d| 1111    111 |
            //e| 1111    111 |
            //f| 1111    111 |
            //#|         111 |
            //#|         111 |
            //#|         111 |
            //#|         111 |
            //#|         111 |
            //#|             |
            //  -------------
            // "/1" instead of '4'
            
#if DEBUG
            if ((r->ch=='C') && (r->next != NULL) && (r->next->ch=='1') && (r->next->next != NULL) && (r->next->next->ch=='9'))  {
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
                if (st != NULL) delete st;
                DebugLog("Found in [%s]", toUTF8(r->word->text()).c_str());
                DebugLog("");
            }
#endif
            
            //2016-02-19 14:32:17.464 Windfall[41815:3579563] #105: C quality: 67 [607,76 - 613,87] w=7,h=12]
            //2016-02-19 14:32:17.465 Windfall[41815:3579563] #106: 1 quality: 74 [613,71 - 618,93] w=6,h=23]
            //2016-02-19 14:32:17.465 Windfall[41815:3579563] #107: 9 quality: 88 [622,72 - 634,93] w=13,h=22]
            // "C1" instead of '4'
            if (((r->ch == '/') || isCLookalike(r->ch)) && (r->next != NULL) && isVerticalLine(r->next->ch) && (statsWithoutCurrentAndNext->averageWidthDigits.count > 0)
                && (r->rect.size.height < statsWithoutCurrentAndNext->averageHeightDigits.average * 0.75)
                && (r->rect.size.height < results->globalStats.averageHeightDigits.average * 0.75)
                && (rectRight(r->next->rect) - rectLeft(r->rect) + 1 < statsWithoutCurrentAndNext->averageWidthDigits.average * 1.20)
                && (rectRight(r->next->rect) - rectLeft(r->rect) + 1 < results->globalStats.averageWidthDigits.average * 1.20)
                && !(r->flags3 & FLAGS3_TESTED_AS_DISCONNECTED_DIGIT4)) {
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                r->flags3 |= FLAGS3_TESTED_AS_DISCONNECTED_DIGIT4;
                int nDigitsLookAlikesBefore = countDigitLookalikes(r->previous, false, results);
                int nDigitsLookAlikesAfter = countDigitLookalikes(r->next->next, true, results);
                int laxLevel = ((nDigitsLookAlikesBefore + nDigitsLookAlikesAfter == results->retailerParams.productNumberLen - 1)? 2:0);
                wchar_t newCh = testAsDisconnectedDigit(r, combinedRect, statsWithoutCurrent, results, '4', '\0', true, laxLevel, false);
                if (newCh != '\0') {
                    replaceTwoWithRect(r, newCh, combinedRect, "rule 0611");
                    makeAnotherPass = true;
                }
            }


            // U-like next to digits -> replace with 0
            // PQPQDIGITSONLY - when we know zone is all digits, no need to require char next to digits
            if (uEquiv(r->ch)
                && digitsOnly) {
                wchar_t newCh = '0';
                ReplacingLog("ValidateLine: rule 0542 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)newCh, toUTF8(r->word->text()).c_str());
                r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                makeAnotherPass = true;
            }
            // J next to digits -> replace with 1
            else if ((r->ch == 'J') && digitsOnly
                && (((statsWithoutCurrent->averageHeightDigit1.count >= 1) && (r->rect.size.width < statsWithoutCurrent->averageHeightDigit1.average * 1.15))
                    || ((statsWithoutCurrent->averageHeightDigit1.count < 1) && (results->globalStats.averageWidthDigit1.count >= 1) && (r->rect.size.width < results->globalStats.averageHeightDigit1.average * 1.15)))) {
                wchar_t newCh = '1';
                ReplacingLog("ValidateLine: rule 0547 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)newCh, toUTF8(r->word->text()).c_str());
                r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                makeAnotherPass = true;
            }
            
            // b next to digits -> replace with 5 or 6
            if ((r->ch == 'b')
                && digitsOnly) {
                wchar_t newCh = SingleLetterTestAsDigit(r, results, statsWithoutCurrent, true);
                if ((newCh != '\0') && (newCh != r->ch)) {
                    ReplacingLog("ValidateLine: rule 0543 replacing small [%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)newCh, toUTF8(r->word->text()).c_str());
                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                    makeAnotherPass = true;
                }
            }
            
            // Eliminate noise dot above or below some letters where it has been found to cause recognition errors. Note: useful only to the extent that our code can correct that mistake otherwise little point doing that (besides perhaps adjusting stats)
            // Test only if still tall after expected removal of noise
            if ((r->ch == 'F')
                && !(r->flags4 & FLAGS4_TESTED_FOR_NOISE) && (tallHeightTest(statsWithoutCurrent.getPtr(), r->rect.size.height * 0.80, 'F', false, 1, true) != 0)) {
                r->flags4 |= FLAGS4_TESTED_FOR_NOISE;
                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results, false, 0, 0.001);
                if (st != NULL) {
                    ConnectedComponentList cpl = st->getConnectedComponents(0.001);
                    if ((cpl.size() >= 3) && (cpl[2].area < cpl[1].area * 0.10)) {
                        ConnectedComponent mainCC = cpl[1];
                        CGRect newRect (rectLeft(r->rect) + mainCC.xmin, rectBottom(r->rect)+mainCC.ymin, mainCC.getWidth(), mainCC.getHeight());
                        // Check height of new rect
                        bool doit = false;
                        char newCh = r->ch;
                        if (isUpper(r->ch) && (tallHeightTest(statsWithoutCurrent.getPtr(), newRect.size.height, 'F', false, 1, true) != 0)) {
                            // Uppercase, still tall after adjustment - OK, just adjust
                            doit = true;
                        }
                        if (doit) {
                            ReplacingLog("ValidateLine: rule 0050 replacing - adjusting rect height [%c] to remove noise in word [%s]", (unsigned short)r->ch, toUTF8(r->word->text()).c_str());
                            r->word->updateLetterWithNewCharAndNewRect(r, newCh, newRect);
                            makeAnotherPass = true;
                        }
                    }
                    delete st;
                }
            }
            
            // 'q' instead of 'o' because of dangling 'f' following
            if ((r->ch == 'q')
                && !(r->flags4 & FLAGS4_TESTED_FOR_NOISE)) {
                r->flags4 |= FLAGS4_TESTED_FOR_NOISE;
                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results, false, 0, 0.001);
                if (st != NULL) {
                    ConnectedComponentList cpl = st->getConnectedComponents(0.001);
                    if ((cpl.size() >= 3) && (cpl[2].area < cpl[1].area * 0.30)
                        // Far enough below
                        && (cpl[2].ymin - cpl[1].ymax - 1 > cpl[1].getHeight() * 0.10)) {
                        ConnectedComponent mainCC = cpl[1];
                        CGRect newRect (rectLeft(r->rect) + mainCC.xmin, rectBottom(r->rect)+mainCC.ymin, mainCC.getWidth(), mainCC.getHeight());
                        // Check height of new rect
                        bool doit = false;
                        char newCh = r->ch;
                        if ((r->ch == 'q') && (tallHeightTest(statsWithoutCurrent.getPtr(), newRect.size.height, 'F', false, 1, true) == 0)) {
                            // Now low 'q' => 'o'
                            doit = true;
                            // Verify 'o' shape
                            SingleLetterTests *stNew = CreateSingleLetterTests(newRect, results);
                            if (stNew != NULL) {
                                SegmentList midVert = stNew->getVerticalSegments(0.50, 0.00);
                                SegmentList midHor = stNew->getHorizontalSegments(0.50, 0.00);
//#if DEBUG
//                                SingleLetterPrint(midVert, newRect.size.height);
//                                SingleLetterPrint(midHor, newRect.size.width);
//#endif
                                if ((midVert.size() >= 1) && (midHor.size() >= 1)
                                    && (midVert[midVert.size()-1].endPos > newRect.size.height * 0.85)
                                    && (midVert[0].startPos < newRect.size.height * 0.10)
                                    && (midHor[midHor.size()-1].endPos > newRect.size.width * 0.85)
                                    && (midHor[0].startPos < newRect.size.width * 0.10)) {
                                    newCh = 'o';
                                }
                                delete stNew;
                            }
                        }
                        if (doit) {
                            // Still tall, OK to replace
                            ReplacingLog("ValidateLine: rule 0052 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)newCh, toUTF8(r->word->text()).c_str());
                            r->word->updateLetterWithNewCharAndNewRect(r, newCh, newRect);
                            makeAnotherPass = true;
                        }
                    }
                    delete st;
                }
            }
            
            // 'F' instead of 'P'
            if ((r->ch == 'F') && !(r->flags4 & FLAGS4_TESTED_AS_P) && (results->imageTests)) {
                r->flags4 |= FLAGS4_TESTED_AS_P;
                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results, false, SINGLE_LETTER_VALIDATE_COMP_SIZE | SINGLE_LETTER_VALIDATE_SINGLE_COMP);
                if (st != NULL) {
                    // Test we have a bubble on top
                    ConnectedComponentList invertCpl = st->getInverseConnectedComponents();
                    if (invertCpl.size() == 2) {
                        // Got hole, test location & size
                        ConnectedComponent hole = invertCpl[1];
                            // Hole wide enough
                        if ((hole.getWidth() > r->rect.size.width * 0.25)
                            // Hole center above mid-point
                            && ((hole.ymin + hole.ymax)/2 < r->rect.size.height * 0.50)) {
                            // Now test we can't find a deep bounded opening from the right side
                            OpeningsTestResults resRight;
                            bool success = st->getOpenings(resRight, SingleLetterTests::Right,
                                                           0.00,      // Start of range to search (top/left)
                                                           0.20,      // End of range to search (bottom/right)
                                                           SingleLetterTests::Bound,   // Require start (top/left) bound
                                                           SingleLetterTests::Bound  // Require end (bottom/right) bound
                                                           );
                            if (!success || (resRight.maxDepth < r->rect.size.width * 0.10)) {
                                char newCh = 'P';
                                ReplacingLog("ValidateLine: rule 0051 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)newCh, toUTF8(r->word->text()).c_str());
                                r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                                makeAnotherPass = true;
                            }
                        }
                    }
                    delete st;
                }
            }
            
            // r instead of :
            if (((r->ch == '1') || (r->ch == 'r') || ((r->ch != ':') && (r->ch != ';') && (r->rect.size.height > r->rect.size.width * 3.0))) 
                && (glued(r) == 0))
            {
                // Possibly a column
                wchar_t newCh = '\0';
                CGRect newRect;
                if ((SingleLetterTestAsColumn(r, r->rect, results, newCh, newRect) == 1.00) && (newCh != '\0') && (newCh != r->ch))
                {
                    ReplacingLog("ValidateLine: rule 0130 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)newCh, toUTF8(r->word->text()).c_str());
                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, newRect);
                    makeAnotherPass = true;                
                    r = r->next;
                    continue;
                }
            }
            
            // 'S' instead of '5'
            if ((r->ch == 'S')
                && (results->imageTests)
                // Next to digits, because this rule is very risky
                && (((r->next != NULL) && isDigit(r->next->ch)) || ((r->previous != NULL) && isDigit(r->previous->ch)))
                && !(r->flags4 & FLAGS4_TESTED_AS_5))
            {
                r->flags4 |= FLAGS4_TESTED_AS_5;
                // Taking top half in case the left side of the '5' is a bit to the right
                CGRect topHalf (rectLeft(r->rect), rectBottom(r->rect), r->rect.size.width, r->rect.size.height * 0.50);
                SingleLetterTests *st = CreateSingleLetterTests(topHalf,results, false, 0, 0.03, true);
                if (st != NULL) {
                    // Take into account a possible x offset on the left side
                    ConnectedComponentList cpl = st->getConnectedComponents();
                    float xOffset = 0;
                    if (cpl.size() > 1) {
                        xOffset = cpl[1].xmin;
                    }
                    SegmentList slLeft = st->getVerticalSegments(xOffset/r->rect.size.width + 0.025, 0.05);
//#if DEBUG
//                    SingleLetterPrint(slLeft, r->rect.size.height);
//#endif
                    if (slLeft.size() >= 1) {
                        float topLeftSegmentLength = slLeft[0].endPos - slLeft[0].startPos + 1;
                        if ((slLeft[0].startPos < r->rect.size.height * 0.10)
                               // Very long segment
                            && ((topLeftSegmentLength > r->rect.size.height * 0.35)
                               // Or 25% long but surrounded by digits
                                || ((topLeftSegmentLength > r->rect.size.height * 0.25) && (((r->next != NULL) && isDigit(r->next->ch)) || ((r->previous != NULL) && isDigit(r->previous->ch))))
                               )
                            ) {
                            char newCh = '5';
                            ReplacingLog("ValidateLine: rule 0014 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)newCh, toUTF8(r->word->text()).c_str());
                            r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                            makeAnotherPass = true;
                        }
                    }
                    delete st;
                }
            }

			if (r->ch == '1')
            {

//#if DEBUG
//			if ((r->next != NULL) && (r->next->ch =='1')) {
//				DebugLog("Found");
//			}
//#endif			
				if (r->next != NULL) 
                {
					// Eliminate abnormally thin and short '1'
					if ((statsWithoutCurrent->averageWidthDigits.count > 3)
							&& (r->rect.size.width < statsWithoutCurrent->averageWidthDigits.average * 0.33)
							&& (r->rect.size.height < statsWithoutCurrent->averageHeightDigits.average * 0.80)
							// Make sure it's not a case where the area code is using a diminutive font
							&& !(((r->next != NULL) && isDigit(r->next->ch) && (r->rect.size.height > r->next->rect.size.height * 0.90))
							      || ((r->previous != NULL) && isDigit(r->previous->ch) && (r->rect.size.height > r->previous->rect.size.height * 0.90)))
							) 
					{
                        ReplacingLog("ValidateLine: rule 0131 replacing - eliminating [%c] in word [%s]", (unsigned short)r->ch, toUTF8(r->word->text()).c_str());
                        // Replacing with ' ' if not followed or preceeded already by a space
                        if ( ((r->previous == NULL) || (r->previous->ch != ' '))
                            && ((r->next == NULL) || (r->next->ch != ' ')) ) 
                        {
                            // No space, replace letter
                            char newCh = ' ';
                            r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                            makeAnotherPass = true;
                            r = r->next;
                        } else {
                            // There is a space next, just remove
                            SmartPtr<OCRRect> p = r->next; // Save r->next
                            r->word->removeLetter(r);
                            r = p;
                        }
                        continue;	
					}
					// Replace '1' between uppercase letters with 'I'
					else if ( isUpper(r->next->ch)
					    && (r->previous != NULL) && isUpper(r->previous->ch)
					    // Require one more uppercase beyond previous & next
					    && ( ((r->previous->previous != NULL) && isUpper(r->previous->previous->ch))
							|| ((r->next->next != NULL) && isUpper(r->next->next->ch)) ) 
					    // And one more ... 
					    && ( ((r->previous->previous != NULL) && (r->previous->previous->previous != NULL) && isUpper(r->previous->previous->previous->ch))
							|| ((r->next != NULL) && (r->next->next != NULL) && (r->next->next->next != NULL) && isUpper(r->next->next->next->ch)) )
						)
					{
						if (round == 0) {
							makeAnotherPass = true;
						} else {
							ReplacingLog("Validate: special 1 in uppercase handling, replacing [%c] with [I] in word [%s]",
								 (unsigned short)r->ch, toUTF8(r->word->text()).c_str());
							r->word->updateLetterWithNewCharAndNewRect(r, 'I', r->rect);
							r->confidence = 0;					
						}
					}
					if ((r->next->ch == '>') && !OCRLine::isPresentInLineBeforeRect('<', r) && (r->rect.size.height > 0)
						// Next char ('>') bottom is at least 15% above current char base line (as percent of current char height)
						&& ((r->next->rect.origin.y - r->rect.origin.y)/r->rect.size.height > 0.15)) 
                    {
						// Replace '1>' with 'p' or 'P'
						float newWidth = rectRight(r->next->rect) - rectLeft(r->rect) + 1;
						// Adjust current rect. Use the height of the first char in this case.
						// Midpoint bottom Y location between current and next
						float newHeight = r->rect.size.height;
						float newBottom = (rectTop(r->rect) + rectTop(r->next->rect))/2 - newHeight + 1;
						CGRect newRect(rectLeft(r->rect),
													newBottom,
													newWidth,
													newHeight);
						char newCh;
						if ((r->previous != NULL) && isupper(r->previous->ch)
							&& (r->previous->rect.size.height != 0)
							// current char top is near previous letter top
							&& (abs((r->previous->rect.origin.y+r->previous->rect.size.height-1) - (r->rect.origin.y+r->rect.size.height-1))/r->previous->rect.size.height < 0.07)
							// next char top is near previous letter top
							&& (abs((r->previous->rect.origin.y+r->previous->rect.size.height-1) - (r->next->rect.origin.y+r->next->rect.size.height-1))/r->previous->rect.size.height < 0.07))
							newCh = 'P';
						else
							newCh = 'p';
						ReplacingLog("ValidateLine: rule 0132 replacing [%c%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)r->next->ch, newCh, toUTF8(r->word->text()).c_str());
						r->word->removeLetter(r->next);
						r->word->updateLetterWithNewCharAndNewRect(r, newCh, newRect);
						// Skip next char (replaced)
						r = r->next;
						if (r != NULL)
							r = r->next;
						continue;	// We don't expect other substitutions
					} else if (((r->next->ch == '\'') || (r->next->ch == '`')) && ((r->previous == NULL) || isupper(r->previous->ch) || (r->previous->ch == ' ') || ((r->next->next != NULL) && isupper(r->next->next->ch)))) {
						// "1'" at word start or before/after uppercase char => replace with 'T'
						char newCh = 'T';
						float newWidth = rectRight(r->next->rect) - rectLeft(r->rect) + 1;
						float spaceBetween = rectLeft(r->next->rect) - rectRight(r->rect) - 1;
						float spaceAfter = ((r->next->next != NULL)? rectLeft(r->next->next->rect) - rectRight(r->next->rect) - 1:-1000);
						// Verify width
						// If no other uppercase letters, demand that it be the first letter
						if ((((statsWithoutCurrent->averageWidthUppercase.count == 0)
							  && ((r->previous == NULL) || (r->previous->ch == ' ')))
							|| (newWidth > line->averageWidthUppercase.average * (1-0.92)))
							&& ((spaceBetween <= 0) || (spaceAfter == -1000) || (spaceBetween < spaceAfter))) {
							float newBottom = r->rect.origin.y;
							float newHeight = r->rect.size.height;
							replaceTwo(r, newCh, "rule 0029", newBottom, newHeight);
							// Skip next char (replaced)
							r = r->next;
							if (r != NULL)
								r = r->next;
							makeAnotherPass = true; // For example we have subst for "ITI"
							continue;
						}
					} else {
						// Test cases where '1' needs to be replaced with 'l'
							// Not after a digit
						if (((r->previous == NULL) || !isDigit(r->previous->ch))
						    // Followed by a lowercase letter, i.e. in the middle of a lowercase word
							&& (r->next != NULL) && islower(r->next->ch)
							// Not within a phone number or zip (although with some digits mistaken for letters)
							&& (countLongestDigitsSequence(r->word->text()) < 2)) {
							// Replace with 'l'/. Note: could be a 'I' but less look alike than 'l'. TODO: check if all words on that line have uppercase first letters, in which case can't be a 'l'
							wchar_t newCh = 'l';
							ReplacingLog("ValidateLine: rule 0133 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)newCh, toUTF8(r->word->text()).c_str());
							r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
						}
					}
				}
			}

//#if DEBUG
//			if ((r->ch =='I') && (r->previous != NULL) && (r->previous->ch =='E')) {
//				DebugLog("Found it!");
//			}
//#endif

			// Replace 'i' with "fi"
			if (r->ch == 'i') {
				if (!line->isItalic()
					&& (statsWithoutCurrent->averageWidthSuperNarrow1.count >= 2)
					&& (r->rect.size.width > statsWithoutCurrent->averageWidthSuperNarrow1.average * 2)) {
					// Check again against immediate neigbors
					// Either there is no previous
					if ( ((r->previous == NULL)
						 // Or: either we can't compare because not a lowercase chat
						 || !islower(r->previous->ch)
						 // Or: we are twice as wide if previous is not narrow
							|| (!isNarrow(r->previous->ch) && (r->rect.size.width > r->previous->rect.size.width * 0.93))
							|| (isNarrow(r->previous->ch) && (r->rect.size.width > r->previous->rect.size.width * 2)))
						&& ((r->next == NULL)
							// Or: either we can't compare because not a lowercase chat
							|| !islower(r->next->ch)
							// Or: we are wider if not narrow or twice as wide if narrow
							|| (!isNarrow(r->next->ch) && (r->rect.size.width > r->next->rect.size.width * 0.93))
							|| (isNarrow(r->next->ch) && (r->rect.size.width > r->next->rect.size.width * 2)))
						) {
						// Replace with "fi"
						float totalWidth = r->rect.size.width;
						float newWidth = (totalWidth - line->averageSpacing.average) / 2;
						if (newWidth < 1) {
							newWidth = (totalWidth/2) - 1;
						}
						float newHeight = r->rect.size.height;
						char newCh1 = 'f';
						CGRect newRect1(rectLeft(r->rect), rectBottom(r->rect),
													 newWidth, newHeight);
						CGRect newRect2(rectRight(r->rect) - newWidth + 1,
													 rectBottom(r->rect),
													 newWidth,
													 newHeight);
						r->confidence = 0;
						char newCh2 = 'i';
						ReplacingLog("ValidateLine: rule 0134 replacing [%c] with [%c%c] in word [%ls]", (unsigned short)r->ch, newCh1, newCh2, r->word->text().c_str());
						r->word->updateLetterWithNewCharAndNewRect(r, newCh1, newRect1);
						r->word->addLetterWithRectConfidenceAfterRect(newCh2, newRect2, 0, r);
						r = r->next;
						makeAnotherPass = true;
						continue;
					}
				}
				else {
					float gap = gapBelow(r,1);
					if (gap > r->rect.size.height * RATIO_J_BELOW) {
                        // Make sure the gap is not created by some noise
                        if (results->imageTests) {
                            SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                            if (st != NULL) {
                                ConnectedComponentList cpl = st->getConnectedComponents();
                                if ((cpl.size() >= 2) && (cpl[1].ymax < r->rect.size.height)) {
                                    // Adjust height, main component doesn't quite go all the way
                                    CGRect newRect(rectLeft(r->rect), rectBottom(r->rect), r->rect.size.width, cpl[1].ymax);
                                    r->word->updateLetterWithNewCharAndNewRect(r, r->ch, newRect);
                                    gap = gapBelow(r,1);
                                }
                                delete st;
                            }
                        }
                        // Check gap again
                        if (gap > r->rect.size.height * RATIO_J_BELOW) {
                            char newCh = 'j';
                            ReplacingLog("ValidateLine: rule 0135 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                            r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                            makeAnotherPass = true;
                            r = r->next;
                            continue;
                        }
					}
				}
			}
            
//#if DEBUG
//            if ((r->ch =='j') && (r->next != NULL) && (r->next->ch =='c')) {
//                DebugLog("Found");
//            }
//#endif            

			// Matching: 'j'
			// Replacing with: 'J' if way above
			if (r->ch == 'j') {
                float gapB = gapBelow(r, 1, statsWithoutCurrent);
                    // We got an answer
                if ((gapB > -1000)
                    && (gapB < r->rect.size.height * 0.17)) {
                    // Lowercase 'j' that doesn't go below the line => 'i', unless surrounded by uppercase letters
                    
                    // Try 'i'
                    CGRect actualRect = r->rect;
                    // If 'l' is abnormally low, augment the rect we are going to use to test, to capture a possible lost dot above
                    if ((tallHeightTest(statsWithoutCurrent.getPtr(), r->rect.size.height, 0, false, 3, true) == 0)
                        && (maxHeightForSingleLetter > r->rect.size.height)) {
                        actualRect.origin.y = rectTop(r->rect) - maxHeightForSingleLetter + 1;
                        actualRect.size.height = maxHeightForSingleLetter;
                    }
                    wchar_t newCh = SingleLetterTestAsi(r, actualRect, statsWithoutCurrent, results);
                    
                    if (newCh != 'i') {
                        newCh = 'J';
                    }
                    ReplacingLog("ValidateLine: rule 0040 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                    makeAnotherPass = true;
                }
				else if ((tallHeightTest(statsWithoutCurrent.getPtr(), r->rect.size.height,'J',false,0,false) == 1)
				&& (r->rect.size.height > statsWithoutCurrent->averageHeightNormalLowercase.average * 1.40)
				&& ((line->averageHeightNormalLowercase.count == 0) || (heightBelow(r, upsideDown) < line->averageHeightNormalLowercase.average * 0.20))
				&& (r->rect.size.height > statsWithoutCurrent->averageHeightNormalLowercase.average * 1.8)) {
                    char newCh = 'J';
                    ReplacingLog("ValidateLine: rule 0136 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                    makeAnotherPass = true;
                    r = r->next;
                    continue;
                }
            }

			// Map 'l'' to 'r'
			if (isVerticalLine(r->ch) 
				&& (r->next != NULL) && isQuote(r->next->ch)) {
					// 'l' is too short to be a l
				float spaceWithNext = rectLeft(r->next->rect) - rectRight(r->rect) - 1;
				float spaceAfterNext;
				// Matching: "|'|", replacing with 'n'
				if (
					// Low
					(lowHeightTest(statsWithoutCurrent.getPtr(), r->rect.size.height, 1, true, results) == 1)
					// Glued together
					&& (spaceWithNext <= 0)
					// TODO replace line with statsWithout
					&& (line->averageSpacing.average > 0) && (line->averageSpacing.average > spaceAfterNext)
					&& (r->next->next != NULL)
					&& (lowHeightTest(statsWithoutCurrent.getPtr(), r->next->next->rect.size.height, 1, true, results) == 1)
					&& ((r->next->next->ch == '1') || (r->next->next->ch == 'l') || (r->next->next->ch == '|'))
					&& ((spaceAfterNext = rectLeft(r->next->next->rect) - rectRight(r->next->rect) - 1) <= 0)
					&& (line->averageSpacing.average > 0) && (line->averageSpacing.average > spaceAfterNext) ) {
					// Replace with 'n'
					char newCh = 'n';
					float newWidth = rectRight(r->next->next->rect) - rectLeft(r->rect) + 1;
					float maxTop = MAX(MAX(rectTop(r->rect), rectTop(r->next->rect)), rectTop(r->next->next->rect));
					float minBottom = MIN(MIN(rectBottom(r->rect), rectBottom(r->next->rect)), rectBottom(r->next->next->rect));
					float newHeight = maxTop - minBottom + 1;
					CGRect newRect(rectLeft(r->rect), minBottom, newWidth, newHeight);
					ReplacingLog("ValidateLine: rule 0137 replacing [%c%c%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)r->next->ch, (unsigned short)r->next->next->ch, newCh, toUTF8(r->word->text()).c_str());
					r->word->removeLetter(r->next);
					r->word->removeLetter(r->next);
					r->word->updateLetterWithNewCharAndNewRect(r, newCh, newRect);
					r= r->next;
					continue;
				}
				else if ((line->averageHeightNormalLowercase.count >= 2)
						&& (spaceWithNext <= 0) && (statsWithoutCurrentAndNext->averageSpacing.count > 1) 
							&& (statsWithoutCurrentAndNext->averageSpacing.average > spaceWithNext)
                        && (isCloseOrSmallerThanAverage(line->averageHeightNormalLowercase, r->rect.size.height, 0.07)
					   || (indexCloserValToAv1OrAv2(r->rect.size.height, statsWithoutCurrent->averageHeightNormalLowercase, statsWithoutCurrent->averageHeightUppercase) == 1)))
                {
                    replaceTwo(r, 'r');
					r = r->next;
					makeAnotherPass = true;
					continue;	// We don't expect other substitutions
				}
			}

			// Map 'I1' to 'n'
			// Map 'i1' to 'n'
			if (isVerticalLine(r->ch)
				&& (r->next != NULL) && isVerticalLine(r->next->ch)
				// 'i' and 'l' are both too short
				&& (lowHeightTest(statsWithoutCurrentAndNextTwo.getPtr(), r->rect.size.height, 0, true, results) == 1)
				&& (lowHeightTest(statsWithoutCurrentAndNextTwo.getPtr(), r->next->rect.size.height, 0, true, results) == 1)
                && results->imageTests && !(r->flags2 & FLAGS2_TESTED)) 
            {
                float minBottom = MIN(rectBottom(r->rect), rectBottom(r->next->rect));
                float maxTop = MAX(rectTop(r->rect), rectTop(r->next->rect));                     
                float newHeight = maxTop - minBottom + 1;
				float newWidth = rectRight(r->next->rect) - rectLeft(r->rect) + 1;
				float spaceBetween = rectLeft(r->next->rect) - rectRight(r->rect) - 1;
                CGRect newRect (rectLeft(r->rect), minBottom, newWidth, newHeight);
				if ((spaceBetween <= 0) && (line->averageSpacing.average > 0)
					&& (line->averageSpacing.average > spaceBetween)) 
                {
                    char newCh = '\0';
                    // Check that we have indeed a single connected component!
                    bool doit = true;
                    SingleLetterTests *st = CreateSingleLetterTests(newRect, results);
                    if (st != NULL) 
                    {
                        ConnectedComponentList cpl = st->getConnectedComponents();
                        if ((cpl.size() < 2) || ((cpl.size() >= 3) && (cpl[2].area > cpl[1].area * 0.05))) {
                            doit = false;
                        }
                        if (doit) 
                        {
                            newCh = 'n';
                            // Before we conclude it's a 'n', test if the opening might be on top! Then it's a 'u'			
                            OpeningsTestResults resTop;
                            bool success = st->getOpenings(resTop, SingleLetterTests::Top, 
                                0.00,      // Start of range to search (top/left)
                                1.00,      // End of range to search (bottom/right)
                                SingleLetterTests::Bound,   // Require start (top/left) bound
                                SingleLetterTests::Bound  // Require end (bottom/right) bound
                                );
                            if (success && (resTop.maxDepth > newRect.size.height * 0.45)) {
                                newCh = 'u';
                            } else {
                                // Double-check 'n' hypothesis
                                OpeningsTestResults resBottom;
                                bool success = st->getOpenings(resBottom, SingleLetterTests::Bottom, 
                                    0.00,      // Start of range to search (top/left)
                                    1.00,      // End of range to search (bottom/right)
                                    SingleLetterTests::Bound,   // Require start (top/left) bound
                                    SingleLetterTests::Bound  // Require end (bottom/right) bound
                                    );
                                if (!success || (resTop.maxDepth < newRect.size.height * 0.15)) {
                                    newCh = '\0';
                                    doit = false;
                                }
                            }                            
                        } // doit				
                        delete st;
                    } // st != NULL	 
                    else {
                        doit = false;
                    }
                    if (doit && (newCh != '\0')) {
                        ReplacingLog("Validate: replacing [%c%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)r->next->ch, newCh, toUTF8(r->word->text()).c_str());
                        r->word->removeLetter(r->next);
                        r->word->updateLetterWithNewCharAndNewRect(r, newCh, newRect);
                        r = r->next;
                        continue;	// We don't expect other substitutions
                    }
				}
			}
            
            // 1 letter replacements / 1-letter from here on
            
            // 'I' instead of 'E'
            if ((r->ch == 'I') && (results->imageTests) && !(r->flags3 & FLAGS3_TESTED_AS_E)) {
                r->flags3 |= FLAGS3_TESTED_AS_E;
                SmartPtr<OCRStats> sameLetter = countLetterWordLine(r, 'I', true);
                // Much wider than 'I' and same height
                if ((sameLetter->averageHeight.count > 0) && (r->rect.size.width > sameLetter->averageWidth.average * 1.8) && (r->rect.size.height > statsWithoutCurrent->averageHeight.average * (1 - OCR_ACCEPTABLE_ERROR_LOWHURDLE))) {
                    bool doit = false;
                    // Look for two notches on the right side
                    CGRect topRect (rectLeft(r->rect), rectBottom(r->rect), r->rect.size.width, r->rect.size.height * 0.50);
                    CGRect bottomRect (rectLeft(r->rect), rectBottom(r->rect) + r->rect.size.height * 0.50, r->rect.size.width, r->rect.size.height * 0.50);
                    SingleLetterTests *stTop = CreateSingleLetterTests(topRect, results, false, 0, 0.03, true);
                    SingleLetterTests *stBottom = CreateSingleLetterTests(bottomRect, results);
                    if ((stTop != NULL) && (stBottom != NULL)) {
                        doit = true;
                        OpeningsTestResults resTopRight;
                        bool success = stTop->getOpenings(resTopRight, SingleLetterTests::Right,
                                                         0.00,      // Start of range to search (top/left)
                                                         1.00,      // End of range to search (bottom/right)
                                                         SingleLetterTests::Bound,   // Require start (top/left) bound
                                                         SingleLetterTests::Bound  // Require end (bottom/right) bound
                                                         );
                        if (!success) {
                            doit = false;
                        }
                        
                        if (doit) {
                            OpeningsTestResults resBottomRight;
                            bool success = stBottom->getOpenings(resBottomRight, SingleLetterTests::Right,
                                                              0.00,      // Start of range to search (top/left)
                                                              1.00,      // End of range to search (bottom/right)
                                                              SingleLetterTests::Bound,   // Require start (top/left) bound
                                                              SingleLetterTests::Bound  // Require end (bottom/right) bound
                                                              );
                            if (!success) {
                                doit = false;
                            }
                        }
                        
                        if (doit) {
                            OpeningsTestResults resTopLeft;
                            bool success = stTop->getOpenings(resTopLeft, SingleLetterTests::Left,
                                                              0.00,      // Start of range to search (top/left)
                                                              1.00,      // End of range to search (bottom/right)
                                                              SingleLetterTests::Bound,   // Require start (top/left) bound
                                                              SingleLetterTests::Bound  // Require end (bottom/right) bound
                                                              );
                            if (success) {
                                OpeningsTestResults resBottomLeft;
                                bool success = stBottom->getOpenings(resBottomLeft, SingleLetterTests::Left,
                                                                     0.00,      // Start of range to search (top/left)
                                                                     1.00,      // End of range to search (bottom/right)
                                                                     SingleLetterTests::Bound,   // Require start (top/left) bound
                                                                     SingleLetterTests::Bound  // Require end (bottom/right) bound
                                                                     );
                                if (success) {
                                    // We also found two notches on the left -> abort
                                    doit = false;
                                }
                            }
                        }
                        
                        //  -----------
                        //0|           |
                        //1|    1  1 1 |
                        //2|  11111111 |
                        //3|  1 111111 |
                        //4|    111  1 |
                        //5|    111    |
                        //6|    111    |
                        //7|    111    |
                        //8|    11     |
                        //9|    111    |
                        //a|    111    |
                        //b|    111    |
                        //c|    111    |
                        //d|    111    |
                        //e|    111    |
                        //f|    111    |
                        //#|    111    |
                        //#|    111    |
                        //#|    111    |
                        //#|    111    |
                        //#|    11     |
                        //#|    11     |
                        //#|    111    |
                        //#| 11 1111 1 |
                        //#| 111111111 |
                        //#| 111111111 |
                        //#|     11    |
                        //#|           |
                        //  -----------
                        // One more thing: check we didn't just detect two silly openings top/bottom in the above
                        if (doit) {
                            // Middle section must be at least half the width
                            SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                            if (st != NULL) {
                                SegmentList slMiddle = st->getHorizontalSegments(0.50, 0.30);
                                float widthCenter = totalWidth(slMiddle);
                                if (widthCenter < r->rect.size.width * 0.50)
                                    doit = false;
                                delete st;
                            } else {
                                doit = false;
                            }
                        }
                        
                    } // stBottom & stTop != NULL
                    if (stTop != NULL) delete stTop;
                    if (stBottom != NULL) delete stBottom;
                    
                    if (doit) {
                        wchar_t newCh = 'E';
                        ReplacingLog("ValidateLine: rule 01000 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                        r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                    }
                } // high-level test
            }
            
            
            // 'L' instead of 'I'
            if (results->imageTests
                && !(r->flags6 & FLAGS6_TESTED_AS_I)
                && (r->ch == 'L')) {
                r->flags6 |= FLAGS6_TESTED_AS_I;
                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                if (st != NULL)
                {
                    ConnectedComponentList cpl = st->getConnectedComponents();
                    if ( ((cpl.size() == 2)
                         || ((cpl.size() > 2)
                             && ((cpl[2].area < cpl[1].area * 0.04)
                                 // Or much above bottom and still smaller
                                 || ((cpl[2].area < cpl[1].area * 0.15) && (cpl[2].ymax > cpl[1].getHeight() * 0.20))) ))
                         && (cpl[1].getWidth() < r->rect.size.width * 0.80)
                         // Much taller than wide (like a 'I')
                         && (cpl[1].getHeight() > cpl[1].getWidth() * 1.5) ) {
                        // Mistaken bounding box (presumably leading to the mistake). Now test main component is indeed like a 'I'
                        SegmentList slBottom = st->getHorizontalSegments(0.97, 0.06);
                        SegmentList slMiddle = st->getHorizontalSegments(0.35, 0.01);
                        if ((slMiddle.size() > 0) && (slBottom.size() > 0)) {
                            float midPointMiddle = (slMiddle[0].startPos + slMiddle[0].endPos) / 2;
                            float midPointBottom = (slBottom[0].startPos + slBottom[0].endPos) / 2;
                            float bottomLeftBase = slMiddle[0].startPos - slBottom[0].startPos;
                            float bottomRightBase = slBottom[0].endPos - slMiddle[0].endPos;
                                // Middle not titled forward (italics) 
                            if ((midPointMiddle - midPointBottom < cpl[1].getWidth() * 0.20)
                                // Not titled back at all
                                && (midPointBottom - midPointMiddle < cpl[1].getWidth() * 0.05)
                                // Little sprockets left and right (like a 'I' with a base, otherwise wouldn't be mistaken for L)
                                && (bottomLeftBase > 0) && (bottomRightBase > 0)
                                && (bottomRightBase < bottomRightBase * 1.20)) {
                                CGRect newRect(rectLeft(r->rect) + cpl[1].xmin, rectBottom(r->rect) + cpl[1].ymin, cpl[1].getWidth(), cpl[1].getHeight());
                                wchar_t newCh = 'I';
                                ReplacingLog("ValidateLine: rule 0013 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                                r->word->updateLetterWithNewCharAndNewRect(r, newCh, newRect);
                            }
                        }
                    }
                    delete st;
                }
            }
            
			// Map '3' to 'a'
			if (((r->ch == '3') || (r->ch == '8'))
			    // '3' is too short
                && (tallHeightTest(statsWithoutCurrent.getPtr(), r->rect.size.height, '3', false, 2, true) == 0)
				&& (strictShortTest(r, 3) == 1)
				&& !isTallRelativeToNeigbors(r, r->rect.size.height, false)
                // Last test: either surrounded by letters or not a line with consecutive digits (don't take chances to mess tel #)
                    // Accept '1' as a letter on the ground that it could be a mis-recognized 'l' (but then demand it be taller than us)
				&& (((r->previous != NULL) && (isLetter(r->previous->ch) || ((r->previous->ch == '1') && (r->previous->rect.size.height > r->rect.size.height * 1.15)))
                     && (r->next != NULL) && isLetter(r->next->ch)) 
                    || (countLongestDigitsSequence(r->word->text()) < 2))
				) {
                if (round == 0) {
                    makeAnotherPass = true;
                    r = r->next;
                    continue;
                } else {
                    char newCh = 'a';
                    ReplacingLog("ValidateLine: rule 0009 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                    // If previous letter was '1' check if we need to replace it with 'l'
                    if ((r->previous != NULL) && (r->previous->ch == '1') && (r->previous->previous != NULL) && isLetter(r->previous->previous->ch)
                        && (r->next != NULL) && isLower(r->next->ch)) {
                        char newCh = 'l';
                        ReplacingLog("ValidateLine: rule 0009 also replacing previous [%c] with [%c] in word [%s]", (unsigned short)r->previous->ch, newCh, toUTF8(r->word->text()).c_str());
                        r->word->updateLetterWithNewCharAndNewRect(r->previous, newCh, r->previous->rect);
                    }
                    r = r->next;
                    continue;	// We don't expect other substitutions
                }
			}
			// Eliminate extremely narrow '2'
			else if ((r->ch == '2') 
                     && (statsWithoutCurrent->averageWidthDigits.count > 2)) {
                if (((r->rect.size.width < statsWithoutCurrent->averageWidthDigits.average * 0.33)
                            // Av. digit width was 12.5555 => ratio of '2' width is 0.398
                            || ((r->rect.size.width < statsWithoutCurrent->averageWidthDigits.average * 0.41)
                                 // and '2' itself has odd proportions (too tall)
                                 && (r->rect.size.width < r->rect.size.height * 0.33))
                         )
                    )
                {
                    ReplacingLog("ValidateLine: eliminating [%c] in word [%s]", (unsigned short)r->ch, toUTF8(r->word->text()).c_str());
                    // Replacing with ' ' if not followed or preceeded already by a space
                    if ( ((r->previous == NULL) || (r->previous->ch != ' '))
                        && ((r->next == NULL) || (r->next->ch != ' ')) ) 
                    {
                        // No space, replace letter
                        char newCh = ' ';
                        r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                        makeAnotherPass = true;
                        r = r->next;
                    } else {
                        // There is a space next, just remove
                        // There is a space next, just remove
                        SmartPtr<OCRRect> p = r->next; // Save r->next
                        r->word->removeLetter(r);
                        r = p;
                    }
                    continue;
                }
                // '2' instead of '-'
                else if ((r->rect.size.height < statsWithoutCurrent->averageHeightDigits.average * 0.50)
                            // Wider than tall
                            && (r->rect.size.width > r->rect.size.height * 1.8)) {
                    char newCh = '-';
                    ReplacingLog("ValidateLine: rule 0188 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                    makeAnotherPass = true;
                    // Let other tests have a chance
                }
            } // '2'
			
			// Look for mangled th/nd/rd after digit
			if (isDigit(r->ch) // && (r->ch != '0')
				&& (r->next != NULL) && ((r->next->ch == '*') 
                                         || (((r->next->ch == '5') || (toLower(r->next->ch) == 's')) && (r->ch == '1'))
                                         || isQuote(r->next->ch)))
			{
                float applicableWidth = r->rect.size.width;
                if (statsWithoutCurrent->averageWidthDigits.average > 0)
                    applicableWidth = statsWithoutCurrent->averageWidthDigits.average;
                else {
                    if (r->ch == '1')
                        applicableWidth *= 1.7;
                }
                // Not too far
				if (rectLeft(r->next->rect) - rectRight(r->rect) - 1 <= applicableWidth * 0.33) 
                {
                    // Allow quotes to start a bit above the digit
                    float minY = rectBottom(r->rect) - (r->rect.size.height * 0.35);
                    // And dip as low as 0.74 of the height of the digit
                    float maxY = rectBottom(r->rect) + (0.74 * r->rect.size.height);
                    // No larger than 3.0 x the width of the digit (to avoid running amok)
                    float maxWidth = r->rect.size.width * 3.0;
                    float maxHeightAllowed = r->rect.size.height * 0.74;
                    int cnt = 0;	// Number of quote-like
                    SmartPtr<OCRRect> tmpR = r->next;  // Start after digit
                    float newTotalWidth = 0;
                    float minBottom = 10000.0; float maxTop = -1.0;
                    // Count how many characters make up the st/rd/nd/th
                    while (tmpR != NULL) {
                        // Are we going too far out of control?
                        float curWidth = rectRight(tmpR->rect) - rectLeft(r->next->rect) + 1;
                        if (curWidth > maxWidth) {
                            break;
                        }
                        if ((tmpR->ch != ' ') 
                            && (rectBottom(tmpR->rect) >= minY) && (rectTop(tmpR->rect) <= maxY)
                            // Also validate that it is not too tall
                            && (tmpR->rect.size.height < maxHeightAllowed)
                            ) {
                            cnt++;
                            newTotalWidth =  curWidth;
                            float curBottom = rectBottom(tmpR->rect);
                            if (curBottom < minBottom) {
                                minBottom = curBottom;
                            }
                            float curTop = rectTop(tmpR->rect);
                            if (curTop > maxTop) {
                                maxTop = curTop;
                            }
                            tmpR = tmpR->next;
                        } else {
                            break;
                        }
                    }
                    if ((cnt > 0) 
                        // Make sure it's wide enough to be a st/nt/rd/th
                        && (newTotalWidth > line->averageWidthDigits.average * 0.85)
                        // Require a space or comma after
                        && (tmpR != NULL) && ((tmpR->ch == ' ') || (tmpR->ch == ',') || (tmpR->ch == ')') || (tmpR->ch == ']') || (tmpR->ch == '/') || (tmpR->ch == '-'))
                        ) {
                        // Replace!
                        // Create two new characters
                        wchar_t newCh1 = 't', newCh2 = 'h';
                        // If preceeding digit is 1, all numbers end with "th"
                        if ((r->previous == NULL) || (r->previous->ch != '1')) {
                            if (r->ch == '1') {
                                newCh1 = 's'; newCh2 = 't';
                            } else if (r->ch == '2') {
                                newCh1 = 'n'; newCh2 = 'd';
                            } else if (r->ch == '3') {
                                newCh1 = 'r'; newCh2 = 'd';
                            }					
                        }
                        float newWidth = newTotalWidth / 2.0 - 1;
                        float newHeight = maxTop - minBottom + 1;
                        ReplacingLog("ValidateLine: rule 0139 replacing [%d] quote-like characters after [%c] with [%c%c] in word [%s]",
                            cnt, (unsigned short)r->ch, (unsigned short)newCh1, (unsigned short)newCh2, toUTF8(r->word->text()).c_str());
                        // Remove all quote-like
                        for (int j=0; j<cnt; j++) {
                            r->word->removeLetter(r->next);
                        }
                        CGRect newRect1(rectRight(r->rect)+1,
                                    minBottom,
                                    newWidth,
                                    newHeight);
                        CGRect newRect2(rectRight(newRect1)+1,
                                    minBottom,
                                    newWidth,
                                    newHeight);								
                        // -1.0 means do NOT add to stats!
                        r->word->addLetterWithRectConfidenceAfterRect(newCh1, newRect1, -1.0, r);
                        r->word->addLetterWithRectConfidenceAfterRect(newCh2, newRect2, -1.0, r->next);
                        r = r->next->next;
                        continue;
                    }
                }
			}
			
			// Check for 'Y' that's really 'y' 
			else if ((r->ch == 'Y') && (r->previous != NULL)) {
				if (isLower(r->previous->ch) && !isTallAbove(r->previous->ch)
				  // Previous letter less than 12% lower than top of alledged 'Y'
				  && (gapBelowToplineOfOtherRect(r->previous, r) < r->rect.size.height * (OCR_TALL_TO_LOWERCASE_RATIO_LOWHURDLE - 1))) 
				{
					float previousGapAbove = gapAboveBaselineOfOtherRect(r->previous, r);
					if ((isTallBelow(r->previous->ch) && (previousGapAbove > r->rect.size.height * -0.15))
					     || (previousGapAbove > LETTER_BELOW_GAP_AS_PERCENT_OF_HEIGHT_LOWHURDLE)) {
						char newCh = 'y';
						ReplacingLog("ValidateLine: rule 0140 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
						r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
						makeAnotherPass = true;
						r = r->next;
						continue;
					}
				}
			}
			else if ((r->ch == '3') && (r->next != NULL) && (r->next->ch == ' ')
				&& (statsWithoutCurrent->averageHeightDigits.count > 3)
				&& (r->rect.size.width < statsWithoutCurrent->averageWidthDigits.average * (5.0/9.0)) ) {
				char newCh = ':';
				ReplacingLog("ValidateLine: 0141 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
				r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
				r = r->next;
				continue;	// We don't expect other substitutions
			}

			if (r->ch == 'q') {
				float gap = gapBelow(r,1);
				if ((gap != -1000) && (gap < r->rect.size.height * 0.10)) {
					char newCh = 'a';
					ReplacingLog("ValidateLine: rule 0010 replacing [%c] with [%c] in word [%ls]", (unsigned short)r->ch, newCh, r->word->text().c_str());
					r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
					r = r->next;
					continue;	// We don't expect other substitutions
				}
			}
             
			// Map 'B' to 'e'
			if (r->ch == 'B') {
				// 'B' is too short. Require 4 comparable letter to make that (risky) call
				if ((tallHeightTest(statsWithoutCurrent.getPtr(), r->rect.size.height, 'B', false, 3, true) == 0)
                    // Make extra sure by also comparing to neigbors (and fail if tall relative to either neigbors)
                    && !isTallRelativeToNeigbors(r, r->rect.size.height, false)
                    // Check that we don't have a digit left or right (to avoid messing up with a tel number)
                    && (r->previous != NULL) && !isDigit(r->previous->ch)
                    && (r->next != NULL) && !isDigit(r->next->ch)
                    ) {
                    char newCh = 'e';
                    ReplacingLog("ValidateLine: rule 0142 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                    r = r->next;
                    continue;	// We don't expect other substitutions
                }
                // B instead of R
                else if (results->imageTests && !(r->flags2 & FLAGS2_TESTED_AS_B))
                {
                    r->flags2 |= FLAGS2_TESTED_AS_B;
                    SingleLetterTests *st = CreateSingleLetterTests(r->rect, results, false, SINGLE_LETTER_VALIDATE_COMP_SIZE | SINGLE_LETTER_VALIDATE_SINGLE_COMP);
                    if (st != NULL) 
                    {
                        LimitedOpeningsTestResults resBottom;
                        bool successBottom = st->getOpeningsLimited(resBottom, SingleLetterTests::Bottom, 
                            0.10,      // Start of range to search (top/left)
                            0.90,    // End of range to search (bottom/right)
                            0.25,
                            SingleLetterTests::Bound,   // Require start (top/left) bound
                            SingleLetterTests::Bound  // Require end (bottom/right) bound
                            );
                        if (successBottom && (resBottom.maxDepth > r->rect.size.height * 0.20)) {
                            // One more test: demand a wide enough opening, not just a thin line opened at the bottom
                            SegmentList bottomSL = st->getHorizontalSegments(0.975, 0.05);
                            if (bottomSL.size() == 2) {
                                Segment slLeft = bottomSL[0];
                                Segment slRight = bottomSL[1];
                                float gap = slRight.startPos - slLeft.endPos - 1;
#if DEBUG
                                ReplacingLog("ValidateLine: B instead of R test, gap at bottom = [%f] in word [%ls]", gap, r->word->text().c_str());
#endif                                
                                if (gap > r->rect.size.width * 0.15) {
                                    
                                    // One more check: verify bottom-right part is not curved (in case it IS a B):
                                    //  -------------
                                    //0|             |
                                    //1|  111   1    |
                                    //2|  11111111   |
                                    //3|  1111 1111  |
                                    //4|  111   1111 |
                                    //5|  111    111 |
                                    //6|  111    111 |
                                    //7|  111    111 |
                                    //8|  111    11  |
                                    //9|  111    11  |
                                    //a|  1111 111   |
                                    //b|  111111111  |
                                    //c|  1111  1111 |
                                    //d|  111    111 |
                                    //e|  111     11 |
                                    //f|  111     11 |
                                    //#|  111     11 |
                                    //#|  111     11 |
                                    //#|  111    111 |
                                    //#|  111   111  |
                                    //#| 1111  1111  |
                                    //#|  111  111   |
                                    //#|             |
                                    //  -------------
                                    // Indent=3 vs width=11
                                    char newCh = 'R';
                                    CGRect rightRect (rectLeft(r->rect) + slRight.startPos, rectBottom(r->rect), r->rect.size.width - slRight.startPos, r->rect.size.height);
                                    SingleLetterTests *stRight = CreateSingleLetterTests(rightRect, results);
                                    if (stRight != NULL) {
                                        OpeningsTestResults res;
                                        bool success = stRight->getOpenings(res, SingleLetterTests::Left,
                                         0.50,      // Start of range to search (top/left)
                                         1.00,      // End of range to search (bottom/right)
                                         SingleLetterTests::Bound,   // Require start (top/left) bound
                                         SingleLetterTests::Bound  // Require end (bottom/right) bound
                                         );
                                        if (success && (res.maxDepth >= r->rect.size.width * 0.25)) {
                                            newCh = '\0';
                                        }
                                        delete stRight;
                                    }
                                
                                    if (newCh != '\0') {
                                        ReplacingLog("ValidateLine: rule  replacing [%c] with [%c] in word [%ls]", (unsigned short)r->ch, newCh, r->word->text().c_str());
                                        r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                                        r = r->next;
                                        continue;	// We don't expect other substitutions
                                    }
                                }
                            }
                        }
                        delete st;
                    }
                } 
                // 'B' and end dipping below line => 'g'
                if ((r->previous != NULL) && isLower(r->previous->ch)) {
                    float gapAboveTopLine = gapAboveToplineOfNeighbors(r, 1, false);
                    float gapBelowBaseLine = gapBelow(r,1);
                    if ((gapAboveTopLine != -1000) && (gapAboveTopLine < r->rect.size.height * 0.06)
                        && (gapBelowBaseLine != -1000) && (gapBelowBaseLine > r->rect.size.height * 0.12)) {
                        char newCh = 'g';
                        ReplacingLog("ValidateLine: rule 0144 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                        r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                        r = r->next;
                        continue;	// We don't expect other substitutions 
                    }
                }
            }
            
            // 'B' instead of 'C'
            if ((r->ch == 'B') && !(r->flags3 & FLAGS3_TESTED_AS_C) && (results->imageTests)) {
                r->flags3 |= FLAGS3_TESTED_AS_C;
                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results, SINGLE_LETTER_VALIDATE_COMP_SIZE | SINGLE_LETTER_VALIDATE_SINGLE_COMP);
                if (st != NULL) {
                    OpeningsTestResults res;
                    bool success = st->getOpenings(res, SingleLetterTests::Right,
                                         0.20,      // Start of range to search (top/left)
                                         0.80,      // End of range to search (bottom/right)
                                         SingleLetterTests::Bound,   // Require start (top/left) bound
                                         SingleLetterTests::Bound  // Require end (bottom/right) bound
                                         );
                    if (success && (res.maxDepth > r->rect.size.width * 0.25)) {
                        // Found deep opening, now test we don't have inverted components (as in a normal 'B')
                        ConnectedComponentList invertCpl = st->getInverseConnectedComponents();
                        if (invertCpl.size() < 2) {
                            // One more sanity check: make sure we don't have a wide contiguous horizontal segment (as in a C)
                            ConnectedComponentList cpl = st->getConnectedComponents();
                            SegmentList slMiddle = st->getHorizontalSegments(0.50, 0.30);
                            if ((cpl.size()>=2) && (slMiddle.size() >= 1) && (slMiddle[0].endPos - slMiddle[0].startPos < cpl[1].getWidth() * 0.60)) {
                                char newCh = 'C';
                                if (lowHeightTest(statsWithoutCurrent.getPtr(), r->rect.size.height, 1, false, results) == 1)
                                    newCh = 'c';
                                ReplacingLog("ValidateLine: rule 0287 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                                r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                                makeAnotherPass = true;
                            }
                        }
                    }
                    delete st;
                }
            }
            
            // Prices where decimal dot is missing. e.g. $516 instead of $5.16
            // RETAILSPECIFIC what about retailers where prices don't have a leading $?
            if (results->imageTests && isDigit(r->ch) && (r->next != NULL) && isDigit(r->next->ch) && (r->next->next != NULL) && isDigit(r->next->next->ch) && ((r->next->next->next == NULL) || (r->next->next->next->ch == ' '))) {
                if (OCRLine::isPresentInLineBeforeRect('$', r)) {
                    CGRect rect1, rect2;
                    wchar_t newCh1, newCh2;
                    bool foundDot = needToInsertDot (r, statsWithoutCurrent, results, rect1, rect2, newCh1, newCh2);
                    if (foundDot) {
                        ReplacingLog("ValidateLine: rule 0453 replacing [%c] with [%c%c] in word [%s]", (unsigned short)r->ch, (unsigned short)newCh1, (unsigned short)newCh2, toUTF8(r->word->text()).c_str());
                        line->addLetterWithRectConfidenceAfterRect(newCh2, rect2, r->confidence, r);
                        r->word->updateLetterWithNewCharAndNewRect(r, newCh1, rect1);
                        // Stay on current letter, might be a rule testing it below
                    }
                }
            }
            // 'R' instead of "P."
            else if ((r->ch == 'R') && (results->imageTests)) {
                CGRect rect1, rect2;
                wchar_t newCh1, newCh2;
                bool foundDot = needToInsertDot (r, statsWithoutCurrent, results, rect1, rect2, newCh1, newCh2);
                if (foundDot) {
                    ReplacingLog("ValidateLine: rule 0097 replacing [%c] with [%c%c] in word [%s]", (unsigned short)r->ch, (unsigned short)newCh1, (unsigned short)newCh2, toUTF8(r->word->text()).c_str());
                    line->addLetterWithRectConfidenceAfterRect(newCh2, rect2, r->confidence, r);
                    r->word->updateLetterWithNewCharAndNewRect(r, newCh1, rect1);
                    // Stay on current letter, might be a rule testing it below
                }
            }
            // Test for extra wide 's' or 'e' or 'k' or '' because it subsumes a '.'
            // TODO include all normal lowercase letter + all tall narrow letters?
            else if (((r->ch == 's') || (r->ch == 'e') || (r->ch == 'k') || (r->ch == 'i') || (r->ch == 'd') || (r->ch == 'm') || (r->ch == 't') || (r->ch == 'p') || (r->ch == 0xe7) || (r->ch == 'L')) && (results->imageTests)
                     && ( (((r->ch != 'L') && (statsWithoutCurrent->averageWidthNormalLowercase.count >= 2))
                           && ( ((r->ch != 'm') && (r->rect.size.width > statsWithoutCurrent->averageWidthNormalLowercase.average * 1.25))
                               || ((r->ch == 't') && (r->rect.size.width > statsWithoutCurrent->averageWidthNormalLowercase.average * 0.75))
                               || ((r->ch == 'm') && (r->rect.size.width > statsWithoutCurrent->averageWidthNormalLowercase.average * 1.43))
                               || ((r->ch == 'i') && (r->rect.size.width > statsWithoutCurrent->averageWidthNormalLowercase.average * 0.75))
                              )
                          )
                          || ((statsWithoutCurrent->averageWidth.count >= 2)
                               && (r->rect.size.width > statsWithoutCurrent->averageWidth.average))
                          || ((r->ch == 'L') && (r->rect.size.width > r->rect.size.height * 0.35))
                        )
                )
            {
                if (round == 0) {
                    makeAnotherPass = true;
                } else 
                {
                    CGRect rect1, rect2;
                    wchar_t newCh1, newCh2;
                    SingleLetterTests *st = NULL;
                    bool foundDot = needToInsertDot (r, statsWithoutCurrent, results, rect1, rect2, newCh1, newCh2, &st);
                    if (foundDot) {
                        ReplacingLog("ValidateLine: rule 0036 replacing [%c] with [%c%c] in word [%s]", (unsigned short)r->ch, (unsigned short)newCh1, (unsigned short)newCh2, toUTF8(r->word->text()).c_str());
                        line->addLetterWithRectConfidenceAfterRect(newCh2, rect2, r->confidence, r);
                        r->word->updateLetterWithNewCharAndNewRect(r, newCh1, rect1);                                    
                        r = r->next;
                        if (st != NULL) {
                            delete st;
                            st = NULL;
                        }
                    }        
                    else if (((r->ch == 'c') || (r->ch == 0xe7)) && (st != NULL)) 
                    {
                        ConnectedComponentList cpl = st->getConnectedComponents();
                        if (cpl.size() == 2) 
                        {
                            // For c and  give it another chance: could be a dot glued at the bottom => wider bottom than top
                            SegmentList slTop = st->getHorizontalSegments(0.075, 0.15);
                            SegmentList slBottom = st->getHorizontalSegments(0.90, 0.20);
                            for (int i=0; i< slTop.size(); i++) {
                                DebugLog("Validate: checking wide [c], top segments[%d] [%d,%d] in word [%s]", i, slTop[i].startPos, slTop[i].endPos, toUTF8(r->word->text()).c_str());
                            }
                            for (int i=0; i< slBottom.size(); i++) {
                                DebugLog("Validate: checking wide [c], top segments[%d] [%d,%d] in word [%s]", i, slBottom[i].startPos, slBottom[i].endPos, toUTF8(r->word->text()).c_str());
                            }                        

                            if ((slTop.size() == 1) && (slBottom.size() == 1)) {
                                DebugLog("Validate: checking wide [c], top segment=[%d,%d], bottom segment=[%d, %d], width=%d in word [%s]", slTop[0].startPos, slTop[0].endPos, slBottom[0].startPos, slBottom[0].endPos, (unsigned int)r->rect.size.width, toUTF8(r->word->text()).c_str());
                                bool doit = true;
                                if (!(((slTop[0].endPos + 1) < r->rect.size.width * 0.75) && ((slBottom[0].endPos + 1) > r->rect.size.width * 0.90))) {
                                    doit = false;
                                }
                                if (doit) 
                                {
                                    // Now also require indentations top & bottom creating a separation of the dot
                                    CGRect bottomRect(rectLeft(r->rect), rectBottom(r->rect) + r->rect.size.height * 0.50, r->rect.size.width, r->rect.size.height * 0.50);
                                    SingleLetterTests *stBottom = CreateSingleLetterTests(bottomRect, results);
                                    if (stBottom != NULL) 
                                    {
                                        OpeningsTestResults resTop;
                                        bool success = stBottom->getOpenings(resTop, SingleLetterTests::Top, 
                                            0.50,      // Start of range to search (top/left)
                                            0.90,      // End of range to search (bottom/right)
                                            SingleLetterTests::Bound,   // Require start (top/left) bound
                                            SingleLetterTests::Bound  // Require end (bottom/right) bound
                                            );
                                        if (!success) {
                                            doit = false;
                                        }
                                        OpeningsTestResults resBottom;
                                        if (doit)
                                        {
                                            bool success = stBottom->getOpenings(resBottom, SingleLetterTests::Bottom, 
                                                0.50,      // Start of range to search (top/left)
                                                0.90,      // End of range to search (bottom/right)
                                                SingleLetterTests::Bound,   // Require start (top/left) bound
                                                SingleLetterTests::Bound  // Require end (bottom/right) bound
                                                );
                                            if (!success) {
                                                doit = false;
                                            } 
                                        }
                                        if (doit) 
                                        {
                                            char newCh2 = '.';
                                            CGRect actualDotRect;
                                            bool doit = true;
                                            // Determine rect for the dot
                                            float minX = MIN(resTop.maxDepthCoord, resBottom.maxDepthCoord);
                                            CGRect dotRect(rectLeft(bottomRect)+minX, rectBottom(bottomRect), bottomRect.size.width - minX, bottomRect.size.height);
                                            SingleLetterTests *stDot = CreateSingleLetterTests(dotRect, results);
                                            if (stDot != NULL) {
                                                ConnectedComponentList cpl = stDot->getConnectedComponents();
                                                if (cpl.size() >= 2) {
                                                    actualDotRect.origin.x = rectLeft(dotRect) + cpl[0].xmin;
                                                    actualDotRect.origin.y = rectBottom(dotRect) + cpl[0].ymin;
                                                    actualDotRect.size.width = cpl[0].getWidth();
                                                    actualDotRect.size.height = cpl[0].getHeight();
                                                    // Is it a comma?
                                                    // TODO check that comma extends below the 'c' part to the left
                                                    if (actualDotRect.size.height > actualDotRect.size.width * 1.4) {
                                                        newCh2 = ',';
                                                    }
                                                } else {
                                                    doit = false;
                                                }
                                                delete stDot;
                                            } // stDot != NULL
                                            if (doit) {
                                                ReplacingLog("ValidateLine: rule 0145 replacing [%c] with [%c%c] in word [%s]", (unsigned short)r->ch, (unsigned short)r->ch, newCh2, toUTF8(r->word->text()).c_str());
                                                CGRect newRect1(rectLeft(r->rect),
                                                                rectBottom(r->rect),
                                                                minX,
                                                                r->rect.size.height);
                                                // Update first char width
                                                r->word->updateLetterWithNewCharAndNewRect(r, r->ch, newRect1);
                                                r->confidence = 0;
                                                // Insert '.' after letter
                                                r->word->addLetterWithRectConfidenceAfterRect(newCh2, actualDotRect, 0, r);
                                                r->next->confidence = 0;
                                                r = r->next->next;
                                                delete stBottom;
                                                delete st;
                                                continue;	// We don't expect other substitutions 
                                            } // doit
                                        }
                                        delete stBottom;
                                    } // stBottom != NULL
                                } // doit
                            } // got top & bottom segments
                        } // 2 components
                    } // c or  and st != NULL
                    delete st;
                } /// round = 1
            }          
            // 'C' or '' instead of ".C", test for extra wide 'C' because it subsumes a '.'
            else if (((r->ch == 'C') || (r->ch == 0xc7)) && (r->previous != NULL) && isUpper(r->previous->ch)
                     && (statsWithoutCurrent->averageWidthUppercase.count > 4)
                     && (r->rect.size.width > statsWithoutCurrent->averageWidthUppercase.average * 1.5)) {
                if (round == 0) {
                    makeAnotherPass = true;
                } else if (r->previous != NULL) {
                    // Make sure previous rect doesn't overlap with us (if it does, cast doubt on our assumption that the extra width is caused by a '.'
                    float spaceWithPrevious = rectLeft(r->rect) - rectRight(r->previous->rect) - 1;
                    if (spaceWithPrevious >= 0) {
                        ReplacingLog("ValidateLine: rule 0080 replacing [%c] with [.C] in word [%s]", (unsigned short)r->ch, toUTF8(r->word->text()).c_str());
                        char newCh1 = '.';
                        // C actual width should be per the average width of uppercase
                        float newWidth2 = statsWithoutCurrent->averageWidthUppercase.average;
                        float spaceWithPrevious = rectLeft(r->rect) - rectRight(r->previous->rect) - 1;
                        float newWidth1 = r->rect.size.width - newWidth2 - spaceWithPrevious;
                        // '.' 15% of 'C' height?
                        float newHeight1 = r->rect.size.height * 0.15;
                        CGRect newRect1(rectLeft(r->rect),
                                        rectTop(r->rect) - newHeight1 + 1,
                                        newWidth1,
                                        newHeight1);
                        CGRect newRect2(rectRight(r->rect) - newWidth2,
                                        rectBottom(r->rect),
                                        newWidth2,
                                        r->rect.size.height);
                        // Update 'C' width
                        r->word->updateLetterWithNewCharAndNewRect(r, r->ch, newRect2);
                        r->confidence = 0;
                        // Insert '.' before
                        r->word->addLetterWithRectConfidenceAfterRect(newCh1, newRect1, 0, r->previous);
                        r = r->next;
                        continue;	// We don't expect other substitutions 
                    }
                }
            }            
            // Test for extra wide 'o' because it subsumes a ".o" in ".oom" (".com")
            else if (((r->ch == 'o') || (r->ch == 'c') || (r->ch == 'n')) && (r->next != NULL) && isLower(r->next->ch)
                     && (statsWithoutCurrent->averageWidthNormalLowercase.count > 4)
                     && ((r->previous != NULL) && isLower(r->previous->ch))
                     && (r->rect.size.width > statsWithoutCurrent->averageWidthNormalLowercase.average * 1.4)
                     && results->imageTests) 
            {
                if (round == 0) {
                    makeAnotherPass = true;
                } else 
                {
                    float spaceWithPrevious = rectLeft(r->rect) - rectRight(r->previous->rect) - 1;
                    if (spaceWithPrevious >= 0) {
                        SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                        if (st != NULL) {
                            ConnectedComponentList cpl = st->getConnectedComponents();
                            CGRect rect1;
                            CGRect rect2;
                            bool foundDot = needToInsertDot (r, statsWithoutCurrent, cpl, rect1, rect2);
                            if (foundDot) {
                                ReplacingLog("ValidateLine: rule 0146 replacing [%c] with [.%c] in word [%s]", (unsigned short)r->ch, (unsigned short)r->ch, toUTF8(r->word->text()).c_str());
                                line->addLetterWithRectConfidenceAfterRect(r->ch, rect2, r->confidence, r);
                                r->word->updateLetterWithNewCharAndNewRect(r, '.', rect1);                                    
                                r = r->next;
                            }
                            delete st;
                        } // st != NULL
                    }
                }
            } 
            // Test for extra wide 't' because it subsumes a '.'
            // Make sure to do this only for tall 't's, NOT the wide variety
            else if (((r->ch == 't') && (r->rect.size.height > r->rect.size.width * 1.6))
                     && (r->next != NULL) && isLower(r->next->ch)
                     && (statsWithoutCurrent->averageWidthNormalLowercase.count > 7)
                     && (r->rect.size.width > statsWithoutCurrent->averageWidthNormalLowercase.average)) {
                if (round == 0) {
                    makeAnotherPass = true;
                } else if (!line->isItalic()) {
                    float spaceWithNext = rectLeft(r->next->rect) - rectRight(r->rect) - 1;
                    if (spaceWithNext >= 0) {
                        // One more check: if there is a missed dot, it means we should have two connected components - check it!
                        bool doit = true;
                        if (results->imageTests && !(r->flags4 & FLAGS4_TESTED_FOR_MISSING_DOT)) {
                            r->flags4 |= FLAGS4_TESTED_FOR_MISSING_DOT;
                            SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                            if (st != NULL) {
                                ConnectedComponentList cpl = st->getConnectedComponents();
                                if ((cpl.size() < 3) || (cpl[2].area < cpl[1].area * 0.05)) {
                                    doit = false;
                                }
                                delete st;
                            }
                        }
                        if (doit) {
                            ReplacingLog("ValidateLine: rule 0081 replacing [%c] with [%c.] in word [%s]", (unsigned short)r->ch, (unsigned short)r->ch, toUTF8(r->word->text()).c_str());
                            char newCh2 = '.';
                            // t actual width should be at most 2/3 or normal lowercase width
                            float newWidth1 = statsWithoutCurrent->averageWidthNormalLowercase.average * 0.66;
                            float newWidth2 = r->rect.size.width - newWidth1 - spaceWithNext;
                            // '.' 20% of 's' height?
                            float newHeight2 = r->rect.size.height * 0.20;
                            CGRect newRect1(rectLeft(r->rect),
                                            rectBottom(r->rect),
                                            newWidth1,
                                            r->rect.size.height);
                            // Refrain from doing the replacement if the narrower letter is not a 't'
                            if (results->imageTests 
                                && (OCRUtilsSuggestLetterReplacement(newRect1, r->ch, 0, results,
                                                                         false,
                                                                         NULL) == 't')) 
                            {
                                CGRect newRect2(rectRight(r->rect) - newWidth1,
                                            rectTop(r->rect) - newHeight2 + 1,
                                            newWidth2,
                                            newHeight2);
                                // Update 't' width
                                r->word->updateLetterWithNewCharAndNewRect(r, r->ch, newRect1);
                                r->confidence = 0;
                                // Insert '.' after 't'
                                r->word->addLetterWithRectConfidenceAfterRect(newCh2, newRect2, 0, r);
                                r = r->next->next;
                                continue;	// We don't expect other substitutions 
                            }
                        }
                    }
                }
            }
            
            //  --------
            //0|        |
            //1| 111111 |
            //2|  1111  |
            //3|    11  |
            //4|    11  |
            //5|    11  |
            //6|   11   |
            //7|   11   |
            //8|   11   |
            //9|   11   |
            //a|   11   |
            //b|   11   |
            //c|        |
            //  --------
            // 'T' instead of '7' (at small font size)
            // 4th pixel down (3.5/12=29%) showing section shifted right
            if ((r->ch == 'T') && (results->globalStats.averageHeightDigits.average <= 13) && (r->rect.size.width > results->globalStats.averageWidthDigits.average * 0.85) && !(r->flags3 & FLAGS3_TESTED_AS_7)) {
                bool doit = false; wchar_t newCh = '\0';
                r->flags3 |= FLAGS3_TESTED_AS_7;
                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                if (st != NULL) {
                    SegmentList slTop29 = st->getHorizontalSegments(0.29, 0.05);
                    SegmentList slBottom = st->getHorizontalSegments(0.625, 0.05);
                    SegmentList slBottomTall = st->getHorizontalSegments(0.90, 0.20);
                    if ((slTop29.size() == 1) && (slBottom.size() == 1) && (slBottomTall.size() == 1)
                        // Top more shifted right than bottom (start)
                        && (slTop29[0].startPos > slBottom[0].startPos)
                        // Top more shifted right than bottom (end)
                        && (slTop29[0].endPos > slBottom[0].endPos)
                        // Top more shifted right than bottom (start)
                        && (slTop29[0].startPos > slBottomTall[0].startPos)
                        // Top more shifted right than bottom (end)
                        && (slTop29[0].endPos > slBottomTall[0].endPos)
                        // Closer to right side than to left side
                        && (r->rect.size.width - slTop29[0].endPos < slTop29[0].startPos)) {
                        doit = true;
                        newCh = '7';
                    }
                    delete st;
                }
                if (doit && (newCh != '\0')) {
                    ReplacingLog("ValidateLine: rule 0663 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                    makeAnotherPass = true;
                }
            }
            
            //  --------
            //0|        |
            //1|   111  |
            //2|  11111 |
            //3| 111111 |
            //4| 11111  |
            //5|   111  |
            //6|   111  |
            //7|   111  |
            //8|   111  |
            //9|   111  |
            //a|   111  |
            //b|   111  |
            //c|   111  |
            //d|   111  |
            //e|   111  |
            //f|   111  |
            //#|   111  |
            //#|   111  |
            //#|        |
            //  --------
            // 'T' instead of '1'
            if ((r->ch == 'T') && results->imageTests && !(r->flags2 & FLAGS2_TESTED_AS_1) && (((statsWithoutCurrent->averageWidthDigits.count >= 2) && (r->rect.size.width < statsWithoutCurrent->averageWidthDigits.average * 0.85)) || ((results->globalStats.averageWidthDigits.count >= 2) && (r->rect.size.width < results->globalStats.averageWidthDigits.average * 0.85)))) {
                r->flags2 |= FLAGS2_TESTED_AS_1;
                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                bool doit = false; char newCh = '\0';
                if (st != NULL) {
                    // Verify that it's not just narrow, it's also the case that the stem spans most of the width (i.e. top part is *really* too narrow
                    SegmentList slMiddle = st->getHorizontalSegments(0.50, 0.01);
                    SegmentList slBottom = st->getHorizontalSegments(0.90, 0.01);
                    if ((slMiddle.size() == 1) && (slBottom.size() == 1)) {
                        if ((slMiddle[0].endPos - slMiddle[0].startPos + 1 >= r->rect.size.width * 0.40)
                            && (slBottom[0].endPos - slBottom[0].startPos + 1 >= r->rect.size.width * 0.40)) {
                            newCh = '1';
                            doit = true;
                        }
                    }
                    if (doit) {
                        // Test that it's not more indented on the right side!
                        OpeningsTestResults resRight;
                        bool successRight = st->getOpenings(resRight, SingleLetterTests::Right,
                            0.10,      // Start of range to search (top/left)
                            0.90,      // End of range to search (bottom/right)
                            SingleLetterTests::Bound,   // Require start (top/left) bound
                            SingleLetterTests::Any  // Require end (bottom/right) bound
                            );
                        OpeningsTestResults resLeft;
                        bool successLeft = st->getOpenings(resLeft, SingleLetterTests::Left,
                            0.10,      // Start of range to search (top/left)
                            0.90,      // End of range to search (bottom/right)
                            SingleLetterTests::Bound,   // Require start (top/left) bound
                            SingleLetterTests::Any  // Require end (bottom/right) bound
                            );
                        if (successRight
                            && ((!successLeft || (resLeft.maxDepth < resRight.maxDepth))
                                || (resRight.maxDepth >= r->rect.size.width * 0.25))) {
                            ReplacingLog("ValidateLine: rule 0860 NOT replacing [%c] with [%c] in word [%s], indented on right side", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                            doit = false;
                        }
                    }
                    // Also test there isn't an abnormally large space on the right side, can indicate a T truncated by a bad printer
                    if ((r->next != NULL) && isLetterOrDigit(r->next->ch)) {
                        if ((statsWithoutCurrentAndNext->averageSpacing.count > 0) && (rectSpaceBetweenRects(r->rect, r->next->rect) > statsWithoutCurrentAndNext->averageSpacing.average * 2.5)) {
                            ReplacingLog("ValidateLine: rule 0860 NOT replacing [%c] with [%c] in word [%s], wide space on right", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                            doit = false;
                        }
                    }
                    delete st;
                }
                if (doit) {
                    ReplacingLog("ValidateLine: rule 0860 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                    makeAnotherPass = true;
                }
            }
            
            if ((r->ch == 'p') && (statsWithoutCurrent->averageHeightNormalLowercase.count < statsWithoutCurrent->averageHeightUppercase.count * 0.20)) {
                float gapBelowBaseLine = gapBelow(r,1);
                if ((gapBelowBaseLine != -1000) && (gapBelowBaseLine < r->rect.size.height * 0.10)) {
                    char newCh = 'P';
                    ReplacingLog("ValidateLine: rule 0147 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                    r = r->next;
                    makeAnotherPass = true;
                    continue;	// We don't expect other substitutions 
                }
            } else if ((r->ch == 'P') && !allUpperCase
                     && ((r->previous != NULL) && isLetterOrDigit(r->previous->ch))
                     && ((r->previous->previous == NULL) || !isUpper(r->previous->previous->ch))
                     ) {
                float gapBelowBaseLine = gapBelow(r,1);
                if ((gapBelowBaseLine != -1000) && (gapBelowBaseLine > r->rect.size.height * 0.20)) {
                    char newCh = 'p';
                    ReplacingLog("ValidateLine: rule 0148 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                    r = r->next;
                    makeAnotherPass = true;
                    continue;	// We don't expect other substitutions 
                }
            } 

			// "LLP" on first line got returned as "Lu>"
			if ((r->ch == 'u') && (r->next != NULL) && (r->next->ch == '>') && !OCRLine::isPresentInLineBeforeRect('<', r) && (r->rect.size.height > 0)
				// Next char ('>') bottom is at least 15% above current char base line (as percent of current char height)
				&& ((rectTop(r->rect)-rectTop(r->next->rect))/r->rect.size.height > 0.15)) {
				// Replace 'u>' with 'LP'
				float newWidth = (rectRight(r->next->rect) - rectLeft(r->rect))/2;
				if ((line->averageSpacing.count > 0) && (line->averageSpacing.average < newWidth/3)) {
					newWidth -= (line->averageSpacing.average/2);
				}
				// Adjust current rect.
				float maxTop = MAX(rectTop(r->rect), rectTop(r->next->rect));
				float minBottom = MIN(rectBottom(r->rect), rectBottom(r->next->rect));
				float newHeight = maxTop - minBottom + 1;
				CGRect newRect(rectLeft(r->rect),
								minBottom,
								newWidth,
								newHeight);
				char newCh = 'L';
				ReplacingLog("ValidateLine: rule 0149 replacing [%c%c] with [LP] in word [%s]", (unsigned short)r->ch, (unsigned short)r->next->ch, toUTF8(r->word->text()).c_str());
				r->word->updateLetterWithNewCharAndNewRect(r, newCh, newRect);
				newRect = CGRect(rectRight(r->next->rect)-newWidth,
									 minBottom,
									 newWidth,
									 r->rect.size.height);
				r->word->updateLetterWithNewCharAndNewRect(r->next, 'P', newRect);
				// Skip current char & next char (both processed already)
				r = r->next->next;
				continue;	// We don't expect other substitutions
				}
                
            // 't' instead of ':'
            if ((r->ch == 't') && (r->rect.size.height > r->rect.size.width * 2.5)) {
                // Possibly a column
                wchar_t newCh = '\0';
                CGRect newRect;
                if ((SingleLetterTestAsColumn(r, r->rect, results, newCh, newRect) >= 0.50) && (newCh != '\0') && (newCh != r->ch))
                {
                    ReplacingLog("ValidateLine: rule 0150 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)newCh, toUTF8(r->word->text()).c_str());
                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, newRect);
                    makeAnotherPass = true;                
                    r = r->next;
                    continue;
                }
            }

			// 'S' height 25, ':' height 15
			if ((r->ch == 'S')
				&& (r->next != NULL) && (r->next->ch == ':') && (r->next->rect.size.height < r->rect.size.height * (16.0/25.0))) {
				float spaceWithNext = rectLeft(r->next->rect) - rectRight(r->rect) - 1;
				if ((spaceWithNext <= 0) && (statsWithoutCurrent->averageSpacing.average > spaceWithNext)) {
                    replaceTwo(r, '&');
					r = r->next;
					continue;	// We don't expect other substitutions
				}
			}
            
            if ((r->ch == '2') && (r->rect.size.height > r->rect.size.width * 4)) {
                wchar_t newCh = 'i';
                if (lowHeightTest(statsWithoutCurrent.getPtr(), r->rect.size.height, 0, false, results) == 1)
                {
                    if (((r->next == NULL) || isDigit(r->next->ch))
                        && ((r->previous != NULL) && ((r->previous->ch == ' ') || isLetter(r->previous->ch)))) {
                        newCh = ':';
                    } else {
                        newCh = 'i';
                        r->confidence += 500;
                    }
                }
                ReplacingLog("ValidateLine: rule 0152 replacing [%c] with [%c] in [%s]", (unsigned short)r->ch, (unsigned short)newCh,
                             toUTF8(r->word->text()).c_str());
                r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                makeAnotherPass = true;
            }
			// Replace "8<" with "&"
			else if (r->ch == '8') {
				float spaceBetween;
				if ((r->next != NULL) && (r->next->ch == '<')) {
					float newWidth = rectRight(r->next->rect) - rectLeft(r->rect) + 1;
					if ( (line->averageWidth.count >= 3)
						&& (indexCloserValToVal1OrVal2(newWidth, line->averageWidth.average, (line->averageWidth.average+line->averageSpacing.average)*2) == 1))
                    {
                        replaceTwo(r, '&');
						r = r->next;
						continue;	// We don't expect other substitutions
					}
				} else if ((r->next != NULL)
						   // Surrounded by spaces
						   && ((r->previous == NULL) || (r->previous->ch == ' '))
						   && ((r->next->next == NULL) || (r->next->next->ch == ' '))
						   && (tallHeightTest(statsWithoutCurrent.getPtr(), r->rect.size.height, 0, false, 0, true) == 1)
						   // Glued together
						   && ((spaceBetween = (rectLeft(r->next->rect) - rectRight(r->rect) - 1)) <= 0)
						   // Line is not italics with zero or negative spacing
						   && ((statsWithoutCurrentAndNext->averageSpacing.average != 0)
								&& (statsWithoutCurrentAndNext->averageSpacing.average > spaceBetween))
						   // '8' much taller
						   && (r->rect.size.height > r->next->rect.size.height * 1.35)) 
                {
                    replaceTwo(r, '&');
					r = r->next;
					continue;	// We don't expect other substitutions
				}
			}
            
            // Replace "IY" with 'N'
            if (isVerticalLine(r->ch)
                && ((r->next != NULL) && (r->next->ch == 'Y'))
                // We can apply single-letter tests and have not tested this possibility yet
                && !(r->flags6 & FLAGS6_TESTED_AS_N) && results->imageTests
                // Touching or overlapping
                && (rectSpaceBetweenRects(r->rect, r->next->rect) <= 0)
                // Next two are not touching
                && ((r->next->next == NULL) || (rectSpaceBetweenRects(r->next->rect, r->next->next->rect) > 0))
                // Previous two are not touching
                && ((r->previous == NULL) || (rectSpaceBetweenRects(r->previous->rect, r->rect) > 0)))
            {
                r->flags6 |= FLAGS6_TESTED_AS_N; // Avoid testing this again
                // Require that the combination of both characters be a single blog of connected pixels
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                // Accept neighbor8
                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results, false, 0);
                if (st != NULL)
                {
                    ConnectedComponentList cpl = st->getConnectedComponents();
                    if ((cpl.size() == 2) // single comp
                        || ((cpl.size() == 3) // 2 comps
                            && (cpl[2].getHeight() < cpl[1].getHeight() * 0.30) // 2nd much smaller
                            // Way above or below
                            && (((cpl[2].ymin - cpl[1].ymax) > cpl[1].getHeight() * 0.25) || (cpl[1].ymin - cpl[2].ymax > cpl[1].getHeight() * 0.25))
                            ))
                    {
                        CGRect newRect (rectLeft(combinedRect) + cpl[1].xmin, rectBottom(combinedRect) + cpl[1].ymin, cpl[1].getWidth(), cpl[1].getHeight());
                        // Check that new rect has a sensible height as uppercase
                        if ((newRect.size.height > statsWithoutCurrentAndNext->averageHeightUppercase.average * 0.85)
                            && (newRect.size.height < statsWithoutCurrentAndNext->averageHeightUppercase.average * 1.15))
                        {
                            SingleLetterTests *stNew = CreateSingleLetterTests(newRect, results, false, 0);
                            if (stNew != NULL) {
                                // Avoid replacing a real 'Y', test right side for a straight vertical line (90% of height should be enough)
                                if (stNew->getSide(SingleLetterTests::Right, 0.90, false)) {
                                    // Replace!
                                    replaceTwoWithRect(r, 'N', newRect);
                                    // Fall through, let other tests use the new letter
                                }
                                delete stNew;
                            }
                        }
                    }
                    delete st;
                }
            }
            
            // Replace "l:" with 't' or 'f'
            if (isVerticalLine(r->ch)
                && ((r->next != NULL) && (r->next->ch == ':'))
                // We can apply single-letter tests and have not tested this possibility yet
                && !(r->flags4 & FLAGS4_TESTED_AS_t) && results->imageTests
                // Touching or overlapping
                && (rectSpaceBetweenRects(r->rect, r->next->rect) <= 0)
                // Next two are not touching
                && ((r->next->next == NULL) || (rectSpaceBetweenRects(r->next->rect, r->next->next->rect) > 0))
                )
            {
                r->flags4 |= FLAGS4_TESTED_AS_t; // Avoid testing this again
                // Require that the combination of both characters be a single blog of connected pixels
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                // Accept neighbor8
                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results, false, SINGLE_LETTER_VALIDATE_COMP_SIZE | SINGLE_LETTER_VALIDATE_SINGLE_COMP);
                if (st != NULL) {
                    // Single component
                    // Tell suggest letter replacement we think it's a 'l'. If it suggests 't' of 'f', go for it because these letter fit the case
                    wchar_t newCh = OCRUtilsSuggestLetterReplacement(combinedRect, 'l',
                                                     (((line->averageHeightNormalLowercase.count > 2) && (r->rect.size.height > line->averageHeightNormalLowercase.average * 1.36))? 0:maxHeightForSingleLetter),
                                                    results,
                                                    false, /* Don't force replace */
                                                    NULL   /* Don't need to know i body height here */);
                    delete st;
                    if ((newCh == 't') || (newCh == 'f')) {
                        // Replace!
                        replaceTwoWithRect(r, newCh, combinedRect);
                        continue;
                    }
                }
            }

			// Replace "|<" with "k"
			if (isVerticalLine(r->ch)
                && !(r->flags3 & FLAGS3_TESTED_AS_K) && results->imageTests
				&& (r->next != NULL) && (isCLookalike(r->next->ch) || (r->next->ch == 'r')
                        || (r->next->ch == '2')
                        || (r->next->ch == 'z'))
					// Too risky to replace 'i' + a real letter because the bar of the 'k' is not like a 'i' so unlikely to be a 'k' here
				&& ((r->ch != 'i') || (r->next->ch == '<')) 
                    // Avoid testing "IC", unless follows a lowercase or followed by a lowercase
                && ( !(((r->ch == 'I') || (r->ch == 'l')) && (r->next->ch == 'C'))
                     || ((r->previous != NULL) && isLower(r->previous->ch))
                     || ((r->next->next != NULL) && isLower(r->next->next->ch))
                    )
				// Too risky to replace "/c" with "k" because of http://cxxx 
				&& !((r->ch == '/') && (r->next->ch == 'c'))
                // Special test for '2'
                && ((r->next->ch != '2') 
                        // Require '2' to be diminutive in order to not risk replacing a real '2' (even though we tested for single component - may be too conservative)
                        || ((statsWithoutCurrent->averageHeightNormalLowercase.count > 2) && (r->next->rect.size.height < statsWithoutCurrentAndNext->averageHeightNormalLowercase.average * 1.1)))
                // Already tested '2' differently above
                // 'z' is a normal lowercase height
				&& (((r->next->ch == '<') || (r->next->ch == '2') || (r->next->ch == 'z'))
					// If rest of line well spaced, don't test height: we are going to require glued, if line well spaced that must mean we should replace!
                    // If next is not '<' (which begs to be replaced), required positive spacing on the line
				    || (statsWithoutCurrentAndNext->averageSpacing.average > statsWithoutCurrentAndNext->averageWidthNormalLowercase.average * 0.125)
                    || (r->next->rect.size.height > r->rect.size.height * 0.64))
				)
			{
                char newCh = 'k';
				bool doit = false;
				float spaceBetween = rectLeft(r->next->rect) - rectRight(r->rect) - 1;
                // First case: letters are glued, rest of line is not
				if (spaceBetween <= 0) {
                    if (statsWithoutCurrentAndNext->averageSpacing.average > 0) {
					doit = true;
					ReplacingLog("ValidateLine: rule 0099 replacing [%c%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)r->next->ch, newCh, toUTF8(r->word->text()).c_str());
                    } else {
                        float totalWidth = rectRight(r->next->rect) - rectLeft(r->rect) + 1;
                        // '<' is less that 70% of a normal lowercase width
                        if ((statsWithoutCurrentAndNext->averageWidthNormalLowercase.count >= 2)
                             && (r->next->rect.size.width <= statsWithoutCurrentAndNext->averageWidthNormalLowercase.average * 0.70)
                             // Space between no more than 10% 
                             && (spaceBetween <= statsWithoutCurrentAndNext->averageWidthNormalLowercase.average * 0.10)
                             && (spaceBetween <= totalWidth * 0.10)) {
                             doit = true;
                             ReplacingLog("ValidateLine: rule 0099 replacing [%c%c] with [%c] in word [%s] even though letters are glued in general on that line", (unsigned short)r->ch, (unsigned short)r->next->ch, newCh, toUTF8(r->word->text()).c_str());
                        }
                    }
                }
                // Adding test that the two letters form a single connected component
                if (results->imageTests) {
                    CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                    // Accept neighbor8
                    SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results, false, SINGLE_LETTER_VALIDATE_COMP_SIZE | SINGLE_LETTER_VALIDATE_SINGLE_COMP);
                    if (st == NULL)
                        doit = false;
                    else 
                        delete st;
                }
				if (doit) {
					float newWidth = rectRight(r->next->rect) - rectLeft(r->rect) + 1;
					// Adjust current rect.
					float maxTop = MAX(rectTop(r->rect), rectTop(r->next->rect));
					float minBottom = MIN(rectBottom(r->rect), rectBottom(r->next->rect));
					float newHeight = maxTop - minBottom + 1;
					float newBottom = minBottom;
					CGRect newRect(rectLeft(r->rect), newBottom, newWidth, newHeight);
                    // One more check, to be on the safe side
                    doit = false;
                    CGRect bottomRect(rectLeft(newRect), rectBottom(r->next->rect), newRect.size.width, maxTop - rectBottom(r->next->rect) + 1);
                    r->flags3 |= FLAGS3_TESTED_AS_K;
                    SingleLetterTests *stBottom = CreateSingleLetterTests(bottomRect, results);
                    if (stBottom != NULL) {
                        OpeningsTestResults resTop;
                        bool success = stBottom->getOpenings(resTop, SingleLetterTests::Top, 
                            0.15,      // Start of range to search (top/left)
                            0.95,      // End of range to search (bottom/right)
                            SingleLetterTests::Bound,   // Require start (top/left) bound
                            SingleLetterTests::Bound  // Require end (bottom/right) bound
                            );
                        if (success 
                            // We accept 'z' as the 2nd letter but that's risky because 'z' is legitimately low so could be a real "lz" just touching a bit => be more strict in various tests
                            && ((r->next->ch != 'z') || (resTop.maxDepth > bottomRect.size.height * 0.15))) {
                            OpeningsTestResults resBottom;
                            bool success = stBottom->getOpenings(resBottom, SingleLetterTests::Bottom, 
                                0.15,      // Start of range to search (top/left)
                                0.95,      // End of range to search (bottom/right)
                                SingleLetterTests::Bound,   // Require start (top/left) bound
                                SingleLetterTests::Bound  // Require end (bottom/right) bound
                                );
                            if (success) {
                                // We accept 'z' as the 2nd letter but that's risky because 'z' is legitimately low so could be a real "lz" just touching a bit => be more strict in various tests
                                if (r->next->ch == 'z') {
                                    if (resBottom.maxDepth > bottomRect.size.height * 0.15)
                                        doit = true;
                                } else {
                                    doit = true;
                                }
                            }
                        }
                        delete stBottom;
                    } // st != NULL
                    if (doit) 
                    {
                        // Adjust to 'K'?
                        if ( ((r->previous == NULL) || (r->previous->ch == ' '))
                            || ((r->next->next != NULL) && isUpper(r->next->next->ch))
                            || ((r->next->previous != NULL) && isUpper(r->previous->ch)) ) {
                            newCh = 'K';
                        }
                        replaceTwoWithRect(r, newCh, newRect);
                        r = r->next;
                        continue;	// We don't expect other substitutions
                    }
				}
			}
            
            // Replace "c|" or "cl" with 'a'
			// Replace "ci" with 'd'
			// Replace "ci" with a
			if (isCLookalike(r->ch) && (lowHeightTest(statsWithoutCurrentAndNext.getPtr(), r->rect.size.height, 1, true, results) == 1)
                && !(r->flags & TESTED_AS_CL)
                // "<J" instead of 'a' where 'J' was as low as lowercase letters
                // "cr" instead of 'a'
				&& (r->next != NULL) && (isVerticalLine(r->next->ch) || (r->next->ch == 'J') || (r->next->ch == 'r'))
                && ((spaceBetween =  rectSpaceBetweenRects(r->rect, r->next->rect)) <= 0) 
                && (statsWithoutCurrentAndNext->averageSpacing.average > 0) && (statsWithoutCurrentAndNext->averageSpacing.average > spaceBetween)) 
            {
                // Refrain from doing the replacement if the next char IS actually a 'i'
                if ( ((r->next->ch == 'i') && (r->next->confidence == 0))
                    || ((results->imageTests) 
                        && (OCRUtilsSuggestLetterReplacement(r->next->rect, r->next->ch,
                                                             (((line->averageHeightNormalLowercase.count > 2) && (r->rect.size.height > line->averageHeightNormalLowercase.average * 1.36))? 0:maxHeightForSingleLetter),
                                                             results,
                            false, /* Don't force replace */
                            NULL   /* Don't need to know i body height here */) == 'i')) ) 
                {
                    ReplacingLog("ValidateLine: avoiding replacing [%c%c] based on validation of [%c] as [i] in [%s]", (unsigned short)r->ch, (unsigned short)r->next->ch, (unsigned short)r->next->ch, 
                                toUTF8(r->word->text()).c_str());
                    if (r->next->ch != 'i') {
                        r->word->updateLetterWithNewCharAndNewRect(r->next, 'i', r->next->rect);
                    }
                    r->next->confidence = 0;
                } else {
                    float newWidth = rectRight(r->next->rect) - rectLeft(r->rect) + 1;
                    bool abort = false;
                    char newCh = 'd';
                    if (isCloseOrSmallerThanAverage(line->averageHeightNormalLowercase, r->next->rect.size.height, 0.07)) {
                            newCh = 'a';
                    }

                    // Apply components test
                    if (results->imageTests
                        && (!(r->flags & TESTED_AS_CL))) 
                    {
                        r->flags |= TESTED_AS_CL;
                    
                        float minBottom = MIN(rectBottom(r->rect), rectBottom(r->next->rect));
                        float maxTop = MAX(rectTop(r->rect), rectTop(r->next->rect));
                        float newHeight = maxTop - minBottom + 1;
                        CGRect bothRect (rectLeft(r->rect),
                            minBottom,
                            newWidth,
                            newHeight);
                        SingleLetterTests* st = CreateSingleLetterTests(bothRect, results);
        
                        if (st != NULL) {
                            ConnectedComponentList cpl = st->getConnectedComponents();
            
                            // If there is only one component, we are done, this is a 'd'
                            // Not quite ... still need to test if c & l may be disconnected on top
                            if (cpl.size() == 2) {
                                // First chop off the top, to make sure it doesn't block the opening
                                // Why are we chopping the top when we are not sure it's a 'd'??? If it's a 'a', we are creating an opening by chopping like this!
                                // Doing it only if assumption is 'd' (tall next rect)
                                if (newCh == 'd') {
                                    CGRect bottomRect (rectLeft(bothRect), rectBottom(bothRect) + bothRect.size.height * 0.25, bothRect.size.width, bothRect.size.height * 0.75);
                                    SingleLetterTests *stBottom = CreateSingleLetterTests(bottomRect, results);
                                    if (stBottom != NULL) {
                                        OpeningsTestResults resTop;
                                        bool success = stBottom->getOpenings(resTop, SingleLetterTests::Top, 
                                            0,      // Start of range to search (top/left)
                                            1,      // End of range to search (bottom/right)
                                            SingleLetterTests::Bound,   // Require start (top/left) bound
                                            SingleLetterTests::Bound  // Require end (bottom/right) bound
                                            );
                                        if (success && (resTop.maxDepth > bottomRect.size.height * 0.45)) {
                                            ReplacingLog("ValidateLine: rule 0096 replacing - aborting [%c%c] to [d] replacement in word [%s] (found opening on top)", (unsigned short)r->ch, (unsigned short)r->next->ch, toUTF8(r->word->text()).c_str());
                                            abort = true;
                                        }
                                        delete stBottom;
                                    }
                                } // 'd'
                                else {
                                    OpeningsTestResults resTop;
                                    bool success = st->getOpenings(resTop, SingleLetterTests::Top,
                                        0.25,      // Start of range to search (top/left)
                                        0.90,      // End of range to search (bottom/right)
                                        SingleLetterTests::Bound,   // Require start (top/left) bound
                                        SingleLetterTests::Bound  // Require end (bottom/right) bound
                                        );
                                    if (success && (resTop.maxDepth > bothRect.size.height * 0.45)) {
                                        ReplacingLog("ValidateLine: rule 0096 replacing - aborting [%c%c] to [d] replacement in word [%s] (found opening on top)", (unsigned short)r->ch, (unsigned short)r->next->ch, toUTF8(r->word->text()).c_str());
                                        abort = true;
                                    }
                                } // 'a'
                            } else if (cpl.size() > 2) {
                                // Get 2 main components
                                ConnectedComponent majorComp = cpl[1];
                                ConnectedComponent minorComp = cpl[2];
                                
                                // Make sure the minor comp is not some small thing
                                if (minorComp.area > majorComp.area * 0.20) {
                                    // Why all these other conditions?! 20% of size of first comp IS a serious other component not to be ignored ...
                                    /* // Minor starts past the midpoint of major
                                    && (minorComp.xmin > (majorComp.xmin + majorComp.getWidth()/2))
                                    && (minorComp.getHeight() > majorComp.getHeight())) { */
                                    ReplacingLog("ValidateLine: rule 0096 replacing - aborting [%c%c] to [%c] replacement in word [%s] (found two components)", (unsigned short)r->ch, (unsigned short)r->next->ch, (unsigned short)r->ch, toUTF8(r->word->text()).c_str());
                                    abort = true;
                                }
                                // Now also test that we don't have an opening on top
                                // Careful: need to truncate the top part of the '1' that follow, it may block the opening. Set height to 'c' height
                                if (!abort) {
                                    CGRect bothRectLow(rectLeft(bothRect), rectBottom(r->rect), bothRect.size.width, r->rect.size.height);
                                    SingleLetterTests *stLow = CreateSingleLetterTests(bothRectLow, results);
                                    if (stLow != NULL) {
                                        OpeningsTestResults resTop;
                                        bool success = stLow->getOpenings(resTop, SingleLetterTests::Top, 
                                            0.1,      // Start of range to search (top/left)
                                            0.9,      // End of range to search (bottom/right)
                                            SingleLetterTests::Bound,   // Require start (top/left) bound
                                            SingleLetterTests::Bound  // Require end (bottom/right) bound
                                            );
                                        if (success && (resTop.maxDepth > r->rect.size.height * 0.20)) {
                                            ReplacingLog("ValidateLine: rule 0096 replacing - aborting [%c%c] to [%c] replacement in word [%s] (found opening on top)", (unsigned short)r->ch, (unsigned short)r->next->ch, (unsigned short)r->ch, toUTF8(r->word->text()).c_str());
                                            abort = true;
                                        }
                                        delete stLow;
                                    } // stLow != NULL
                                }
                            } // cpl.size() > 2
                            delete st;
                        } // st != NULL 
                    } // results->imageTests
                    else {
                        if ( (line->averageWidth.count >= 3)
                            && (indexCloserValToVal1OrVal2(newWidth, statsWithoutCurrentAndNext->averageWidth.average, statsWithoutCurrentAndNext->averageWidth.average*2 + statsWithoutCurrentAndNext->averageSpacing.average) == 1)) 
                        {
                            abort = true;
                        } 
                    }
                    if (!abort) {
                        replaceTwo(r, newCh, "rule 0096"); // = 'a' or = 'd'
                        // Skip next char (replaced)
                        r = r->next;
                        continue;	// We don't expect other substitutions
                    } // !abort
                } // next char not a 'i'
            } // cl -> d basic prerequisite

			// Map 'f' to 'r' when too short
			if ((r->ch == 'f') && (tallHeightTest(statsWithoutCurrent.getPtr(), r->rect.size.height, 'r', false, 2, true) == 0)
				 && !isTallRelativeToNeigbors(r, r->rect.size.height, false)) {
				char newCh = 'r';
				ReplacingLog("ValidateLine: rule 0153 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
				r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
				makeAnotherPass = true;
			}

			// Check for 'F{' that's actually a 'R'
			if ((r->ch == 'F') && (r->next != NULL) && (r->next->ch == '{')) 
            {
                replaceTwo(r, 'R');
				// Allow other combinations with this new letter(s)
				makeAnotherPass = true;
			}

			if ((r->ch == '_') && (r->next != NULL) && (r->next->ch == '_')
				&& ( isClose(line->averageWidthLowercase, rectRight(r->next->rect) - rectLeft(r->rect), 0.18)
					|| isClose(line->averageWidthLowercase, rectRight(r->next->rect) - rectLeft(r->rect), 0.18)
					)
				)
			{
				// Remove the 2nd '_'
				ReplacingLog("ValidateLine: rule 0154 replacing [%c%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)r->next->ch, (unsigned short)r->ch, toUTF8(r->word->text()).c_str());
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
				r->word->removeLetter(r->next);
                // Adjust current rect
                r->word->updateLetterWithNewCharAndNewRect(r, r->ch, combinedRect);
				// Allow other combinations with this new letter(s)
				makeAnotherPass = true;
			}

			if ((r->ch == '_') || ((r->ch == '.') && (r->rect.size.width > 2))) {
				// Map '_[' or '_]' or '_/' to 'J'
				// Map '.l' to 'J'
				if ((r->next != NULL) && ((r->next->ch == '[') || (r->next->ch == ']') || (r->next->ch == 'l') || (r->next->ch == 'i') || (r->next->ch == '|') || (r->next->ch == 'I') || (r->next->ch == '/'))) {
					float spaceBetween = rectLeft(r->next->rect) - rectRight(r->rect) - 1;
					float gapAboveBase = rectTop(r->next->rect)-rectTop(r->rect);
					
					// Accept even if line has negative or zero spacing when at word start (e.g ".l" at start makes no sense)
					if ((spaceBetween <= 0) && ((line->averageSpacing.average > spaceBetween) || (r->previous == NULL) || (r->previous->ch == ' '))
						&& ((r->ch != '.')
							|| (gapAboveBase < r->next->rect.size.height * 0.10) ))
                    {
                        // Sometimes the '_' just needs to be removed
                        if (rectLeft(r->rect) >= rectLeft(r->next->rect)) {
                            ReplacingLog("ValidateLine: rule 0155 replacing - eliminating [%c] in word [%s]", (unsigned short)r->ch, toUTF8(r->word->text()).c_str());
                            SmartPtr<OCRRect> p = r->next; // Save r->next
                            r->word->removeLetter(r);
                            r = p;
                            makeAnotherPass = true;
                            continue;
                        } else 
                        {
                            char newCh = 'J';
                            if ( (r->next->ch == 'i')
                                || ((line->averageHeightNormalLowercase.count >= 2) && (line->averageHeightUppercase.count >= 2)
                                && (indexCloserValToAv1OrAv2(r->next->rect.size.height, line->averageHeightNormalLowercase,
                                                             line->averageHeightUppercase) == 1)) ) {
                                newCh = 'j';
                            }
                            float newWidth = rectRight(r->next->rect) - rectLeft(r->rect);
                            float minBottom = MIN(rectBottom(r->rect), rectBottom(r->next->rect));
                            float maxTop = MAX(rectTop(r->rect), rectTop(r->next->rect));
                            float newHeight = maxTop - minBottom + 1;
                            float newBottom = minBottom;
                            CGRect newRect(rectLeft(r->rect), newBottom, newWidth, newHeight);

                            // Replace
                            ReplacingLog("ValidateLine: rule 0156 replacing [%c%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)r->next->ch, newCh,
                                         toUTF8(r->word->text()).c_str());
                            // remember next height before removing (for test later)
                            float nextHeight = r->next->rect.size.height;
                            r->word->removeLetter(r->next);
                            r->word->updateLetterWithNewCharAndNewRect(r, newCh, newRect);
                            if ((newCh == 'J') && (((r->previous != NULL) 
                                                && (r->previous->ch != ' ')) || (line->averageHeightUppercase.count == 0))
                                && (gapBelow(r,1) > nextHeight * 0.18)) {
                                ReplacingLog("ValidateLine: rule 0082 change of mind - replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, 'j', toUTF8(r->word->text()).c_str());
                                r->word->updateLetterWithNewCharAndNewRect(r, 'j', newRect);
                            }
                            r = r->next;
                            continue;
                        }
					}
				}
			}
            
			// Matching: '-' or '~' not wider than it is taller
			// Mapping to: '.' or ','
			if ((r->ch == '-') || (r->ch == '~')) {
                bool doit = false;
                char newCh = '.';
                if (r->rect.size.height >= r->rect.size.width) {
                    doit = true;
                    if (r->rect.size.height >= r->rect.size.width * OCR_MAX_H_TO_W_RATIO_DOT) {
                        gapBelowBaseline = gapBelow(r,1); 
                        if ((gapBelowBaseline != -1000) && (gapBelowBaseline > r->rect.size.height * OCR_MIN_GAPBELOW_LINE_COMMA_STRICT))
                            newCh = ',';
                    }
                }
                else if (r->rect.size.height >= r->rect.size.width * 0.54) {
                    // Slighly wider than it is tall, but perhaps hugging the bottom?
                    float gap = gapAboveBaselinePercent (r, r->rect, true);
                    if ((gap > -1000) && (gap < 0.10)) {
                        doit = true;
                        // Could it be a underscore?
                        // Must be quite a bit wider
                        if ( (r->rect.size.width > r->rect.size.height * 2.5) 
                            && (((statsWithoutCurrent->averageWidthNormalLowercase.count >= 2) 
                                && (r->rect.size.width > statsWithoutCurrent->averageWidthNormalLowercase.average * 0.65))
                              || ((statsWithoutCurrent->averageWidthUppercase.count >= 2) 
                                && (r->rect.size.width > statsWithoutCurrent->averageWidthUppercase.average * 0.65)))
                           ) {
                              newCh = '_';
                        }
                    }
                }
                CGRect newRect = r->rect;
                if (doit && (newCh == '.')) {
                    // Possible ':'
                    // Adjust rect up/down
                    CGRect referenceRect (0,0,0,0);
                    if ((r->previous != NULL) && (r->previous->ch != ' ') && (r->previous->rect.size.height > results->globalStats.averageHeightDigits.average * 0.75)) {
                        referenceRect = r->previous->rect;
                    } else if ((r->next != NULL) && (r->next->ch != ' ') && (r->next->rect.size.height > results->globalStats.averageHeightDigits.average * 0.75)) {
                        referenceRect = r->next->rect;
                    }
                    float minY = rectBottom(referenceRect); if (rectBottom(r->rect) < minY) minY = rectBottom(r->rect);
                    float maxY = rectTop(referenceRect); if (rectTop(r->rect) > maxY) maxY = rectTop(r->rect);
                    newRect = CGRect(rectLeft(r->rect), minY, r->rect.size.width, maxY - minY + 1);
                    SingleLetterTests *st = CreateSingleLetterTests(newRect, results);
                    if (st != NULL) {
                        ConnectedComponentList cpl = st->getConnectedComponents();
                        if (cpl.size() == 3) {
                            ConnectedComponent ccTop, ccBottom;
                            if (cpl[1].ymax < cpl[2].ymin) {
                                ccTop = cpl[1]; ccBottom = cpl[2];
                            } else {
                                ccTop = cpl[2]; ccBottom = cpl[1];
                            }
                            if ((ccTop.getHeight() < ccBottom.getHeight() * 2)
                                && (ccBottom.getHeight() < ccTop.getHeight() * 2)
                                && (ccBottom.ymin - ccTop.ymax - 1 > ccTop.getHeight() * 0.75)
                                && (ccBottom.ymin - ccTop.ymax - 1 > ccBottom.getHeight() * 0.75)) {
                                newCh = ':';
                            }
                        }
                        delete st;
                    }
                }
                if (doit) {
                    ReplacingLog("ValidateLine: rule 0083 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, newRect);
                    // Allow other combinations with this new letter(s)
                    makeAnotherPass = true;
                }
			}

			// Map "yy" to 'w'
			if ((r->ch == 'y') && (r->next != NULL) && (r->next->ch == 'y')
				// TODO add a width check that "yy" is as wide as we expect from "w"
				&& isClose(statsWithoutCurrent->averageWidthLowercase, rectRight(r->next->rect) - rectLeft(r->rect), 0.18)
				)
			{
				// Remove the 2nd 'y'
				ReplacingLog("ValidateLine: rule 0084 replacing [%c%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)r->next->ch, (unsigned short)r->ch, toUTF8(r->word->text()).c_str());
				r->word->removeLetter(r->next);
				// Allow other combinations with this new letter(s)
				makeAnotherPass = true;
			}

			// [d<] with [ck]
			if ((r->ch == 'd') && (r->next != NULL) && (r->next->ch == '<')
				&& ( isClose(statsWithoutCurrent->averageWidthLowercase, (rectRight(r->next->rect) - rectLeft(r->rect) - statsWithoutCurrent->averageSpacing.average)/2, 0.18)
					|| isClose(line->averageWidthLowercase, (rectRight(r->next->rect) - rectLeft(r->rect) - statsWithoutCurrent->averageSpacing.average)/2, 0.18)
					)
				)
			{
				// Replace with 'c' + k'
				char newCh1 = 'c';
				char newCh2 = 'k';
				ReplacingLog("ValidateLine: rule 0157 replacing [%c%c] with [%c%c] in word [%s]", (unsigned short)r->ch, (unsigned short)r->next->ch, newCh1, newCh2, toUTF8(r->word->text()).c_str());
				r->word->updateLetterWithNewCharAndNewRect(r, newCh1, r->rect);
				r->word->updateLetterWithNewCharAndNewRect(r->next, newCh2, r->next->rect);
				r = r->next;
				// Allow other combinations with this new letter(s)
				makeAnotherPass = true;
			}

			// 'l'T\' instead of 'm' in a standalone '.com'
			if (((r->ch == 'l') || (r->ch == '|')) && isCloseOrSmallerThanAverage(statsWithoutCurrent->averageHeightNormalLowercase, r->rect.size.height, 0.08)
				&& (r->next != NULL) && (r->next->ch == '\'')
				&& (r->next->next != NULL) && (r->next->next->ch == 'T') && isCloseOrSmallerThanAverage(statsWithoutCurrent->averageHeightNormalLowercase, r->next->next->rect.size.height, 0.08)
				&& (r->next->next->next != NULL) && ((r->next->next->next->ch == '\\') || (r->next->next->next->ch == '1') || (r->next->next->next->ch == '|') || (r->next->next->next->ch == 'I')) && isCloseOrSmallerThanAverage(statsWithoutCurrent->averageHeightNormalLowercase, r->next->next->next->rect.size.height, 0.08)
				) {
				// Replace with [m]
				char newCh = 'm';
				float newWidth = rectLeft(r->next->next->next->rect) - rectLeft(r->rect) + 1;
				float maxTop = MAX(MAX(MAX(rectTop(r->rect), rectTop(r->next->rect)), rectTop(r->next->next->rect)), rectTop(r->next->next->next->rect));
				float minBottom = MIN(MIN(MIN(rectBottom(r->rect), rectBottom(r->next->rect)), rectBottom(r->next->next->rect)), rectBottom(r->next->next->next->rect));
				float newHeight = maxTop - minBottom + 1;
				float newBottom = minBottom;
				CGRect newRect(rectLeft(r->rect), newBottom, newWidth, newHeight);
				ReplacingLog("OCRUtilsValidate: replacing [%c%c%c%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)r->next->ch, (unsigned short)r->next->next->ch, (unsigned short)r->next->next->next->ch, newCh, toUTF8(r->word->text()).c_str());
				r->word->removeLetter(r->next->next->next);
				r->word->removeLetter(r->next->next);
				r->word->removeLetter(r->next);
				r->word->updateLetterWithNewCharAndNewRect(r, newCh, newRect);
				r = r->next;
				continue;
			}

			if ((r->ch == 'V') && (r->next != NULL) && (r->next->ch == '\\')
				&& (r->next->next != NULL) && (r->next->next->ch == 'h')
				&& (r->next->next->next != NULL) 
				&& (isLower(r->next->next->next->ch) || (isVerticalLine(r->next->next->next->ch) 
														 && (r->next->next->next->next->next != NULL) 
														 && isLower(r->next->next->next->next->ch)))) {
				float space1 = rectLeft(r->next->rect) - rectRight(r->rect) - 1;
				float space2 = rectLeft(r->next->next->rect) - rectRight(r->next->rect) - 1;
				if ((space1 <= 0) && (space2 <= 0) && (statsWithoutCurrentAndNextTwo->averageSpacing.average > 0)) {
					float maxTop = MAX(rectTop(r->rect), rectTop(r->next->rect));
					 maxTop = MAX(maxTop, rectTop(r->next->next->rect));
					float minBottom = MIN(rectBottom(r->rect), rectBottom(r->next->rect));
					 minBottom = MIN(minBottom, rectBottom(r->next->next->rect));
					float newHeight1 = maxTop - minBottom + 1;
					// i a bit lower than uppercase letters
					float newHeight2 = newHeight1 * 0.60;
					float newWidth2 = (r->next->next->rect.size.width / 2) - 1;
					float newWidth1 = rectRight(r->next->next->rect) - rectLeft(r->rect) + 1
						// minus half the width of the 'h' and 1 for spacing
						- newWidth2 - 1;

					char newCh1 = 'W';
					CGRect newRect1(rectLeft(r->rect), minBottom, newWidth1, newHeight1);

					char newCh2 = 'i';
					CGRect newRect2(rectRight(r->next->next->rect) - newWidth2 - 1, maxTop - newHeight2 + 1, newWidth2, newHeight2);
					ReplacingLog("Validate: rule 0109 replacing [%c%c] with [%c%c] in word [%s]", (unsigned short)r->ch, (unsigned short)r->next->ch, newCh1, newCh2, toUTF8(r->word->text()).c_str());
					r->word->updateLetterWithNewCharAndNewRect(r, newCh1, newRect1);
					r->word->updateLetterWithNewCharAndNewRect(r->next->next, newCh2, newRect2);
					r->word->removeLetter(r->next);
					r = r->next;
					makeAnotherPass = true;
				}
			}
			// Testing: '|n|' with 'w' left or right
			// Replacing with: 'w' or 'W'
			else if (((r->ch == 'l') || (r->ch == '|') || (r->ch == '\\'))
				&& (r->next != NULL) && (r->next->ch == 'n')
				&& (r->next->next != NULL) && ((r->next->next->ch == 'l') || (r->next->next->ch == '|') || (r->next->next->ch == '/'))
				&& ( ((r->next->next->next != NULL) && (toLower(r->next->next->next->ch) == 'w'))
				    || ((r->previous != NULL) && (toLower(r->previous->ch) == 'w')) )
			    ) {
				char newCh = 'w';
				if (((r->previous != NULL) && (r->ch == 'W')) || ((r->next->next->next != NULL) && (r->next->next->next->ch == 'W'))) {
					newCh = 'W';
				}
				float newWidth = rectRight(r->next->next->rect) - rectLeft(r->rect) + 1;
				// Adjust current rect
				float newHeight = r->rect.size.height;
				float newBottom = rectBottom(r->rect);
				CGRect newRect(rectLeft(r->rect),
											newBottom,
											newWidth,
											newHeight);
				ReplacingLog("OCRUtilsValidate: rule 0110 replacing [%c%c%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)r->next->ch, (unsigned short)r->next->next->ch, newCh, toUTF8(r->word->text()).c_str());
				r->word->removeLetter(r->next->next);
				r->word->removeLetter(r->next);
				r->word->updateLetterWithNewCharAndNewRect(r, newCh, newRect);
				if ((r->previous != NULL) && (toLower(r->previous->ch) == 'w')) {
					r->confidence = 0; // Protect it from our space handling that follows
				}
				makeAnotherPass = true;
			}

			// Testing: '\x/' or '\n/'
			// Replacing with: 'w' or 'W'
			if (r->ch == '\\') {
				if ((r->next != NULL) && ((r->next->ch == 'x') || (r->next->ch == 'n'))
				    && (r->next->next != NULL) && (r->next->next->ch == '/')) {
					char newCh = 'w';
					float newWidth = rectRight(r->next->next->rect) - rectLeft(r->rect);
					// Adjust current rect
					float maxTop = MAX(rectTop(r->next->next->rect), rectTop(r->rect));
					float minBottom = MIN(rectBottom(r->next->next->rect), rectBottom(r->rect));
					float newHeight = maxTop - minBottom;
					if (tallHeightTest(statsWithoutCurrent.getPtr(), newHeight,'W', false, 0,false) == 1) {
						newCh = 'W';
					}
					float newBottom = minBottom;
					CGRect newRect(rectLeft(r->rect),
												newBottom,
												newWidth,
												newHeight);
					ReplacingLog("OCRUtilsValidate: rule 0111 replacing [%c%c%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)r->next->ch, (unsigned short)r->next->next->ch, newCh, toUTF8(r->word->text()).c_str());
					r->word->removeLetter(r->next->next);
					r->word->removeLetter(r->next);
					r->word->updateLetterWithNewCharAndNewRect(r, newCh, newRect);
					makeAnotherPass = true;
				} else if ((r->next != NULL) && (r->next->ch == 'N')) {
					// Testing: "\N"
					// Replacing with: 'W' or 'w'
					char newCh = 'w';
					if (tallHeightTest(statsWithoutCurrent.getPtr(), r->next->rect.size.height, 'W', false, 0, false) == 1) {
						newCh = 'W';
					}
					replaceTwo(r, newCh, "rule 0112");
					makeAnotherPass = true;
				}
			}

			if (r->ch == 'm') 
            {
				if ((r->next != NULL) && (r->next->ch == '/')) {
					// Testing: "m/"
					// Replacing with: "ny"
					float maxTop = MAX(rectTop(r->rect), rectTop(r->next->rect));
					float minBottom = MIN(rectBottom(r->rect), rectBottom(r->next->rect));
					float newHeight2 = maxTop - minBottom + 1;
					bool flushOnTop = (abs(rectBottom(r->next->rect)-rectBottom(r->rect)) < 0.08*r->rect.size.height);
					bool longBelow = ((rectTop(r->next->rect)-rectTop(r->rect)) > 0.20*r->rect.size.height);
					if (flushOnTop && longBelow && (tallHeightTest(statsWithoutCurrent.getPtr(), newHeight2,'y', false, 1,false) == 1)) {
						float newWidth = (rectRight(r->next->rect) - rectLeft(r->rect) + 1 - line->averageSpacing.average) / 2;
						if (newWidth < OCR_MIN_WIDTH) {
							newWidth = (rectRight(r->next->rect) - rectLeft(r->rect)) / 2 - 1;
						}
						float newHeight1 = statsWithoutCurrent->averageHeightNormalLowercase.average;
						if (newHeight1 == 0)
							newHeight1 = statsWithoutCurrent->averageHeightUppercase.average / OCR_TALL_TO_LOWERCASE_RATIO;
						if (newHeight1 == 0)
							newHeight1 = statsWithoutCurrent->averageHeightDigits.average / OCR_TALL_TO_LOWERCASE_RATIO;
						if (newHeight1 == 0)
							newHeight1 = statsWithoutCurrent->averageHeightTallLowercase.average / OCR_TALL_TO_LOWERCASE_RATIO;
						if (newHeight1 == 0)
							newHeight1 = OCR_MIN_HEIGHT_NORMALLOWERCASE;
						float newBottom1 = maxTop - newHeight1 + 1;
						float newBottom2 = minBottom;

						char newCh1 = 'n';
						CGRect newRect1(rectLeft(r->rect), newBottom1, newWidth, newHeight1);

						char newCh2 = 'y';
						CGRect newRect2(rectRight(r->next->rect) - newWidth + 1, newBottom2, newWidth, newHeight2);
						ReplacingLog("Validate: replacing [%c%c] with [%c%c] in word [%s]", (unsigned short)r->ch, (unsigned short)r->next->ch, newCh1, newCh2, toUTF8(r->word->text()).c_str());
						r->word->updateLetterWithNewCharAndNewRect(r, newCh1, newRect1);
						r->word->updateLetterWithNewCharAndNewRect(r->next, newCh2, newRect2);
						r = r->next;
						makeAnotherPass = true;
					}
				}
			}
			if (r->ch == ':') {
				if ((r->previous != NULL) && isDigit(r->previous->ch)
					&& ((r->next != NULL) && (r->next->ch == 'h'))
					&& (r->rect.size.height > statsWithoutCurrent->averageHeightNormalLowercase.average)) {
					// Replace with 'T'
					char newCh = 't';
					ReplacingLog("Validate: rule 0537 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
					r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
					makeAnotherPass = true;
				}
				// Testing: ':r'
				// Replacing with: 'T'
				else if ((r->next != NULL) && (r->next->ch == 'r')
					&& isCloseOrGreaterThanAverage(line->averageHeightUppercase, MIN(r->rect.size.height,r->next->rect.size.height), 0.08))	{
					replaceTwo(r, 'T');
					makeAnotherPass = true;
				}
			}

			// Matching: ','
			// Replacing with: '.' if not tall relative to width
			if ((r->ch == ',') && !(r->flags5 & FLAGS5_TESTED_AS_DOT) && results->imageTests && (r->rect.size.height < r->rect.size.width * 1.34))
            {
                bool doit = true;
                gapBelowBaseline = gapBelow(r,1); 
                r->flags5 |= FLAGS5_TESTED_AS_DOT;
                SingleLetterTests *st =  CreateSingleLetterTests(r->rect, results);
                if (st != NULL) 
                {
                    ConnectedComponentList cpl = st->getConnectedComponents();
                    if (cpl.size() == 2) {
                        if ((cpl[1].getHeight() != r->rect.size.height) || (cpl[1].getWidth() != r->rect.size.width)) {
                            // Update rect to actual values
                            CGRect newRect(rectLeft(r->rect) + cpl[1].xmin, rectBottom(r->rect) + cpl[1].ymin, cpl[1].getWidth(), cpl[1].getHeight());
                            ReplacingLog("Validate: updating [%c] rect from [%d,%d] to [%d,%d] in word [%s]", (unsigned short)r->ch, (unsigned int)r->rect.size.width, (unsigned int)r->rect.size.height, (unsigned int)cpl[1].getWidth(), (unsigned int)cpl[1].getHeight(), toUTF8(r->word->text()).c_str());
                            r->word->updateLetterWithNewCharAndNewRect(r, r->ch, newRect);
                        }
                    } else {
                        doit = false;
                    }
                } else {
                    doit = false;
                }
                if (doit) 
                {
                    // Not much taller than it is wide
                    // Real comma had h=11 and w=9 (1.22%)
                    if (  ( (r->rect.size.height < r->rect.size.width * 1.21) 
                            // Not much below baseline
                            // Real comma had h=11 and was below by 5 (45%)
                            // Real comma had h=11 and was below by 4 (36%)
                            && (gapBelowBaseline != -1000) && (gapBelowBaseline < r->rect.size.height * OCR_MIN_GAPBELOW_LINE_COMMA_STRICT)
                          )
                          // Or, still not very tall AND less than half of the height is below the baseline
                        || ((r->rect.size.height < r->rect.size.width * 1.34) && (gapBelowBaseline < r->rect.size.height * 0.25)) 
                       ) 
                    {
                        char newCh = '.';
                        
                        // If taller than wide, there is a good chance it IS a comma
                        if (r->rect.size.height > r->rect.size.width) 
                        {
                            OpeningsTestResults resLeft;
                            bool success = st->getOpenings(resLeft, SingleLetterTests::Left, 
                                0,      // Start of range to search (top/left)
                                1,      // End of range to search (bottom/right)
                                SingleLetterTests::Bound,   // Require start (top/left) bound
                                SingleLetterTests::Bound  // Require end (bottom/right) bound
                                );
                            if (success) {
                                doit = false;
                            }
                        } // height > width
                        
                        if (doit) {
                            ReplacingLog("Validate: rule 0086 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                            r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                            makeAnotherPass = true;
                            // ATTENTION: re-do the pass on this letter because of various tests looking for .coxxx etc
                            // It will not be an endless loop because this test will not match again
                            if (st != NULL)
                                delete st;
                            continue;
                        }
                    }
                } // doit
                if (st != NULL)
                    delete st;
            }
            
            // ',' instead of 'r'
            if ((r->ch == ',') && (results->imageTests) && !(r->flags2 & FLAGS2_TESTED_AS_r) && (statsWithoutCurrent->averageHeightNormalLowercase.count > 1) && (r->rect.size.height > statsWithoutCurrent->averageHeightNormalLowercase.average * (1 - OCR_ACCEPTABLE_ERROR_LOWHURDLE))) {
                r->flags2 |= FLAGS2_TESTED_AS_r;
                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results, false, SINGLE_LETTER_VALIDATE_COMP_SIZE | SINGLE_LETTER_VALIDATE_SINGLE_COMP);
                bool doit = false;
                if (st != NULL) {
                    ConnectedComponentList cpl = st->getConnectedComponents();
                    if (cpl.size() == 2) {
                        CGRect newRect (rectLeft(r->rect)+cpl[1].xmin, rectBottom(r->rect)+cpl[1].ymin, cpl[1].getWidth(), cpl[1].getHeight());
                        // Still tall enough after checking the actual size of the main component
                        if ((newRect.size.height == r->rect.size.height) || (newRect.size.height > statsWithoutCurrent->averageHeightNormalLowercase.average * (1 - OCR_ACCEPTABLE_ERROR_LOWHURDLE))) {
                            doit = true;
                        }
                        // Test gap below
                        if (doit) {
                            float gap = gapBelow(r, 1, statsWithoutCurrent);
                            if (gap >= newRect.size.height * 0.15)
                                doit = false; // Too much below line (like a real comma)
                        }
                        // Test size also versus adjacent letters
                        if (doit && (r->previous != NULL)) {
                            if (isLower(r->previous->ch)) {
                                if (!isTallLowercase(r->previous->ch) && (newRect.size.height < r->previous->rect.size.height * (1 - OCR_ACCEPTABLE_ERROR_LOWHURDLE)))
                                    doit = false;
                            }
                        }
                        if (doit && (r->next != NULL)) {
                            if (isLower(r->next->ch)) {
                                if (!isTallLowercase(r->next->ch) && (newRect.size.height < r->next->rect.size.height * (1 - OCR_ACCEPTABLE_ERROR_LOWHURDLE)))
                                    doit = false;
                            }
                        }
                        if (doit) {
                            char newCh = 'r';
                            ReplacingLog("Validate: rule 0044 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                            r->word->updateLetterWithNewCharAndNewRect(r, newCh, newRect);
                            makeAnotherPass = true;
                        }
                    }
                    delete st;
                } // st != NULL
            }

			// Matching: '_'
			// Replacing with: '.' is not wide enough relative to height
			if ((r->ch == '_') && (r->rect.size.width < r->rect.size.height * 1.35)) {
				char newCh = '.';
				ReplacingLog("Validate: rule 0085 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
				r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
				// ATTENTION: re-do the pass on this letter because of various tests looking for .coxxx etc
				// It will not be an endless loop because this test will not match again
				makeAnotherPass = true;
				continue;
			}
            
            // '(' instead of 't', resting on baseline (i.e. suspect)
            if ((r->ch == '(') && !(r->flags4 & FLAGS4_TESTED_AS_t) && !OCRLine::isPresentInLineAfterRect(')', r) && (tallHeightTest(statsWithoutCurrent.getPtr(), r->rect.size.height, 't', false, 1, true) == 1)) {
                r->flags4 |= FLAGS4_TESTED_AS_t;
                bool doit = false;
                if ((r->next != NULL) && (isLower(r->next->ch) && !isTallLowercase(r->next->ch) && (rectTop(r->rect) - rectTop(r->next->rect) < r->next->rect.size.height * 0.10)))
                    doit = true;
                if (doit && (r->previous != NULL) && (isLower(r->previous->ch) && !isTallLowercase(r->previous->ch) && (rectTop(r->rect) - rectTop(r->previous->rect) < r->previous->rect.size.height * 0.10)))
                    doit = true;
                // Make a guess but request single-letter testing!
                char newCh = 't';
                ReplacingLog("Validate: rule 0122 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                r->confidence += 500;
            }

			// Testing: "'I'" or "'l`"
			// Replacing with: 'T'
			// Require I to have uppercase height and trio to have the width of an uppercase T
			if ((r->ch == '\'')
				&& (r->next != NULL) && ((r->next->ch == 'I') || (r->next->ch == 'l'))
				&& (r->next->next != NULL) && ((r->next->next->ch == '\'') || (r->next->next->ch == '`'))
				&& isClose(line->averageWidthUppercase, rectRight(r->next->next->rect) - rectLeft(r->rect) + 1, 0.2)
				)
			{
				float minY = MIN(rectBottom(r->rect), rectBottom(r->next->rect));
				minY = MIN(minY, rectBottom(r->next->next->rect));
				float maxY = MAX(rectTop(r->rect), rectTop(r->next->rect));
				maxY = MAX(maxY, rectTop(r->next->next->rect));
				float newHeight = maxY - minY + 1;
				if ((lowHeightTest(statsWithoutCurrent.getPtr(), newHeight, 0,false, results) != 1)
					// Adding the 2nd clause in case there are no lowercase chars, then ignore the height test
					|| (statsWithoutCurrent->averageHeightNormalLowercase.count == 0)
					|| ((r->previous != NULL) && isupper(r->previous->ch) && (r->next->next->next != NULL) && isupper(r->next->next->next->ch))) {
					// Replace with 'T'
					char newCh = 'T';
					float newBottom = r->next->rect.origin.y;
					CGRect newRect (rectLeft(r->rect),
												newBottom,
												rectRight(r->next->next->rect) - rectLeft(r->rect) + 1,
												newHeight);
					ReplacingLog("Validate: replacing [%c%c%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)r->next->ch, (unsigned short)r->next->next->ch, newCh, toUTF8(r->word->text()).c_str());
					r->word->removeLetter(r->next->next);
					r->word->removeLetter(r->next);
					r->word->updateLetterWithNewCharAndNewRect(r, newCh, newRect);
					makeAnotherPass = true;
				}
			}

			// Testing:'|T\' instead of 'm'
			if (((r->ch == 'l') || (r->ch == '|') || (r->ch == 'I') || (r->ch == 'i')) && isCloseOrSmallerThanAverage(statsWithoutCurrent->averageHeightNormalLowercase, r->rect.size.height, 0.08)
				&& (r->next != NULL) && (r->next->ch == 'T') && isCloseOrSmallerThanAverage(statsWithoutCurrent->averageHeightNormalLowercase, r->next->rect.size.height, 0.08)
				&& (r->next->next != NULL)
				&& ((r->next->next->ch == '\\') || (r->next->next->ch == '1') || (r->next->next->ch == '|') || (r->next->next->ch == 'I') || (r->next->next->ch == ']')
					|| (r->next->next->ch == '[') || (r->next->next->ch == '}') || (r->next->next->ch == '{') || (r->next->next->ch == 'l'))) {
					float space1 = rectLeft(r->next->rect) - rectRight(r->rect) - 1;
					float space2 = rectLeft(r->next->next->rect) - rectRight(r->next->rect) - 1;
					float minBottom = MIN(MIN(rectBottom(r->rect), rectBottom(r->next->rect)),rectBottom(r->next->next->rect));
					float maxTop = MAX(MAX(rectTop(r->rect), rectTop(r->next->rect)),rectTop(r->next->next->rect));
					float newHeight = maxTop - minBottom + 1;

					if (statsWithoutCurrentAndNextTwo == NULL) {
						statsWithoutCurrentAndNextTwo = SmartPtr<OCRWord>(statsWithoutCurrent);
						statsWithoutCurrentAndNextTwo->updateStatsAddOrRemoveLetterAddingSpacingOnly(r->next, false, false);
						statsWithoutCurrentAndNextTwo->updateStatsAddOrRemoveLetterAddingSpacingOnly(r->next->next, false, false);
					}

					if ((space1 <= 0) && (space1 < statsWithoutCurrentAndNextTwo->averageSpacing.average)
						&& (space2 <= 0) && (space2 < statsWithoutCurrentAndNextTwo->averageSpacing.average)
						&& (tallHeightTest(statsWithoutCurrentAndNextTwo.getPtr(), newHeight, 0, false, 0, true) == 0)) {

						// Replace with [m]
						char newCh = 'm';
						float newWidth = rectLeft(r->next->next->rect) - rectLeft(r->rect);
						// Adjust current rect
						CGRect newRect(rectLeft(r->rect),
											// Midpoint bottom Y location between current and next
											minBottom,
											newWidth,
											newHeight);
						ReplacingLog("OCRUtilsValidate: replacing [%c%c%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)r->next->ch, (unsigned short)r->next->next->ch, newCh, toUTF8(r->word->text()).c_str());
						r->word->removeLetter(r->next->next);
						r->word->removeLetter(r->next);
						r->word->updateLetterWithNewCharAndNewRect(r, newCh, newRect);
						// No need to correct stats before removing, removeLetter does it
						r = r->next;
						continue;
					}
			}

			// Matching: "fl" or "ll"
			// Replacing with: 'n'
			if ((r->ch == 'f') && (r->next != NULL) && (r->next->ch == 'l')
				&& (tallHeightTest(statsWithoutCurrent.getPtr(), r->rect.size.height, 'f', false, 0, true) == 0)
				&& (tallHeightTest(statsWithoutCurrent.getPtr(), r->next->rect.size.height, 'l', false, 0, true) == 0)) {
				// Replace "rl" with 'n'
				replaceTwo(r, 'n'); // = 'n'
				makeAnotherPass = true;
			}

			// Map "rl" or "r|" to 'n'
			if ((r->ch == 'r') && (r->next != NULL) && isVerticalLine(r->next->ch)
				&& (tallHeightTest(statsWithoutCurrent.getPtr(), r->rect.size.height, 'n', false, 0, true) == 0)
                && (tallHeightTest(statsWithoutCurrent.getPtr(), r->next->rect.size.height, 'n', false, 0, true) == 0)
				// Frank Skubal: "Amerlca" where "rl" should NOT be mapped to 'n'
				&& (rectSpaceBetweenRects(r->rect, r->next->rect) <= 0)) 
            {
					// Replace 'rl' with 'n'
                    replaceTwo(r, 'n'); // = 'n'
					// Skip next char (replaced)
					r = r->next;
					if (r != NULL)
						r = r->next;
					makeAnotherPass = true;
					continue;	// We don't expect other substitutions
			}

			if ((r->ch == 'V') && (r->next != NULL) && (r->next->ch=='a')) {
				DebugLog("Found in word [%s]", toUTF8(r->word->text()).c_str());
                DebugLog("");
			}

			// Map "uJ" to 'w'
			if ((r->ch == 'u') && (r->next != NULL) && (r->next->ch == 'J')) {
				if ((line->averageHeightNormalLowercase.count >= 2)
					&& isCloseOrSmallerThanAverage(line->averageHeightNormalLowercase, r->next->rect.size.height, 0.07)) 
                {
					// Replace 'uJ' with 'w'
					replaceTwo(r, 'w', "rule 0106");
					// Skip next char (replaced)
					r = r->next;
					continue;	// We don't expect other substitutions
				}
			}

			// Mapping: 'v'
			// Replacing with: 'y' if tall + below line
            // Accepting also 'V' but on the condition that it be surrounded by lowercase or low letters
			if (((r->ch == 'v') || ((r->ch == 'V') && (r->previous != NULL) && (isLower(r->previous->ch) || (tallHeightTest(statsWithoutCurrent.getPtr(), r->previous->rect.size.height, '\0', false, 1, true) == 0)) && (r->next != NULL) && (isLower(r->next->ch) || (tallHeightTest(statsWithoutCurrent.getPtr(), r->next->rect.size.height, '\0', false, 1, true) == 0))))
                && (tallHeightTest(statsWithoutCurrent.getPtr(), r->rect.size.height, 'y', false, 2, false) == 1)
				&& (testBelowRelativeToNeigbors(r) == 1)) {
				char newCh = 'y';
				ReplacingLog("ValidateLine: rule 0158 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
				r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
				makeAnotherPass = true;
			}

			// Matching: 'z' (narrow)
			// Replacing with: ':'
			if ((r->ch == 'z')
                // Very, very narrow
				&& ((r->rect.size.height > r->rect.size.width * 3)
                    // Or very narrow compared to at least 2 supper narrow chars
                    || ((statsWithoutCurrent->averageWidthSuperNarrow1.count >= 2) && isCloseOrSmallerThanAverage(statsWithoutCurrent->averageWidthSuperNarrow1, r->rect.size.width, 0.07)
				// Very narrow compared to at least 2 normal width chars
                    && (statsWithoutCurrent->averageWidthNormalLowercase.count >= 2) && (r->rect.size.width < statsWithoutCurrent->averageWidthNormalLowercase.average * 0.33)))
				) {
				char newCh = ':';
				ReplacingLog("ValidateLine: rule 0160 replacing [%c] with [%c] in word [%ls]", (unsigned short)r->ch, newCh, r->word->text().c_str());
				r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
				makeAnotherPass = true;
			}

			// Map wwm to www. (only at start of word)
			if ( ((r->previous == NULL) || (r->previous->ch == ' '))
				 && (r->ch == 'w')
				 && (r->next != NULL) && (r->next->ch == 'w')
				 && (r->next->next != NULL) && (r->next->next->ch == 'm') ) {
				// Replace 'wwm' with 'www.'
				ReplacingLog("ValidateLine: rule 0087 replacing [%c%c%c] with [www.] in word [%ls]", (unsigned short)r->ch, (unsigned short)r->next->ch, (unsigned short)r->next->next->ch, r->word->text().c_str());
				// Average width of two leading 'w's
				char newCh1 = 'w';
				float newWidth = (r->rect.size.width + r->next->rect.size.width) / 2;
				CGRect newRect1(rectLeft(r->next->next->rect),
											rectBottom(r->next->next->rect),
											newWidth,
											r->next->next->rect.size.height);
				char newCh2 = '.';
				// Position the '.' after the 'w' + width + average spacing
				float newX = rectRight(newRect1) + line->averageSpacing.average;
				if (newX >= rectRight(r->next->next->rect)-3) {
					// Make sure the new char has at least a width of 3
					newX = rectRight(r->next->next->rect)-3;
				}
				float newWidth2 = rectRight(r->next->next->rect) - newX + 1;
				// Assume '.' has same height and width
				float newBottom2;
				newBottom2 = rectTop(r->next->next->rect) - newWidth2;
				CGRect newRect2(newX,
											newBottom2,
											newWidth2,
											newWidth2);
				r->word->updateLetterWithNewCharAndNewRect(r->next->next, newCh1, newRect1);
				r->word->addLetterWithRectConfidenceAfterRect(newCh2, newRect2, 0, r->next->next);
				r = r->next->next->next->next;
				continue;	// We don't expect other substitutions
			}

			// Map ''r' to 'T'
			if (((r->ch == '\'') || (r->ch =='`')) && (r->next != NULL) && (r->next->ch == 'r')
				&& (line->averageHeightUppercase.count >= 3) && isCloseOrGreaterThanAverage(line->averageHeightUppercase, r->next->rect.size.height, 0.11)) 
            {
				// Replace with 'T'
				replaceTwo(r, 'T', "rule 0113");
				r = r->next;
				continue;	// We don't expect other substitutions
			}

			// Map ")/" to 'y'
			if ((r->ch == ')') && (r->next != NULL) && (r->next->ch =='/') && !OCRLine::isPresentInLineBeforeRect('(', r)) {
				// Replace with 'y'
				// Adjust current rect. Use the height of the first char in this case.
				float newHeight = r->next->rect.size.height;
				float newBottom = rectBottom(r->next->rect);
				replaceTwo(r, 'y', "rule 0031", newBottom, newHeight);
				r = r->next;
				continue;	// We don't expect other substitutions
			}
		    else if (r->ch == '(') {
				// Testing: "()" or "(>"
				// Replacing with: '0' or 'o'/'O' or '6'
				if ( (r->next != NULL) && ((r->next->ch == ')') || (r->next->ch == '>') 
                                            || (((r->next->ch == 'J') || (r->next->ch == 'j')) && results->imageTests && !(r->flags2 & FLAGS2_TESTED)))) {
					float minY = MIN(rectBottom(r->rect), rectBottom(r->next->rect));
					float maxY = MAX(rectTop(r->rect), rectTop(r->next->rect));
					// Adjust current rect. Use the height of the first char in this case.
					float newHeight = maxY - minY;
                    CGRect combinedRect(rectLeft(r->rect), minY, rectRight(r->next->rect) - rectLeft(r->rect) + 1, newHeight);
                    // If next is 'J' do some more testing
                    bool doit = true;
                    if ((r->next->ch == 'J') || (r->next->ch == 'j')) {
                        doit = false;
                        r->flags2 |= FLAGS2_TESTED;
                        SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
                        if (st != NULL) {
                            ConnectedComponentList invertCpl = st->getInverseConnectedComponents();
                            if ((invertCpl.size() >= 2) && (invertCpl[1].getWidth() > combinedRect.size.width * 0.50) && (invertCpl[1].getHeight() > combinedRect.size.height * 0.50)) {
                                doit = true;
                            }
                            delete st;
                        } // st != NULL
                    }
                    if (doit) {
                        char newCh;
                        float gapBelowTop = rectBottom(r->next->rect) - rectBottom(r->rect);
                        if ((r->rect.size.height > r->next->rect.size.height*1.2) && (gapBelowTop > r->rect.size.height*0.25)) {
                            newCh = '6';
                        } else {
                            newCh = 'O';
                            // Require the presence of other digits for height test
                            if (tallHeightTest(statsWithoutCurrent.getPtr(), newHeight, '0', true, 0, true) == 1) {
                                if (((r->previous != NULL) && isDigit(r->previous->ch))
                                    || ((r->next != NULL) && isDigit(r->next->ch))) {
                                    newCh = '0';
                                } else {
                                    newCh = 'O';
                                }
                            } else if (lowHeightTest(statsWithoutCurrent.getPtr(), newHeight, 0, false, results) == 1) {
                                newCh = 'o';
                            }
                        }
                        replaceTwoWithRect(r, newCh, combinedRect);
                        makeAnotherPass = true;
                        r = r->next;
                        continue;	// We don't expect other substitutions
                    } // doit
				}
				// Testing: '(' (if no ')' later on line and if no digits on line
				// Replacing with: 'c' or 'C'
				else if (!OCRLine::isPresentInLineAfterRect(')', r) && (countDigits(r->word->text()) < 2)) {
					// Therapy (Christopher Barker), '(' was 16 wide, average was 27
					char newCh = ((tallHeightTest(statsWithoutCurrent.getPtr(), r->rect.size.height, 0, false, 0, true) == 1)?
								  (((statsWithoutCurrent->averageWidthUppercase.count == 0)
									|| (r->rect.size.width > statsWithoutCurrent->averageWidthUppercase.average * 0.57))? 'C':'\0'):
								  ((statsWithoutCurrent->averageWidthNormalLowercase.count == 0)
								   || (r->rect.size.width > statsWithoutCurrent->averageWidthNormalLowercase.average * 0.57))? 'c':'\0');

					if (newCh != 0) {
						ReplacingLog("ValidateLine: rule 0170 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
						r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
						makeAnotherPass = true;
					}
				}
			}
			// Matching: ')' at item start
			// Replacing with: 'j'
			else if ((r->ch == ')') && (r->previous == NULL))
			{
				if (round == 0) {
					makeAnotherPass = true;
				} else {
					// Replace with 'j' or 'J'
					wchar_t newCh = 'J';
                    SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                    if (st != NULL) {
                        ConnectedComponentList cpl = st->getConnectedComponents();
                        if (cpl.size() >= 3) {
                            ConnectedComponent dotCC = cpl[2];
                            ConnectedComponent mainCC = cpl[1];
                            if ((dotCC.area < mainCC.area * 0.10) && (dotCC.ymax < mainCC.ymin)) {
                                newCh = 'j';
                            }
                        }
                        delete st;
                    }
					ReplacingLog("ValidateLine: rule 0171 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)newCh, toUTF8(r->word->text()).c_str());
					r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
					r = r->next;
					continue;	// We don't expect other substitutions
				}
			}

			// Check for '|' in all-uppercase word or just between two uppercase letters
			if ((r->ch == '|')
				&& (sameHeightUppercase
								  || (((r->previous == NULL) || isupper(r->previous->ch))
									  && (r->next != NULL) && isupper(r->next->ch)
									  // Added test below just in case we were about to correct the next letter from say 'C' to 'c' based on height
								      && (tallHeightTest(statsWithoutCurrent.getPtr(), r->next->rect.size.height, 0, false, 0, true))
								     )
				   )
				 ) {
				char newCh = 'I';
				ReplacingLog("ValidateLine: rule 0173 replacing [%c] with [%c] in word [%s] because all-uppercase word", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
				r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
				r = r->next;
				makeAnotherPass  = true;
				continue;
			}

            if (results->retailerParams.pricesHaveDollar) {
                // Check for '$' followed by a letter and replace with 'S' or 's' depending on height
                if ((r->ch == '$') && (r->next != NULL) && isLetter(r->next->ch)) {
                    char newCh = 's';
                    if ((statsWithoutCurrent->averageHeightUppercase.count >= 2) && (statsWithoutCurrent->averageHeightNormalLowercase.count >= 2)
                        && (indexCloserValToAv1OrAv2(r->rect.size.height, statsWithoutCurrent->averageHeightUppercase, statsWithoutCurrent->averageHeightNormalLowercase) == 1)) {
                        newCh = 'S';
                    }
                    ReplacingLog("ValidateLine: rule 0174 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                    r = r->next;
                    continue;	// We don't expect other substitutions
                }
            } // Prices have dollar

			// Check for '"' instead of "il", "ii", "li" or "ll"
            // Can also be 'n' in some rare cases where all letters are lowercase
			if ((r->ch == '"') && (results->imageTests)) {
                SingleLetterTests* st = CreateSingleLetterTests(r->rect, results);
                // Tall and with two main components
                if (st != NULL) {
                    ConnectedComponentList cpl = st->getConnectedComponents();
                    int strictTest = strictTallTest(r, 0, 1);
                    // Tall?
                    if ((strictTest == 1) && (cpl.size() > 2)) {
                        char newCh1 = 'i';
                        float newHeight =  r->rect.size.height;
                        float newBottom = r->rect.origin.y;
                        float newSpacing = line->averageSpacing.average * 0.75; // Use smaller spacing because space near narrow letters such as i & l is narrower
                        if ((r->rect.size.width - newSpacing) < 4) {
                            newSpacing = 1;
                        }
                        float newWidth = (r->rect.size.width - newSpacing) / 2;
                        CGRect newRect1(rectLeft(r->rect),
                                                     newBottom,
                                                     newWidth,
                                                     newHeight);
                        char newCh2 = 'l';
                        CGRect newRect2(rectRight(r->rect) - newWidth + 1,
                                                     newBottom,
                                                     newWidth,
                                                     newHeight);

                        ReplacingLog("ValidateLine: rule 0117 replacing [%c] with [%c%c] in word [%s]", (unsigned short)r->ch, newCh1, newCh2, toUTF8(r->word->text()).c_str());
                        r->word->updateLetterWithNewCharAndNewRect(r, newCh1, newRect1);
                        line->addLetterWithRectConfidenceAfterRect(newCh2, newRect2, r->confidence, r);
                        makeAnotherPass = true;
                    } else if (cpl.size() == 2)
                    {
                        float gap = gapAboveBaseline(r);
                        if ((gap != -1) && (gap < r->rect.size.height * 0.15))
                        {
                            // Low and close to baseline, can't be a '"'
                            char newCh = 'n';
                            
                            if (!(r->flags & TESTED_OPENING_BOTTOM))
                            {                    
                                // Pretend we tested this 'n' from the bottom so that next round doesn't do it
                                r->flags |= TESTED_OPENING_BOTTOM;

                                // Get main component dimensions
                                ConnectedComponent mainComp = cpl[1];
                                float height = mainComp.getHeight();

                                OpeningsTestResults resBottom;
                                bool success = st->getOpenings(resBottom, SingleLetterTests::Bottom, 
                                    0,      // Start of range to search (top/left)
                                    1,      // End of range to search (bottom/right)
                                    SingleLetterTests::Bound,   // Require start (top/left) bound
                                    SingleLetterTests::Bound  // Require end (bottom/right) bound
                                    );
                    
                                if (!success || (resBottom.maxDepth < height * 0.30)) {
                                    // No opening at bottom bounded left & right - assume 'r'
                                    // TODO might be other errors, will test other cases as we encounter them
                                    newCh = 'r';
                                }
                            } // ! tested_opening_bottom
                            ReplacingLog("ValidateLine: rule 0118 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                            r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                            makeAnotherPass = true;
                        } // close to baseline
                    } // not tall
                    delete st;
                } // st != NULL
			}

			// Check for "<>" or "c>" and replace with 'o' or '0'
			if (isCLookalike(r->ch) && (r->next != NULL)) {
                bool doit = false;
                // With a bogus char in the middle
                // Bryan C. Owens
                // [c (0x63)] at [281,47 - 295,74] [w=15,h=28]
                // [_ (0x5f)] at [290,33 - 295,39] [w=6,h=7]
                // [> (0x3e)] at [292,47 - 302,74] [w=11,h=28]
                if ((r->next->next != NULL) && isGreaterThanEquiv(r->next->next->ch)
                   && (rectLeft(r->next->next->rect) - rectRight(r->rect) - 1 <= 0)
                   && !isLetterOrDigit(r->next->ch)) {
                    r->word->removeLetter(r->next);
                    doit = true;
                } else if (isGreaterThanEquiv(r->next->ch)
                        && (rectLeft(r->next->rect) - rectRight(r->rect) - 1 <= 0)) {
                    doit = true;
                }
                if (doit) {
                    // TODO: need to confirm based on width of alledged rects to combine (should be same as letter or digit)
                    char newCh = 'o';
                    if ((r->next->next != NULL) && isDigit(r->next->next->ch)) {
                        newCh = '0';
                    } else if ((r->previous != NULL) && isDigit(r->previous->ch)) {
                        newCh = '0';
                    } else if (((r->next->next != NULL) && isupper(r->next->next->ch))
                        || ((statsWithoutCurrentAndNext->averageHeightUppercase.average != 0)
                            && (r->rect.size.height/statsWithoutCurrentAndNext->averageHeightUppercase.average > 0.9)
                            && (r->rect.size.height/statsWithoutCurrentAndNext->averageHeightUppercase.average < 1.1))
                          ) {
                        newCh = 'O';
                    }
                    replaceTwo(r, newCh, "rule 0032", rectBottom(r->rect), r->rect.size.height);
                    makeAnotherPass = true;
                    continue;
                }
			}
			// Check for '<' without a matching '>' on line, replace with 'c' or 'C'
			if ((r->ch == '<') && !OCRLine::isPresentInLineAfterRect('>', r)) {
                // Before replacing with 'c', test for "n<" -> "rK"
                bool done = false;
                if (!(r->flags3 & FLAGS3_TESTED_AS_K) && (r->previous != NULL) && (r->previous->ch == 'n') && (tallHeightTest(statsWithoutCurrent.getPtr(), r->previous->rect.size.height, '\0', false, 0, true) == 1) && (rectSpaceBetweenRects(r->previous->rect, r->rect) <= 0)) {
                    r->flags3 |= FLAGS3_TESTED_AS_K;
                    if (results->imageTests) {
                        float minY = MIN(rectBottom(r->previous->rect), rectBottom(r->rect));
                        float maxY = MAX(rectTop(r->previous->rect), rectTop(r->rect));
                        CGRect combinedRect (rectLeft(r->previous->rect), minY, rectRight(r->rect) - rectLeft(r->previous->rect) + 1, maxY - minY + 1); 
                        SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
                        if (st != NULL) {
                            ConnectedComponentList cpl = st->getConnectedComponents();
                            if (cpl.size() == 2) {
                                // Only one connected component - good
                                OpeningsTestResults topLeftOpening;
                                bool success = st->getOpenings(topLeftOpening, SingleLetterTests::Left, 
                                    0,      // Start of range to search (top/left)
                                    0.75,    // End of range to search (bottom/right)
                                    SingleLetterTests::Unbound,   // Require start (top/left) bound
                                    SingleLetterTests::Bound  // Require end (bottom/right) bound
                                    );
                            
                                // We are looking for the top left side to have a fairly large gap
                                if (success && (topLeftOpening.maxDepth > combinedRect.size.width * 0.25)) {
                                    // OK, replace with "rK"
                                    char newCh1 = 'r';
                                    float rect1Height = r->previous->rect.size.height - topLeftOpening.maxDepthCoord;
                                    float rect1YBottom = rectBottom(r->previous->rect) + topLeftOpening.maxDepthCoord;
                                    OpeningsTestResults AboveLeftOpening;
                                    bool success = st->getOpenings(topLeftOpening, SingleLetterTests::Left, 
                                        0,      // Start of range to search (top/left)
                                        topLeftOpening.maxDepth/combinedRect.size.width,    // End of range to search (bottom/right)
                                        SingleLetterTests::Unbound,   // Require start (top/left) bound
                                        SingleLetterTests::Bound  // Require end (bottom/right) bound
                                        );
                            
                                    // We are looking for the top left side to have a fairly large gap
                                    if (success && (AboveLeftOpening.maxDepth > 0)) {
                                        rect1Height = r->previous->rect.size.height - AboveLeftOpening.maxDepth;
                                        rect1YBottom = rectBottom(r->previous->rect) + AboveLeftOpening.maxDepth;
                                    }
                                    CGRect rect1 (rectLeft(r->previous->rect), rect1YBottom, topLeftOpening.maxDepth, rect1Height);
                                    char newCh2 = 'k';
                                    CGRect rect2 (rectRight(rect1) + 1, minY, 
                                        combinedRect.size.width - rect1.size.width, maxY - minY + 1);
                                    ReplacingLog("ValidateLine: rule 0175 replacing [%c%c] with [%c%c] in word [%s]", (unsigned short)r->previous->ch, (unsigned short)r->ch, newCh1, newCh2, toUTF8(r->word->text()).c_str());
                                    r->word->updateLetterWithNewCharAndNewRect(r->previous, newCh1, rect1);
                                    r->previous->confidence = 0;
                                    r->word->updateLetterWithNewCharAndNewRect(r, newCh2, rect2);
                                    makeAnotherPass = true;
                                    r = r->next;
                                    done = true;
                                    continue;
                                }
                            }
                            delete st;
                        }
                    }
                }
                if (!done) {
                    char newCh = 'c';
                    if (OCRLine::isPresentInLineAfterRect(')', r))
                        newCh='(';
                    else if ((statsWithoutCurrent->averageHeightUppercase.count >= 2)
                        && isCloseOrGreaterThanAverage(statsWithoutCurrent->averageHeightUppercase, r->rect.size.height, 0.08)) {
                        newCh = 'C';
                    }
                    ReplacingLog("ValidateLine: rule 0175 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                    makeAnotherPass = true;	// Other subst may use 'c'
                }
			}


			// Map '\'' to 'v' or 'V'
			if ((r != NULL) && (r->ch == '\\') && (r->next != NULL) && (r->next->ch == '\'')) {
				// Make sure the ' is aligned to the top of the '\'
				float minY = MIN(rectBottom(r->rect), rectBottom(r->next->rect));
				float newHeight = MAX(r->rect.size.height, r->next->rect.size.height);
				if (abs(rectBottom(r->rect)-rectBottom(r->next->rect)) < newHeight*OCR_ACCEPTABLE_ERROR) {
					char newCh = 'V';
					if  (lowHeightTest(statsWithoutCurrent.getPtr(), r->rect.size.height, 1, false, results) == 1) {
						newCh = 'v';
					}
                    replaceTwo(r, newCh, "rule 0033", minY, newHeight);
					makeAnotherPass = true;
				}
			}

			// replace "_cQm" or ".cqm" with ".com"
			if ((r != NULL) && (((r->ch == '_') || (r->ch == '.')) && (r->next != NULL) && (toLower(r->next->ch) == 'c')
					 && (r->next->next != NULL) && (r->next->next->ch == 'Q')
					 && (r->next->next->next != NULL) && (toLower(r->next->next->next->ch) == 'm'))) {
				// Replace
				ReplacingLog("ValidateLine: rule 0176 replacing [%c%c%c%c] with [.com] in word [%s]", (unsigned short)r->ch, (unsigned short)r->next->ch, (unsigned short)r->next->next->ch, (unsigned short)r->next->next->next->ch, toUTF8(r->word->text()).c_str());
				r->word->updateLetterWithNewCharAndNewRect(r, '.', r->rect);
				r->word->updateLetterWithNewCharAndNewRect(r->next->next, 'o', r->next->next->rect);
				r = r->next->next->next->next;
				continue;
			}
        
			// Replace ']' with 'J' - only if we didn't have an opening '[' in current word
			if ((r != NULL) && (r->ch == ']') && !OCRLine::isPresentInLineBeforeRect('[', r)) 
            {
                // Check for possible '|'
                if ((r->previous != NULL) && (r->previous->ch == ' ') && (r->next != NULL) && (r->next->ch == ' ') && (statsWithoutCurrentAndNext->averageHeightUppercase.count > 0) && strictTallTest(r, r->rect.size.height * 1.20, 0) && extendsBelowLineRelativeToNeighbors(r, false)) {
                    char newCh = ',';
					ReplacingLog("ValidateLine: rule 0177 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
					r->confidence = 0;		// Protect it against replacements in the future
					r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
					makeAnotherPass = true; 
                }
				// Testing: ']' within a number pattern and not likely to be a bracket
				else if ((statsWithoutCurrent->averageHeightDigits.count > 3)
					&& isCloseOrSmallerThanAverage(statsWithoutCurrent->averageHeightDigits, r->rect.size.height, 0.07)
					&& (((r->next != NULL) && (isDigit(r->next->ch) || (r->next->ch == '-')))
						|| ((r->previous != NULL) && (isDigit(r->previous->ch) || (r->previous->ch == '-'))))
					) {
					char newCh = '1';
					ReplacingLog("ValidateLine: rule 0178 replacing [%c] with [%c] in word [%ls]", (unsigned short)r->ch, newCh, r->word->text().c_str());
					r->confidence = 0;		// Protect it against replacements in the future
					r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
					makeAnotherPass = true;
				} else 
                {
					// Check for ']' that's actually a 'J'
					wchar_t newCh = '\0';
                    SingleLetterTests *st = NULL;
                    if ((SingleLetterTestAsSquareBracket(r, r->rect, results, newCh, &st) > 0.50) && (newCh != '\0')) 
                    {
                        if (newCh == 'l') {
                            if (digitsNearby(r)) {
                                newCh = '1';
                            } else if ((r->next != NULL) && isUpper(r->next->ch)) {
                                newCh = 'I';
                            }
                        }
                        ReplacingLog("ValidateLine: rule 0179 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)newCh, toUTF8(r->word->text()).c_str());
                        r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                        makeAnotherPass = true;
                        r = r->next;
                        if (st != NULL)
                            delete st;
                        continue;
                    }
                    newCh = 'J';
					float gap = gapBelow(r,1);
                    if ((gap > 0) && (st != NULL))
                    {
                        ConnectedComponentList cpl = st->getConnectedComponents();
                        if (cpl.size() >= 3) 
                        {
                            ConnectedComponent letterCC = cpl[1];
                            ConnectedComponent dotCC = cpl[2];
                                // Above
                            if ((dotCC.ymax < letterCC.ymin)
                                && OCRUtilsOverlapping(dotCC.xmin, dotCC.xmax, letterCC.xmin, letterCC.xmax))
                            {
                                newCh = 'j';
                            }
                        }
                    }
                    if (st != NULL) delete st;
					// Replace
					ReplacingLog("ValidateLine: rule 0180 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)newCh, toUTF8(r->word->text()).c_str());
					r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
					r = r->next;
					continue;
				}
			}
            
            // '[' instead of 'L'
            // Replace only if we didn't have a closing ']' in current word
            if ((r != NULL) && (r->ch == '[') && !OCRLine::isPresentInLineAfterRect(']', r) && !OCRLine::isPresentInLineAfterRect(')', r)
                   && (tallHeightTest(statsWithoutCurrent.getPtr(), r->rect.size.height, '\0', false, 1, true) == 1)) {
                // Testing: '[' within uppercase letters, likely a 'I' but could also be a 'L'
                wchar_t newCh = '\0';
                if ((SingleLetterTestAsSquareBracket(r, r->rect, results, newCh) > 0.60) && (newCh != '\0') && (newCh != r->ch))
                {
                    // If we think it's a 'l' but surrounded by uppercase letters, replace with 'I'
                    if ((newCh == 'l') && (r->next != NULL) && isUpper(r->next->ch)
                            && ((r->previous == NULL) || (r->previous->ch == ' ') || isUpper(r->previous->ch))) 
                    {
                        newCh = 'I';
                    }
                    ReplacingLog("ValidateLine: rule 0181 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)newCh, toUTF8(r->word->text()).c_str());
                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                    makeAnotherPass = true;
                }
            }

			if ((r != NULL) && (r->ch == '|') && (r->next != NULL) && (r->next->ch == '\\') && (r->next->next != NULL) && (r->next->next->ch == '/') && (r->next->next->next != NULL) && (r->next->next->next->ch == 'H')
				&& isCloseOrGreaterThanAverage(line->averageHeightUppercase, r->rect.size.height, 0.07)) {
				// Replace [|\/H] with [MI]
				char newCh = 'M';
				// New width: from left side of r to left side of the H (approximate, ignores the width of the | in the H)
				float newWidthM = rectLeft(r->next->next->next->rect) - rectLeft(r->rect);
				// Adjust current rect
				float newHeight = (r->rect.size.height + r->next->next->next->rect.size.height)/2;
				float newBottom = (rectTop(r->rect) + rectTop(r->next->next->next->rect))/2 - newHeight + 1;
				CGRect newRectM(rectLeft(r->rect),
											 // Midpoint bottom Y location between current and next
											 newBottom,
											 newWidthM,
											 // average height between current and next
											 newHeight);
				r->word->updateLetterWithNewCharAndNewRect(r, newCh, newRectM);
				float newWidthI = line->averageWidthNarrowChars.average;
				if (newWidthI == 0)
					newWidthI = r->next->next->next->rect.size.height / 3.0;
				newHeight = r->next->next->next->rect.size.height;
				newBottom = rectTop(r->next->next->next->rect) - newHeight + 1;
				CGRect newRectI(rectRight(r->next->next->next->rect) - newWidthI,
											 // Midpoint bottom Y location between current and next
											 newBottom,
											 newWidthI,
											 // average height between current and next
											 newHeight);
				r->word->updateLetterWithNewCharAndNewRect(r->next->next->next, 'I', newRectI);
				r->word->removeLetter(r->next);
				r->word->removeLetter(r->next->next);
			} else if ((r != NULL) && ((r->ch == '_') && (r->next != NULL) && ((r->next->ch == 'I') || (r->next->ch=='l'))
					   && ((r->previous == NULL) || (((r->previous->ch == '\n') || (r->previous->ch == ' ') || (r->previous->ch == '\t')))))) {
				// Replace [_I] with [J] or [j]
				float newWidth = rectRight(r->next->rect) - rectLeft(r->rect);
				// Adjust current rect
				float newHeight = r->next->rect.size.height;
				float newBottom = (rectTop(r->rect) + rectTop(r->next->rect))/2 - newHeight + 1;
				CGRect newRect(rectLeft(r->rect),
											// Midpoint bottom Y location between current and next
											newBottom,
											newWidth,
											newHeight);

				//Now we need to decide between J and j
				char newCh;
				if ((indexCloserValToVal1OrVal2(newRect.size.height, line->averageHeightUppercase.average, line->averageHeightNormalLowercase.average) == 1)
					|| (newRect.size.height > line->averageHeightUppercase.average)) {
					newCh = 'J';
				} else {
					newCh = 'j';
				}
				ReplacingLog("ValidateLine: rule 0191 replacing '\\/' with '%c' in word [%ls]", newCh, r->word->text().c_str());
				r->word->updateLetterWithNewCharAndNewRect(r, newCh, newRect);
				r->word->removeLetter(r->next);
				// Fall through
			}
            // Replace "i/" with 'v'
            else if ((r != NULL) && (results->imageTests) && !(r->flags5 & FLAGS5_TESTED_AS_v)
                       && (isVerticalLine(r->ch) || (r->ch == ';') || (r->ch == '%')) && (r->next != NULL) && (rectSpaceBetweenRects(r->rect, r->next->rect) <= 0))
            {
                r->flags5 |= FLAGS5_TESTED_AS_v;
                bool doit = false;
                bool replaceThree = false;
                if (r->next->ch == '/') {
                    doit = true;
                } else if (isQuote(r->next->ch) && (r->next->next != NULL) && (rectSpaceBetweenRects(r->next->rect, r->next->next->rect) <= 0)  && (r->next->next->ch == '/')) {
                    doit = true;
                    replaceThree = true;
                }
                if (doit) {
                    // Replace [\/] with [V] or [v] or 'y'
                    CGRect combinedRect = (replaceThree? CreateCombinedRect(r->rect, r->next->rect, r->next->next->rect):CreateCombinedRect(r->rect, r->next->rect));

                    // Now we need to decide between V and v and y
                    wchar_t oldCh = '\0';
                    if ((tallHeightTest(statsWithoutCurrentAndNext.getPtr(), combinedRect.size.height, 'y', false, 0, true) == 1)
                        && ((replaceThree? r->next->next->rect.size.height:r->next->rect.size.height) > r->rect.size.height * 1.27)
                        && ((rectTop((replaceThree? r->next->next->rect:r->next->rect)) - rectTop(r->rect)) > combinedRect.size.height * 0.26))
                    {
                        oldCh = r->ch;
                        r->ch = 'y';
                    }
                    wchar_t newChar = '\0';
                    if (SingleLetterTestAsV(r, combinedRect, statsWithoutCurrentAndNext, results, newChar, NULL, &combinedRect) && (newChar != '\0') && (newChar != r->ch)) {
                        if (replaceThree)
                            replaceThreeWithRect(r, newChar, combinedRect, "rule 0017");
                        else
                            replaceTwoWithRect(r, newChar, combinedRect, "rule 0017");
                        // Fall through will potentially replace it and a next 'v' with 'w'
                        // Better NOT let it combine with a next V, to avoid vvv => vw
                        if (round == 0) {
                            makeAnotherPass = true;
                            r = r->next;
                            continue;
                        }
                        // Otherwise, flow through below
                    } else {
                        // if we tried to set current ch to 'y' above but test function failed, revert back
                        if (oldCh != '\0')
                            r->ch = oldCh;
                    }
                }
			}
            
//#if DEBUG
//            if ((r->ch=='6') && (r->previous != NULL) && (r->previous->ch=='3') && (r->next != NULL) && (r->next->ch=='1') && (r->next->next != NULL) && (r->next->next->ch=='1')) {
//                DebugLog("Found in word [%s]!", toUTF8(r->word->text()).c_str());
//                DebugLog("");
//            }
//#endif

			if ((r != NULL) && (r->confidence > 0) && (r->ch == 's') && (tallHeightTest(statsWithoutCurrent.getPtr(), r->rect.size.height, 's', false, 1, true) == 0)
					 && isTallRelativeToNeigbors(r, r->rect.size.height, false) && (r->next != NULL) && (r->next->ch == 't') && (r->next->next != NULL) && (r->next->next->ch == 'h')) {
				char newCh = '6';
				ReplacingLog("ValidateLine: rule 0192 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
				r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
				r->confidence = 0;
				makeAnotherPass = true;
			}
           
            // 6 instead of 5
            if (results->imageTests && (r->ch == '6') && !(r->flags4 & FLAGS4_TESTED_AS_5))
            {
                // Check for deep opening bottom-left, if found likely a '5'. Note: don't care about glued left, if I find a deep open it implies stuff on left didn't block me
                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                r->flags4 |= FLAGS4_TESTED_AS_5;
                if (st != NULL) {
                    // Digit may be broken into several connected components and caused wrong openings test results - check connected components
                    ConnectedComponentList cpl = st->getConnectedComponents();
                    if ((cpl.size()>=2) && (cpl[1].area > cpl[0].area * 0.80)) {
                        OpeningsTestResults resLeft;
                        bool success = st->getOpenings(resLeft, SingleLetterTests::Left, 
                            0.4, 
                            1.0,
                            SingleLetterTests::Bound,
                            SingleLetterTests::Bound
                            ); 
                        if (success && (resLeft.maxDepth > r->rect.size.width * 0.40)) {
                            char newCh = '5';
                        
                            //  ------------
                            //0|            |
                            //1|     1111   |
                            //2|   11111111 |
                            //3|  111   111 |
                            //4| 111        |
                            //5| 11         |
                            //6| 11         |
                            //7| 11  11     |
                            //8| 11111111   |
                            //9| 111   111  |
                            //a|        111 |
                            //b| 11      11 |
                            //c| 11      11 |
                            //d| 11      11 |
                            //e| 111    111 |
                            //f|  111  111  |
                            //#|  11111111  |
                            //#|    111     |
                            //#|            |
                            //  ------------
                        
                            // Make sure we don't change the above pattern to '5'!
                            SegmentList slTop = st->getHorizontalSegments(0.05, 0.10);
                            SegmentList slTop20 = st->getHorizontalSegments(0.20, 0.01);
                            if ((slTop.size() == 1) && (slTop20.size() >= 1)) {
                                float topWidth = slTop[0].endPos - slTop[0].startPos + 1;
                                float topLeftMargin = slTop[0].startPos;
                                float top20LeftMargin = slTop20[0].startPos;
                                if ((topWidth >= r->rect.size.width * 0.80) || (topLeftMargin - top20LeftMargin > r->rect.size.width * 0.08)) {
                                    ReplacingLog("ValidateLine: rule 0193 NOT replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                                    newCh = '\0';
                                }
                            }
                            if (newCh != '\0') {
                                ReplacingLog("ValidateLine: rule 0193 replacing [%c] with [%c] in word [%s] (single-letter confirmed OCR decision)", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                                r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                                makeAnotherPass = true;
                            }
                        } // found opening
                    } // connected components OK
                    delete st;
                } // st != NULL
            }

			if ((r != NULL) && (r->ch == '6') && (!r->flags5 & FLAGS5_TESTED_AS_G)) {
                // Testing: '6' at word starts
                // Replacing with: 'G'
                // Avoid doing it if followed by "th"!
				if ((r->confidence != 0)
					&& (((r->next == NULL) || (r->next->next == NULL)) || (r->next->ch != 't') || (r->next->next->ch != 'h'))
					&& (tallHeightTest(statsWithoutCurrent.getPtr(), r->rect.size.height, 'G', false, 0,false) == 1)
					&& ((r->previous == NULL) || (r->previous->ch == ' ')) && (countDigitsInWord(r) < 2) && (countCharsInWord(r) > 2)) 
                {
                    r->flags5 |= FLAGS5_TESTED_AS_G;
                    // Test if it may pass '6' testing after all
                    if (!SingleLetterTestAs6(r, results, true, NULL)) 
                    {
                        wchar_t newCh = 'G';
                        ReplacingLog("Validate: rule 0536 replacing [%c] with [%c]", (unsigned short)r->ch, (unsigned short)newCh);
                        r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                        makeAnotherPass = true;
                    }
				}
                // 6 instead of '@'
                // circular (as wide as it is tall)
                else if ((r != NULL) && (r->next != NULL) && (r->previous != NULL)
						   && (isLetter(r->previous->ch) || isLetter(r->next->ch))
						   && isClose(r->rect.size.width, r->rect.size.height, 0.07)
						   && (statsWithoutCurrent->averageWidth.count > 3) && (r->rect.size.width > statsWithoutCurrent->averageWidth.average * 1.10)) {
					char newCh = '@';
					ReplacingLog("Validate: rule 0535 replacing [%c] with [%c]", (unsigned short)r->ch, newCh);
					r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
				}
			}

			// Matching: 's'
			// Replacing with: 'g' if below line and tall
			if ((r != NULL) && (r->ch == 's')
				// Dangerous subst - require at least 4 stats member to conclude about height
				&& (tallHeightTest(statsWithoutCurrent.getPtr(), r->rect.size.height, 'g', false, 3, false) == 1)
				&& (gapBelow(r,1) > r->rect.size.height*0.20)) {
				char newCh = 'g';
				ReplacingLog("ValidateLine: rule 0194 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
				r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
			}

			// Matching: "84"
			// Replacing with: '&' if '4' much smaller
			// '8' was 27 tall vs 4 15 pixels tall
			// Matching: "8." surrounded by spaces and glued together
            // TODO pq10 code below expects 50% smaller ...
			if ((r != NULL) && (r->ch == '8') && !(r->flags6 & FLAGS6_TESTED_AS_ANDSIGN)
                && (r->next != NULL) && ((spaceBetween = rectSpaceBetweenRects(r->rect, r->next->rect)) <= 0)
                && (statsWithoutCurrentAndNext->averageSpacing.average > spaceBetween)
                // Test height of next char, we test it later to be at least 23% shorter anyhow
                && (r->next->rect.size.height <= r->rect.size.height * 0.77))
			{ 
                r->flags6 |= FLAGS6_TESTED_AS_ANDSIGN;
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                wchar_t newCh = SingleLetterTestAsAndSign(r, combinedRect, true, statsWithoutCurrentAndNext, results);
                if (newCh != '\0') {
                    if (newCh == '&')
                        newCh = 0xa3; // British pound sign, special code to prevent this character from being considered as a '8' in phones (will ve replaced back later on)
                    replaceTwo(r, newCh, "rule 0034 ");
					makeAnotherPass = true;
                }
            }

//#if DEBUG
//			if ((r->ch =='9') && (r->next != NULL) && (r->next->ch=='4')) {
//                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
//                if (st != NULL) delete st;
//				DebugLog("Found in [%s]", toUTF8(r->word->text()).c_str());
//                DebugLog("");
//			}
//#endif        

            //  ---------------
            //0|               |
            //1|          11   |
            //2|         1111  |
            //3|        11111  |
            //4|          111  |
            //5|          111  |
            //6|     11   111  |
            //7|    111   111  |
            //8|    111   111  |
            //9|   111    111  |
            //a|   11     111  |
            //b|   1      111  |
            //c|  1       111  |
            //d|  1       111  |
            //e| 111      111  |
            //f| 111111   1111 |
            //#| 1111111 11111 |
            //#|  11      111  |
            //#|           11  |
            //#|           11  |
            //#|           11  |
            //#|          111  |
            //#|           11  |
            //#|           11  |
            //#|               |
            //  ---------------
            // '4' instead of '9'
            if ((r->ch == '9') && (results->imageTests) && !(r->flags3 & FLAGS3_TESTED_AS_4)) {
                r->flags3 |= FLAGS3_TESTED_AS_4; // Using new "AS_4" flag because another rule is already using the flag2 one
                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                char newCh = '\0';
                bool doit = false;
                if (st != NULL) {
                    // Test if bottom is actually not curved to the left at the bottom AND not wide at all
                    SegmentList slBottom = st->getHorizontalSegments(0.925, 0.15);
                    // In above pattern the width was just 3 pixels out of 13 - even 4 would be too narrow
                    if ((slBottom.size() == 1) && (slBottom[0].endPos - slBottom[0].startPos + 1 < r->rect.size.width * 0.31)) {
                        // Check top pixels on right side
                        SegmentList slTop = st->getHorizontalSegments(0.075, 0.15);
                        if ((slTop.size() >= 1) && (slTop[0].startPos > r->rect.size.width * 0.50)) {
                            OpeningsTestResults res;
                            bool success = st->getOpenings(res,
                                SingleLetterTests::Left,
                                0.70,      // Start of range to search (top/left)
                                1.00,    // End of range to search (bottom/right)
                                SingleLetterTests::Any,   // Require start (top/left) bound
                                SingleLetterTests::Bound  // Require end (bottom/right) bound
                                );
                            if (!success || (res.maxDepth < r->rect.size.width * 0.31)) {
                                newCh = '4';
                                doit = true;
                            }
                        }
                    }
                    delete st;
                }
                if (doit) {
                    ReplacingLog("ValidateLine: rule 0586 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)newCh, toUTF8(r->word->text()).c_str());
                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                    makeAnotherPass = true;
                }
            }
              
            bool isAccented = false;
			// Must make the below before adjustment of lower/upper otherwise 'v' may get mapped to 'V'
			// Replace 'v' much below baseline and tall with 'y'
			if ( (r != NULL) &&
#if !DEBUG
				(r->confidence > 0) &&
#endif
				(r->ch == '0'))  
            {
                
                // Catch PO BOX
                if (((r->previous != NULL) && (r->previous->ch == 'P'))
                      || ((r->previous != NULL) && (r->previous->ch == '.') && (r->previous->previous != NULL) && (r->previous->previous->ch == 'P') && ((r->previous->previous->previous ==  NULL) || isWordDelimiter(r->previous->previous->previous->ch)))) {
                    char newCh = 'O';
					ReplacingLog("OCRUtilsValidate: rule 0534 replacing [%c] with [%c] in word [%ls]", (unsigned short)r->ch, newCh, r->word->text().c_str());
					r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                    makeAnotherPass = true;
                } else {
                    // 0 could be a lowercase 'o'
                    float nextToALetter = (((r->previous != NULL) && isLetter(r->previous->ch)) || ((r->next != NULL) && isLetter(r->next->ch)));
                    float nextToADigit = (((r->previous != NULL) && isDigit(r->previous->ch)) || ((r->next != NULL) && isDigit(r->next->ch)));
                    if (nextToALetter || !nextToADigit) {
                        float heightRatio = r->rect.size.height / r->rect.size.width;
                        // Give tallness every chance, to replace only when we are sure
                        if ( (lowHeightTest(statsWithoutCurrent.getPtr(), r->rect.size.height, 1, true, results) == 1)
                            // Either we are not next to a digit
                            // or else, if there is a letter but also a digit, require that height be less or equal than 25/22 (1.25) * width
                            && (!nextToADigit || (heightRatio <= 1.25))
                        ) {
                            // Find first tall preceding digit that's not '0', skip '0', 'o' and ' '
                            SmartPtr<OCRRect> p = r->previous;
                            bool foundReferenceDigit = false;
                            while (p != NULL) {
                                if (isDigit(p->ch) && (p->ch != '0')) {
                                    // Found what we were looking for!
                                    foundReferenceDigit = true;
                                    break;
                                } else if ((p->ch == ' ') || (p->ch == '0') || (p->ch == 'o')) {
                                    // OK to skip these
                                    p = p->previous;
                                    continue;
                                }
                                break;
                            }
                            
                            char newCh = 'o';
                            bool doit = true;
                            
                            if (foundReferenceDigit) {
                                // Retiring the test below: even if the reference digit is not tall, why replace '0' with 'o'? Likely a genuine '0'
                                // && (tallHeightTest(statsWithoutCurrent.getPtr(), p->rect.size.height, '\0', false, 1, true) == 1) && (r->rect.size.height > p->rect.size.height * 0.55)) {
                                float gapBottom = rectTop(p->rect) - rectTop(r->rect);
                                // If gap negative, use 0: this will help catch cases where we are trying to effect a replacement where a preceeding non-0 digit is same height -> also avoid replacing in that case
                                if (((gapBottom > 0)? gapBottom:0) + r->rect.size.height > p->rect.size.height * (1 - OCR_ACCEPTABLE_ERROR)) {
                                    doit = false;
                                    ReplacingLog("ValidateLine: rule 0104 NOT replacing [%c] with [%c] in word [%s]!", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                                }
                            }

                            if (doit) {
                                // As long as we are replacing, might as well test for possible 'a'!
                                char replacementCh = SingleLetterTestoAsa(r, results);
                                if (replacementCh == 'a') {
                                    ReplacingLog("ValidateLine: rule 0104 replacing - overriding [%c] with [%c], changing to [%c] instead in word [%s]!", (char)r->ch, newCh, replacementCh, toUTF8(r->word->text()).c_str());
                                    newCh = replacementCh;
                                }
                                ReplacingLog("ValidateLine: rule 0104 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                                r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                                makeAnotherPass = true;
                            }
                        }
                    }
                    
                    if ((r->ch == '0') 
                        // If it's really a O, can't be much taller than other uppercase (otherwise could be a legit 0)
                        && (r->rect.size.height < statsWithoutCurrent->averageHeightUppercase.average * 1.1)
                        && ((r->previous != NULL) && ((isUpper(r->previous->ch) || (r->previous->ch == ' ')) && (r->previous->previous != NULL) && isUpper(r->previous->previous->ch)))
                        && ((r->next != NULL) && (isUpper(r->next->ch) || ((r->next->ch == ' ') && (r->next->next != NULL) && isUpper(r->next->next->ch))))
                        // Require that the suspected 'O' not be much taller than it is wide
                        // real 0 [0 (0x30)] at [75,253 - 88,276] [w=14,h=24] => h = w * 1.714
                        // Bad 0 [0 (0x30)] at [746,413 - 805,467] [w=60,h=55]
                        && (r->rect.size.height < r->rect.size.width * 1.2)) {
                        // Adjust a '0' between two uppercase letters to 'O'. Note: is we mistakenly do that in a phone, no big deal because we accept 'O' in phones
                        // TODO could be a problem in text where where digits are surrounded by uppercase letters - need to revise these regexes to map O to 0 (like we do for phones)
                        char newCh = 'O';
                        ReplacingLog("OCRUtilsValidate: rule 0533 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                        r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                        makeAnotherPass = true;
                    }
                }
			}
			// Check for uppercase letters not tall enough to be uppercase => lowercase
			else if ( (r != NULL) &&
#if !DEBUG
					 (r->confidence > 0) &&
#endif
					 (looksSameAsLowercase(r->ch, results))) {
#if DEBUG
				if ((r->ch =='O') && (r->previous != NULL) && (r->previous->ch =='C')) {
					DebugLog("Found it");
				}
#endif
                bool doIt = false;

				if ((r != NULL) && (sameHeightLowercase
					|| ((lowHeightTest(statsWithoutCurrent.getPtr(), r->rect.size.height, 0, false, results) == 1)
						  && !isTallRelativeToNeigbors(r, r->rect.size.height, false))
					// Below takes care of lines where 2nd part is all smaller font. Can be removed when we have word-level stats.
					|| isLowRelativeToNeigbors(r,true,smallCap, results) )) {
                    doIt = true;
				}
                
                if (doIt) 
                {
                    wchar_t newCh = toLower(r->ch);
                    if (newCh == 'm') {
                        // Extra test, m and M are not that similar
                        if (results->imageTests) 
                        {
                            if (!(r->flags5 & FLAGS5_TESTED_AS_M_versus_m)) 
                            {
                                r->flags5 |= FLAGS5_TESTED_AS_M_versus_m;
                                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                                if (st != NULL) {      
                                    OpeningsTestResults resTop;
                                    bool success = st->getOpenings(resTop, SingleLetterTests::Top, 
                                        0.20,      // Start of range to search (top/left)
                                        0.80,    // End of range to search (bottom/right)
                                        SingleLetterTests::Bound,   // Require start (top/left) bound
                                        SingleLetterTests::Bound  // Require end (bottom/right) bound
                                    );
                                    if (success && (resTop.maxDepth > r->rect.size.height * 0.40)) {
                                        doIt = false;
                                    }
                                    delete st;
                                } // st != NULL
                            } else {
                                // Already tested, don't replace
                                doIt = false;
                            }
                        }
                    }
                    if (doIt) {
                        ReplacingLog("Validate: rule 0532 replacing [%c] with [%c] in word [%s] (looks same as lowercase)", r->ch, (unsigned short)newCh, toUTF8(r->word->text()).c_str());
#if DEBUG
                        if (newCh == 'm') {
                            DebugLog("");
                        }
#endif
                        r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                        makeAnotherPass = true;
                    }
                }
			}
			// Check for lowercase letters which should be uppercase. Ignore 'k' because we had frequent false cases where we upcased a lowercase k (lower and upper k have same height)
			else if ((r != NULL) &&
#if !DEBUG
					 (r->confidence > 0) &&
#endif
					 (looksSameAsUppercase(r->ch, results, &isAccented) 
                        // If 'm' skip if we already tested m versus M (and reached a decision obviously)
                        && ((r->ch != 'm') || !(r->flags5 & FLAGS5_TESTED_AS_M_versus_m)) 
                        && (r->ch != 'k') && (r->ch != 'p'))) 
            {
                bool doIt = false;
#if DEBUG
                if ((r->ch =='s') && (r->next != NULL) && (r->next->ch =='T')) {
                    DebugLog("Found it");
                }
#endif
                if (line->areAllLettersAndDigitsSameHeight()
                    // All chars are the same height - is there a clear majority voting uppercase or digit?
                    && (numUppercase + line->averageHeightDigits.count + numLowercaseLookingLikeUppercase >= 2)
                    && ((numUppercase + line->averageHeightDigits.count + numLowercaseLookingLikeUppercase) >= (numLowercase - numLowercaseLookingLikeUppercase) * 5)) {
                    doIt = true;
                }
				else if (sameHeightUppercase) {
                    doIt = true;
                    // If is accented, don't tolerate a margin of error, must be actually the tallest letter (because an accented uppercase will actually rise above non-accented uppercase letters)!
                } else if ((r->rect.size.height >= maxHeight * (isAccented? (1 + OCR_ACCENT_ADDITION):(1 - OCR_ACCEPTABLE_ERROR)))
                           || ((statsWithoutCurrent->averageHeightUppercase.count >= 4) && (statsWithoutCurrent->averageWidthLowercase.count <= 1) && (r->rect.size.height >= statsWithoutCurrent->averageHeightUppercase.average * (isAccented? (1 + OCR_ACCENT_ADDITION):(1 - OCR_ACCEPTABLE_ERROR)))))
                {
                    if (round == 0) {
                        makeAnotherPass = true;
                    } else 
                    {
                        float realHeight = -1;
                        doIt = true;
                        // Test main component height!
                        if (results->imageTests) {
                            SingleLetterTests * st = CreateSingleLetterTests(r->rect, results);
                            if (st != NULL) {
                                ConnectedComponentList cpl = st->getConnectedComponents();
                                if (cpl.size() >= 2) {
                                    realHeight = cpl[1].getHeight();
#if DEBUG
                                    if ( (realHeight != r->rect.size.height)
                                         // Re-test above test with revised height
                                         && !(  (realHeight >= maxHeight * (isAccented? (1 + OCR_ACCENT_ADDITION):(1 - OCR_ACCEPTABLE_ERROR)))
                                               || ((statsWithoutCurrent->averageHeightUppercase.count >= 4) && (statsWithoutCurrent->averageWidthLowercase.count <= 1) && (realHeight >= statsWithoutCurrent->averageHeightUppercase.average * (isAccented? (1 + OCR_ACCENT_ADDITION):(1 - OCR_ACCEPTABLE_ERROR))))
                                             ) ) {
                                        ReplacingLog("Validate: replacing, single-letter  indicates real height of [%c] is [%.1f] in word [%s], not [%.1f] - NOT upcasing", (unsigned short)r->ch, realHeight, toUTF8(r->word->text()).c_str(), r->rect.size.height);
                                        doIt = false;
                                    }    
#endif                                   
                                }
                                delete st;
                            }
                        }
                        // One more hurdle: demand at least two tall letters to trust the stats and upcase
                        float countTall = statsWithoutCurrent->averageHeightTallLowercase.count + statsWithoutCurrent->averageHeightDigits.count + statsWithoutCurrent->averageHeightUppercase.count;
                        if (countTall < 2)
                            doIt = false;
                    }
                }
                if (doIt) {
                    wchar_t newCh = toUpper(r->ch);
                    if (newCh == 'S') {
                        char digitAlternative = SingleLetterTestSAsDigit(r, r->rect, 1, results, true);
                        if ((digitAlternative != '\0') && (digitAlternative != r->ch)) {
                            newCh = digitAlternative;
                            ReplacingLog("Validate: rule 0531 replacing [%c] with [%c] in word [%s] (testing for digit before changing s -> S)", (unsigned short)r->ch, (unsigned short)newCh, toUTF8(r->word->text()).c_str());
                        }
                    }
                    else if (newCh == 'U') {
                        // Could be LL
                        if (results->imageTests) {
                            // Check if we actually have two roughly equal components => LL
                            ConnectedComponent cc1, cc2;
                            int n = SingleLetterNumComponents(r->rect, results, 0.40, NULL, &cc1, &cc2);
                            if (n == 2) {
                                // Create two letters
                                char newCh1 = 'L';
                                char newCh2 = 'L';

                                ConnectedComponent *first, *second;
                                if (cc2.xmin > cc1.xmin) {
                                    first = &cc1;
                                    second = &cc2;
                                } else {
                                    first = &cc2;
                                    second = &cc1;
                                }
                                CGRect newRect1 (rectLeft(r->rect) + first->xmin,
                                    rectBottom(r->rect) + first->ymin,
                                    first->getWidth(), first->getHeight());
                                CGRect newRect2 (rectLeft(r->rect) + second->xmin,
                                    rectBottom(r->rect) + second->ymin,
                                    second->getWidth(), second->getHeight());
                                    
                                SingleLetterTests *st1 = CreateSingleLetterTests(newRect1, results);
                                if (st1 != NULL) {      
                                    OpeningsTestResults resRight;
                                    bool success = st1->getOpenings(resRight, SingleLetterTests::Right, 
                                        0.50,      // Start of range to search (top/left)
                                        1.00,    // End of range to search (bottom/right)
                                        SingleLetterTests::Unbound,   // Require start (top/left) bound
                                        SingleLetterTests::Bound  // Require end (bottom/right) bound
                                    );
                                    if (!success || (resRight.maxDepth < newRect1.size.width * 0.50)) {
                                        newCh1 = 'I';
                                    }
                                    delete st1;
                                } // st1 != NULL
                                
                                SingleLetterTests *st2 = CreateSingleLetterTests(newRect2, results);
                                if (st2 != NULL) {      
                                    OpeningsTestResults resRight;
                                    bool success = st2->getOpenings(resRight, SingleLetterTests::Right, 
                                        0.50,      // Start of range to search (top/left)
                                        1.00,    // End of range to search (bottom/right)
                                        SingleLetterTests::Unbound,   // Require start (top/left) bound
                                        SingleLetterTests::Bound  // Require end (bottom/right) bound
                                    );
                                    if (!success || (resRight.maxDepth < newRect2.size.width * 0.50)) {
                                        newCh2 = 'I';
                                    }
                                    delete st2;
                                } // st2 != NULL
                                
                                ReplacingLog("Validate: rule 0530 replacing [%c] with [%c%c] in word [%s] (u test)", (unsigned short)r->ch, newCh1, newCh2, toUTF8(r->word->text()).c_str());
                                r->word->updateLetterWithNewCharAndNewRect(r, newCh1, newRect1);
                                r->word->addLetterWithRectConfidenceAfterRect(newCh2, newRect2, r->confidence,r);
                                r = r->next; // Skip only one L, let rules apply to the 2nd one
                                makeAnotherPass = true;
                                continue;
                            }
                        }
                        testUAnyhow = true; // Let single letter test it even if line is italic (this is a test of U vs O
                    }
                    else if ((r->ch == 'm') && results->imageTests) {
                        SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                        if (st != NULL) {
                            ConnectedComponentList cpl = st->getConnectedComponents();
                            if (cpl.size() > 2) {
                                ConnectedComponent major = cpl[1];
                                ConnectedComponent minor = cpl[2];
                                if ((minor.area > major.area * 0.20) && (minor.getHeight() > major.getHeight() * (1 - OCR_ACCEPTABLE_ERROR))
                                    && (minor.getHeight() > minor.getWidth() * 4)) {
                                    char newCh1 = 'I';
                                    char newCh2 = 'N';
                                    ConnectedComponent first, second;
                                    if (major.xmin > minor.xmin) {
                                        first = minor;
                                        second = major;
                                    } else {
                                        first = major;
                                        second = minor;
                                        newCh1 = 'N';
                                        newCh2 = 'I';
                                    }
                                    CGRect newRect1(rectLeft(r->rect) + first.xmin, 
                                        rectBottom(r->rect) + first.ymin, 
                                        first.getWidth(), first.getHeight());
                                    CGRect newRect2 (rectRight(r->rect) - second.getWidth() + 1,
                                        rectBottom(r->rect) + second.ymin,
                                        second.getWidth(),
                                        second.getHeight());
                                    ReplacingLog("Validate: rule 0529 replacing [%c] with [%c%c] in word [%s]", (unsigned short)r->ch, newCh1, newCh2, toUTF8(r->word->text()).c_str());
                                    r->word->updateLetterWithNewCharAndNewRect(r, newCh1, newRect1);
                                    r->word->addLetterWithRectConfidenceAfterRect(newCh2, newRect2, r->confidence, r);
                                    r = r->next->next;
                                    makeAnotherPass = true;
                                    delete st;
                                    continue;
                                }
                            } 
                            delete st;
                        } // st != NULL
                    }
					ReplacingLog("Validate: rule 0058 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)newCh, toUTF8(r->word->text()).c_str());
					r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
					makeAnotherPass = true;
                }
			}
			else if ((r != NULL) &&
#if !DEBUG
					 (r->confidence > 0) &&
#endif
					 (r->ch == 'h') && (results->imageTests) && !(r->flags4 & FLAGS4_TESTED_AS_h) && (tallHeightTest(statsWithoutCurrent.getPtr(), r->rect.size.height, 'h', false, 3, true) == 0)
					   && !isTallRelativeToNeigbors(r, r->rect.size.height, false)) 
            {
                r->flags4 |= FLAGS4_TESTED_AS_h;
                bool doit = true;
                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                if (st == NULL)
                    doit = false;
                if (doit) {
                    ConnectedComponentList cpl = st->getConnectedComponents();
                    if (!validateConnectedComponents (cpl, r->rect))
                        doit = false;
                }
                if (doit) {
                    SegmentList slTop = st->getHorizontalSegments(0.05, 0.10);
                    if ((slTop.size() == 1) && (slTop[0].endPos > r->rect.size.width * 0.70))
                    {
                        char newCh = 'n';
                        ReplacingLog("ValidateLine: rule 0196 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                        r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                        makeAnotherPass = true;
                    }
                }
                if (st != NULL)
                    delete st;
			}
			// Testing: 'n'
			else if ((r != NULL) && (r->ch == 'n')) {
#if DEBUG
				if ((r->next != NULL) && (r->next->ch =='n')) // && (r->next->next != NULL) && (r->next->next->ch =='t')) {
                {
					DebugLog("Found it");
				}
#endif
				// Testing: "n/" where '/' is as low as 'n'
				// Replacing with: "rv"
				// nl instead of rv:
				// [e (0x65)] at [423,62 - 436,82] [w=14,h=21]
				// [n (0x6e)] at [440,63 - 455,82] [w=16,h=20]
				// [l (0x6c)] at [456,63 - 462,81] [w=7,h=19]
				// [i (0x69)] at [465,63 - 468,88] [w=4,h=26]				
				if (((lowHeightTest(statsWithoutCurrent.getPtr(), r->rect.size.height, 2, false, results) == 1)
					&& (r->next != NULL) && ((r->next->ch == '/') || (r->next->ch == 'l'))
					&& isClose(r->rect.size.height, r->next->rect.size.height, 0.08)) && (results->imageTests)) {
					char newCh1 = 'r';
					float totalWidth = rectRight(r->next->rect) - rectLeft(r->rect) + 1;
					float newWidth = (totalWidth - line->averageSpacing.average) / 2;
					if (newWidth < 5) {
						newWidth = (totalWidth - 1) / 2;
					}
					float newX1 = rectLeft(r->rect);
					float maxY = MAX(rectTop(r->rect), rectTop(r->next->rect));
					float minY = MIN(rectBottom(r->rect), rectBottom(r->next->rect));
					float newHeight = maxY - minY + 1;
					float newBottom = minY;
					CGRect newRect1(newX1, newBottom, newWidth, newHeight);

					char newCh2 = 'v';
					float newX2 = rectRight(r->next->rect) - newWidth + 1;
					CGRect newRect2(newX2, newBottom, newWidth, newHeight);
                    
                    CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                    SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results, false, SINGLE_LETTER_VALIDATE_COMP_SIZE|SINGLE_LETTER_VALIDATE_SINGLE_COMP);
                    if (st != NULL) {
                        ReplacingLog("ValidateLine: rule 0103 replacing [%c%c] with [%c%c] in word [%ls]", r->ch, r->next->ch, newCh1, newCh2, r->word->text().c_str());
                        r->word->updateLetterWithNewCharAndNewRect(r, newCh1, newRect1);
                        r->word->updateLetterWithNewCharAndNewRect(r->next, newCh2, newRect2);
                        r = r->next;
                        makeAnotherPass = true;
                        delete st;
                        continue;
                    }
				}
                
                // 'n' instead of "r."
                CGRect rect1, rect2;
                wchar_t newCh1, newCh2;
                bool foundDot = needToInsertDot (r, statsWithoutCurrent, results, rect1, rect2, newCh1, newCh2, NULL);
                // Found dot, and after (not before)
                if (foundDot && ((newCh2 == '.') || (newCh2 == ','))) {
                    // Still need to validate that letter looks like a 'r'
                    SingleLetterTests *st = CreateSingleLetterTests(rect1, results);
                    if (st != NULL) 
                    {
                        LimitedOpeningsTestResults resRight;
                        bool success = st->getOpeningsLimited(resRight, SingleLetterTests::Right, 
                            0.40,      // Start of range to search (top/left)
                            0.80,    // End of range to search (bottom/right)
                            0.35,
                            SingleLetterTests::Bound,   // Require start (top/left) bound
                            SingleLetterTests::Unbound  // Require end (bottom/right) bound
                            );
                        if (success && (resRight.maxDepth > rect1.size.width * 0.30)) 
                        {
                            newCh1 = 'r';
                            ReplacingLog("ValidateLine: rule 0121 replacing [%c] with [%c%c] in word [%s]", (unsigned short)r->ch, (unsigned short)newCh1, (unsigned short)newCh2, toUTF8(r->word->text()).c_str());
                            line->addLetterWithRectConfidenceAfterRect(newCh2, rect2, r->confidence, r);
                            r->word->updateLetterWithNewCharAndNewRect(r, newCh1, rect1);                                    
                            r = r->next;
                            makeAnotherPass = true;
                            delete st;
                            continue;
                        } else if (rect1.size.height > rect1.size.width * 2.5) {
                            newCh1 = 't';
                            ReplacingLog("ValidateLine: rule 0120 replacing [%c] with [%c%c] in word [%s]", (unsigned short)r->ch, (unsigned short)newCh1, (unsigned short)newCh2, toUTF8(r->word->text()).c_str());
                            line->addLetterWithRectConfidenceAfterRect(newCh2, rect2, r->confidence, r);
                            r->word->updateLetterWithNewCharAndNewRect(r, newCh1, rect1);  
                            r->confidence += 500; // Request inspection, could be 'l'                                  
                            r = r->next;
                            makeAnotherPass = true;
                            delete st;
                            continue;
                        }
                        delete st;
                    } // st != NULL
                }
                
                // Testing for lowness w/o being lax - for tests we feel secure about
                if ((r != NULL) && (results->imageTests) && (r->rect.size.width > statsWithoutCurrent->averageWidthNormalLowercase.average * 1.10))
                {
                    if (lowHeightTest(statsWithoutCurrent.getPtr(), r->rect.size.height, 2, false, results) == 0)
                    {
                        if (round == 0) {
                            makeAnotherPass = true;
                        } else {
                            bool doit = true;
                            char newCh2 = 't';
                            // n instead of rt
                            // [a (0x61)] at [718,106 - 733,123] [w=16,h=18]
                            // [n (0x6e)] at [735,107 - 754,125] [w=20,h=19]
                            // Had little dent between glued r & t + t taller (=> opening on left) + opening on right side
                            SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                            if (st != NULL) 
                            {
                                ConnectedComponentList cpl = st->getConnectedComponents();
                                if ((cpl.size() > 2) && (cpl[2].area > cpl[1].area * 0.05)) {
                                    // Suspicious but we are not dealing with this case here, skip
                                    doit = false;
                                }
                                if (doit)
                                {
                                    bool retest = false;
                                    // 'n' can be tallish because rect included a white line - test main CC and adjust rect if necessary
                                    if ((cpl.size() >= 2) && (cpl[1].getHeight() != r->rect.size.height)) {
                                        CGRect newRect (rectLeft(r->rect) + cpl[1].xmin, rectBottom(r->rect) + cpl[1].ymin, cpl[1].getWidth(), cpl[1].getHeight());
                                        r->word->updateLetterWithNewCharAndNewRect(r, r->ch, newRect);
                                        if (st != NULL) delete st;
                                        st = CreateSingleLetterTests(r->rect, results);
                                        if (st == NULL) {
                                            doit = false;
                                        }
                                        retest = true;
                                    }
                                    // Also test if bottom part has just one or two stray pixels (making it taller than it should). Matter only at height below 20 or so
                                    if (r->rect.size.height < 20) {
                                        SegmentList slVeryBottom = st->getHorizontalSegmentsPixels(r->rect.size.height-1, r->rect.size.height-1);
                                        if (slVeryBottom.size() >= 1) {
                                            int bottomWidth = slVeryBottom[slVeryBottom.size()-1].endPos - slVeryBottom[0].startPos + 1;
                                            int totalPixels = 0;
                                            for (i=0; i<slVeryBottom.size(); i++) {
                                                totalPixels += (slVeryBottom[i].endPos - slVeryBottom[i].startPos + 1);
                                            }
                                            if ((bottomWidth < r->rect.size.width * 0.50)
                                                || (totalPixels < r->rect.size.width * 0.20)) {
                                                CGRect newRect (rectLeft(r->rect), rectBottom(r->rect), r->rect.size.width, r->rect.size.height - 1);
                                                r->word->updateLetterWithNewCharAndNewRect(r, r->ch, newRect);
                                                if (st != NULL) delete st;
                                                st = CreateSingleLetterTests(r->rect, results);
                                                if (st == NULL) {
                                                    doit = false;
                                                }
                                                retest = true;
                                            }
                                        }
                                    }
                                    if (retest && (lowHeightTest(statsWithoutCurrent.getPtr(), r->rect.size.height, 2, false, results) != 0))
                                        doit = false;
                                }
                                if (doit)
                                {
                                    // Small dent on top
                                    OpeningsTestResults resTop;
                                        bool success = st->getOpenings(resTop, SingleLetterTests::Top, 
                                        0.25,      // Start of range to search (top/left)
                                        0.80,    // End of range to search (bottom/right)
                                        SingleLetterTests::Bound,   // Require start (top/left) bound
                                        SingleLetterTests::Bound  // Require end (bottom/right) bound
                                    );
                                    if (!success) {
                                        doit = false;
                                    }
                                }
                                if (doit) 
                                {
                                    // t taller and much to the right
                                    OpeningsTestResults resLeft;
                                    bool success = st->getOpenings(resLeft, SingleLetterTests::Left, 
                                        0.00,      // Start of range to search (top/left)
                                        0.30,    // End of range to search (bottom/right)
                                        SingleLetterTests::Unbound,   // Require start (top/left) bound
                                        SingleLetterTests::Bound  // Require end (bottom/right) bound
                                    );
                                    if (!success || (resLeft.maxDepth < r->rect.size.width * 0.40)) {
                                        doit = false;
                                    }
                                } 
                                if (doit) 
                                {
                                    OpeningsTestResults resTop;
                                    bool success = st->getOpenings(resTop, SingleLetterTests::Top, 
                                        0.30,      // Start of range to search (top/left)
                                        0.85,    // End of range to search (bottom/right)
                                        SingleLetterTests::Any,   // Require start (top/left) bound
                                        SingleLetterTests::Bound  // Require end (bottom/right) bound
                                    );
                                    if (!success || (resTop.maxDepth < r->rect.size.height * 0.19)) {
                                        doit = false;
                                    }
                                }                            
                                // Now check for opening on right (caused by t shape). Not all t's like that. but want to be safe
                                if (doit) {
                                    OpeningsTestResults resRight;
                                    bool success = st->getOpenings(resRight, SingleLetterTests::Right, 
                                    0.00,      // Start of range to search (top/left)
                                    1.00,    // End of range to search (bottom/right)
                                    SingleLetterTests::Bound,   // Require start (top/left) bound
                                    SingleLetterTests::Bound  // Require end (bottom/right) bound
                                    );
                                    if (!success || (resRight.maxDepthCoord > r->rect.size.height * 0.70)) {
                                        newCh2 = 'l';
                                    }
                                }          
                                if (st != NULL) delete st;
                            } // st != NULL
                            if (doit) 
                            {
                                char newCh1 = 'r';
                                float newWidth = r->rect.size.width / 2;
                                CGRect newRect1(rectLeft(r->rect), rectTop(r->rect) - statsWithoutCurrent->averageHeightNormalLowercase.average, newWidth, statsWithoutCurrent->averageHeightNormalLowercase.average);
                                CGRect newRect2(rectLeft(r->rect) + newWidth, rectBottom(r->rect), newWidth, r->rect.size.height);
                                ReplacingLog("ValidateLine: rule 0119 replacing [%c] with [%c%c] in word [%s]", (unsigned short)r->ch, newCh1, newCh2, toUTF8(r->word->text()).c_str());
                                r->confidence = 0;		// Protect it against replacements in the future
                                r->word->updateLetterWithNewCharAndNewRect(r, newCh1, newRect1);
                                // Ask single-letter to take a look, could be r+l or r+f
                                line->addLetterWithRectConfidenceAfterRect(newCh2, newRect2, 600, r);
                                // Skip current char & next
                                r = r->next->next;
                                continue;
                            }
                        } // round == '1'
                    } // tall 'n'
                    else if (lowHeightTest(statsWithoutCurrent.getPtr(), r->rect.size.height, 2, false, results) == 1)
                    {
                        if (round == 0) {
                            makeAnotherPass = true;
                        } else 
                        {
                            bool doit = true;
                            CGRect firstRect;                                    
                            CGRect secondRect;
                            // n instead of rr
                            // [e (0x65)] at [515,363 - 542,398] [w=28,h=36]
                            // [n (0x6e)] at [548,363 - 591,397] [w=44,h=35]
                            // [i (0x69)] at [597,363 - 611,409] [w=15,h=47]
                            // Had little dent between glued r & t + t taller (=> opening on left) + opening on right side
                            SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                            if (st != NULL) 
                            {
                                // We are looking for two patterns of roughly equal height, with at least 0.05% of width separating them + little notch on top + opening on right
                                ConnectedComponentList cpl = st->getConnectedComponents();
                                if ( (cpl.size() < 3) 
                                     || ((cpl.size() >= 4) && (cpl[3].area > cpl[2].area * 0.05))
                                     || ((cpl.size() >= 3) && ((cpl[2].getHeight() > cpl[1].getHeight() * 1.15) || (cpl[2].getHeight() < cpl[1].getHeight() * 0.85))) ) {
                                    // Suspicious but we are not dealing with this case here, skip
                                    doit = false;
                                }
                                if (doit) 
                                {
                                    ConnectedComponent firstComp, secondComp;
                                    if (cpl[1].xmax < cpl[2].xmax) {
                                        firstComp = cpl[1];
                                        secondComp = cpl[2];
                                    } else {
                                        firstComp = cpl[2];
                                        secondComp = cpl[1];                                    
                                    }
                                    if (secondComp.xmin - firstComp.xmax < r->rect.size.width * 0.05) {
                                        doit = false;
                                    }
                                    firstRect.origin.x = rectLeft(r->rect) + firstComp.xmin;
                                    firstRect.origin.y = rectBottom(r->rect) + firstComp.ymin;
                                    firstRect.size.width = firstComp.getWidth();
                                    firstRect.size.height = firstComp.getHeight(); 
                                                                        
                                    secondRect.origin.x = rectLeft(r->rect) + secondComp.xmin;
                                    secondRect.origin.y = rectBottom(r->rect) + secondComp.ymin;
                                    secondRect.size.width = secondComp.getWidth();
                                    secondRect.size.height = secondComp.getHeight(); 

                                    // Small dent on top
                                    SingleLetterTests *stFirst = CreateSingleLetterTests(firstRect, results);
                                    SingleLetterTests *stSecond = CreateSingleLetterTests(secondRect, results);
                                    
                                    if ((stFirst == NULL) || (stSecond == NULL)) {
                                        doit = false;
                                    }
                                    if (doit) {
                                        OpeningsTestResults resTop;
                                        bool success = stFirst->getOpenings(resTop, SingleLetterTests::Top, 
                                            0.10,      // Start of range to search (top/left)
                                            0.90,    // End of range to search (bottom/right)
                                            SingleLetterTests::Bound,   // Require start (top/left) bound
                                            SingleLetterTests::Bound  // Require end (bottom/right) bound
                                        );
                                        if (!success) {
                                            doit = false;
                                        }
                                    }
                                    if (doit) {
                                        OpeningsTestResults resTop;
                                        bool success = stSecond->getOpenings(resTop, SingleLetterTests::Top, 
                                            0.10,      // Start of range to search (top/left)
                                            0.90,    // End of range to search (bottom/right)
                                            SingleLetterTests::Bound,   // Require start (top/left) bound
                                            SingleLetterTests::Bound  // Require end (bottom/right) bound
                                        );
                                        if (!success) {
                                            doit = false;
                                        }
                                    }
                                    // Openings on right
                                    if (doit) {
                                        OpeningsTestResults resRight;
                                        bool success = stFirst->getOpenings(resRight, SingleLetterTests::Right, 
                                            0.00,      // Start of range to search (top/left)
                                            1.00,    // End of range to search (bottom/right)
                                            SingleLetterTests::Bound,   // Require start (top/left) bound
                                            SingleLetterTests::Any  // Require end (bottom/right) bound
                                        );
                                        if (!success || (resRight.maxDepth < firstRect.size.width * 0.20)) {
                                            doit = false;
                                        }
                                    }
                                    if (doit) {
                                        OpeningsTestResults resRight;
                                        bool success = stSecond->getOpenings(resRight, SingleLetterTests::Right, 
                                            0.00,      // Start of range to search (top/left)
                                            1.00,    // End of range to search (bottom/right)
                                            SingleLetterTests::Bound,   // Require start (top/left) bound
                                            SingleLetterTests::Any  // Require end (bottom/right) bound
                                        );
                                        if (!success || (resRight.maxDepth < firstRect.size.width * 0.20)) {
                                            doit = false;
                                        }
                                    }
                                    if (stFirst != NULL)
                                        delete stFirst;
                                    if (stSecond != NULL)
                                        delete stSecond;
                                } // doit                                             
                                delete st;
                            } // st != NULL
                            else {
                                doit = false;
                            }

                            if (doit) 
                            {
                                char newCh1 = 'r';
                                char newCh2 = 'r';
                                ReplacingLog("ValidateLine: rule 0197 replacing [%c] with [%c%c] in word [%s]", (unsigned short)r->ch, newCh1, newCh2, toUTF8(r->word->text()).c_str());
                                r->confidence = 0;		// Protect it against replacements in the future
                                r->word->updateLetterWithNewCharAndNewRect(r, newCh1, firstRect);
                                line->addLetterWithRectConfidenceAfterRect(newCh2, secondRect, 0, r);
                                // Skip current char & next
                                r = r->next->next;
                                continue;
                            }
                        } // round == 1
                    } // low 'n'
                } // wide 'n'
                
                // Not using "else" because the above test catches more yet doesn't handle all cases. TODO: need to merge both tests                
 				// Replacing with: "ri"
				// Give lowness every chance to prevail
				if ((r != NULL) && (lowHeightTest(statsWithoutCurrent.getPtr(), r->rect.size.height, 2, true, results) == 0)) {
                    // Refrain from the below iffy replacement at round 1 because there are other combinations (e.g. n< -> rK) which should have priority
                    if (round == 0) {
                        makeAnotherPass = true;
                    } else 
                    {
                        // Test if tall relative to immediate neigbors but if false wait before moving on, we may get confirmatory evidence to override this concern from singleletter tests
                        bool tallRelativeToNeighbors = isTallRelativeToNeigbors(r, r->rect.size.height, false);
                        // One more test, to check if the tallness is really caused by something connected (as opposed to just a spurious dot like)
                        SingleLetterTests *st = NULL;
                        bool doit = true;
                        if (results->imageTests) {
                            st = CreateSingleLetterTests(r->rect, results);
                            if (st != NULL) {
                                ConnectedComponentList cpl = st->getConnectedComponents();
                                if (cpl.size() > 1) 
                                {
                                    float actualHeight = cpl[1].getHeight();
                                    // Now retest the condition that got us here
                                    bool passedHeightTest = (lowHeightTest(statsWithoutCurrent.getPtr(), actualHeight, 2, true, results) == 0);
                                    bool newTallRelativeToNeighbors = isTallRelativeToNeigbors(r, actualHeight, false);
                                    if (!(passedHeightTest && newTallRelativeToNeighbors)) 
                                    {
                                        // OK so there is some minor component somewhere that caused this 'n' to appear tall. Check if we are not looking at "ri" with a dot above the right side
                                        if (cpl.size() >= 3) {
                                            // Two cases: r+i glued or not (as in Exalibur case)
                                            if (cpl.size() >= 4) 
                                            { 
                                                // 2nd comp (i) more or less same height as first (r)
                                                if ((abs(cpl[2].getHeight() - cpl[1].getHeight()) < cpl[1].getHeight() * 0.10)
                                                    // Smaller comp to the right of first
                                                    && (cpl[2].xmin > cpl[1].xmin)
                                                    // Now test the dot
                                                    && (cpl[3].ymax < cpl[2].ymin)
                                                    // Within the rightmost 10% of first comp (or entirely to the right of it)
                                                    && ((cpl[3].xmin - cpl[1].xmax) > -1 * cpl[1].getWidth())
                                                    // If a minor comp (small dot) was found entirely below main comp - ignore it by requiring that this dot be above the bar of the presumed 'i'
                                                    && (cpl[3].ymin <= cpl[2].ymin)
                                                    ) 
                                                {
                                                    // We have a "ri"!
                                                    char newCh1 = 'r';
                                                    char newCh2 = 'i';
                                                    CGRect newRect1(rectLeft(r->rect) + cpl[1].xmin, 
                                                        rectBottom(r->rect) + cpl[1].ymin,
                                                        cpl[1].getWidth(), cpl[1].getHeight());
                                                    float newWidth2 = MAX(cpl[2].xmax, cpl[3].xmax) - MIN(cpl[2].xmin, cpl[3].xmin)  + 1;
                                                    float newHeight2 = MAX(cpl[2].ymax, cpl[3].ymax) - MIN(cpl[2].ymin, cpl[3].ymin) + 1;
                                                    CGRect newRect2(rectLeft(r->rect) + cpl[2].xmin, 
                                                        rectBottom(r->rect) + cpl[3].ymin,
                                                        newWidth2, newHeight2);
                                                    ReplacingLog("ValidateLine: rule 0198 replacing [%c] with [%c%c] in word [%s]", (unsigned short)r->ch, newCh1, newCh2, toUTF8(r->word->text()).c_str());
                                                    r->word->updateLetterWithNewCharAndNewRect(r, newCh1, newRect1);
                                                    // Protect it from single-letter, we are pretty sure here
                                                    r->word->addLetterWithRectConfidenceAfterRect(newCh2, newRect2, 0, r);
                                                    r = r->next->next;
                                                    makeAnotherPass = true;
                                                    delete st;
                                                    continue;
                                                }
                                            } // 3 components
                                            else // 2 components 
                                            {
                                                // Above major comp
                                                // Test for noise!
                                                ConnectedComponent majorCC = cpl[1];
                                                ConnectedComponent minorCC = cpl[2];
                                                if (minorCC.area < majorCC.area * 0.10) {
                                                    // Way above
                                                    if ((majorCC.ymin - minorCC.ymax > statsWithoutCurrent->averageHeightNormalLowercase.average * 0.50)
                                                        // Way below
                                                        || (minorCC.ymin - majorCC.ymax > statsWithoutCurrent->averageHeightNormalLowercase.average * 0.50)) 
                                                    {
                                                        // Eliminate that minor cc, adjust n rect, we are done
                                                        CGRect newRect(rectLeft(r->rect) + majorCC.xmin, rectBottom(r->rect) + majorCC.ymin, majorCC.getWidth(), majorCC.getHeight());
                                                        ReplacingLog("ValidateLine: rule 0199 replacing, adjusting [%c] height in word [%s]", (unsigned short)r->ch, toUTF8(r->word->text()).c_str());
                                                        r->word->updateLetterWithNewCharAndNewRect(r, r->ch, newRect);
                                                        r = r->next;
                                                        makeAnotherPass = true;
                                                        delete st;
                                                        continue;                                                            
                                                    }
                                                }
                                                if ((cpl[2].ymax < cpl[1].ymin)
                                                    // Within the rightmost 10% of main comp (or entirely to the right of it)
                                                    && ((cpl[2].xmin - cpl[1].xmax) > -1 * cpl[1].getWidth())) 
                                                {
                                                    // We have a "ri"!
                                                    char newCh1 = 'r';
                                                    char newCh2 = 'i';
                                                    // Assume 2nd letter ('i') is 15% of width
                                                    CGRect newRect2(rectRight(r->rect) - cpl[1].getWidth() * 0.15, 
                                                        rectBottom(r->rect) + cpl[1].ymin,
                                                        cpl[1].getWidth() * 0.15, actualHeight);
                                                    CGRect newRect1(rectLeft(r->rect), 
                                                        rectBottom(r->rect) + cpl[1].ymin,
                                                        cpl[1].getWidth() * 0.85 - 1, actualHeight);
                                                    ReplacingLog("ValidateLine: rule 0200 replacing [%c] with [%c%c] in word [%s]", (unsigned short)r->ch, newCh1, newCh2, toUTF8(r->word->text()).c_str());
                                                    r->word->updateLetterWithNewCharAndNewRect(r, newCh1, newRect1);
                                                    r->word->addLetterWithRectConfidenceAfterRect(newCh2, newRect2, r->confidence, r);
                                                    r = r->next->next;
                                                    makeAnotherPass = true;
                                                    delete st;
                                                    continue;
                                                }
                                            }
                                        } // 2 or more components
                                        // As long as we got the main comp, update rect
                                        CGRect newRect(rectLeft(r->rect) + cpl[1].xmin, 
                                                   rectBottom(r->rect) + cpl[1].ymin,
                                                   cpl[1].getWidth(), actualHeight);
                                        ReplacingLog("ValidateLine: rule 0201 replacing - updating height of [%c] from [%.0f] to [%.0f] in word [%s]", (unsigned short)r->ch, r->rect.size.height, newRect.size.height, toUTF8(r->word->text()).c_str());
                                        r->word->updateLetterWithNewCharAndNewRect(r, r->ch, newRect);
                                        makeAnotherPass = true;
                                        // Case of multiple components and condition doesn't hold true, suggest aborting - unless it passed the height test and failed only the neighbors test then give it another chance (see case with "12rn" where 'r' was really a 't' hence caused neighbor height test to fail
                                        // If only one component, do not replace if failed neigbors test!
                                        if (!(passedHeightTest && newTallRelativeToNeighbors))
                                            doit = false;
                                    } // no longer tall after adjusting for actual main comp height
                                } // got list of components 
                                else {
                                    // Unexpected, failed to get components list, best to abort
                                    doit = false;
                                }
                            }
                        }
                        if (doit) {
                            // if we got here it means we have a single components returned as 'n' but abnormally tall. Could be h or glued rt - test it
                            char newCh = 'h';
                            // Now take into account tallness relative to neighbors, if not true make note of it then see if single-letter can revert that decision
                            doit = tallRelativeToNeighbors;
                            if (st != NULL) {
                                SegmentList sl = st->getHorizontalSegments(0.10, 0.01);
                                if (sl.size() > 0) {
                                    if (sl[0].startPos > r->rect.size.width * 0.5) {
                                        char newCh1 = 'r';
                                        char newCh2 = 't';
                                        float newWidth2 = (r->rect.size.width - sl[0].startPos) * 2;
                                        if (newWidth2 > r->rect.size.width / 2)
                                            newWidth2 = r->rect.size.width / 2;
                                        CGRect newRect2(rectRight(r->rect) - newWidth2 + 1, rectBottom(r->rect), newWidth2, r->rect.size.height);
                                        float newHeight1 = statsWithoutCurrent->averageHeightNormalLowercase.average;
                                        if (newHeight1 <= 0)
                                            newHeight1 = r->rect.size.height * 0.80;
                                        CGRect newRect1(rectLeft(r->rect), rectBottom(r->rect), r->rect.size.width - newRect2.size.width, r->rect.size.height);
                                        ReplacingLog("ValidateLine: rule 0202 replacing [%c] with [%c%c] in word [%s]", (unsigned short)r->ch, newCh1, newCh2, toUTF8(r->word->text()).c_str());
                                        r->word->updateLetterWithNewCharAndNewRect(r, newCh1, newRect1);
                                        r->word->addLetterWithRectConfidenceAfterRect(newCh2, newRect2, r->confidence, r);
                                        r = r->next->next;
                                        delete st;
                                        continue;
                                    }
                                    // test for possible D only if tall relative to neighbors (because a real n would also pass the test below) 
                                    else if (doit && (sl[0].endPos > r->rect.size.width * 0.20) 
                                        && ((r->previous == NULL) || (r->previous->ch == ' ') || ((r->next != NULL) && isupper(r->next->ch)))) {
                                        // First letter or surrounded by uppercase letters => give 'D' a chance
                                        ConnectedComponentList inverted = st->getInverseConnectedComponents();
                                        if (inverted.size() == 2)
                                            newCh = 'D';
                                    }
                                    // If not doit, do we have grounds to insist on replacing?
                                    else if (!doit) {
                                        // Yes if only one short segment at the 10% height (as opposed to a real n where there would be more than one or a longer one
                                        if ((sl.size() == 1) && (sl[0].endPos < r->rect.size.width * 0.20))
                                            doit = true;
                                    }
                                }
                            }
                            if (st != NULL)
                                delete st;
                            if (doit) {
                                ReplacingLog("ValidateLine: rule 0089 replacing [%c] with [%c] in word [%ls]", r->ch, newCh, r->word->text().c_str());
                                r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                            }
                        }
					}
				}
				else if ((r != NULL) && (r->next != NULL) && (toLower(r->next->ch) == 'o')
					&& (r->next->next != NULL) && (toLower(r->next->next->ch) == 'm')
					&& ((r->next->next->next == NULL) || (r->next->next->next->ch == ' ') || (r->next->next->next->ch == '\t') || (r->next->next->next->ch == '\n'))
					&& (statsWithoutCurrent->averageWidthNormalLowercase.count >= 2) && (r->rect.size.width > statsWithoutCurrent->averageWidthNormalLowercase.average*1.4) ) {
					// Replace 'n' with '.c' be wider than a normal lowercase char
					float newTotalWidth = r->rect.size.width;
					if ((line->averageSpacing.count > 0) && (line->averageSpacing.average < newTotalWidth/4)) {
						newTotalWidth -= line->averageSpacing.average;
					}
					char newCh1 = '.';
					// Adjust current rect to be the '.', use height set to 25% of current rect (usual ratio for '. relative to 'c')
					float newHeight =  r->rect.size.height*0.25;
					float newBottom = rectBottom(r->rect);
					CGRect newRect1(rectLeft(r->rect),
												 newBottom,
												 newTotalWidth*0.25,
												 newHeight);
					char newCh2 = 'c';
					newHeight = r->rect.size.height;
					newBottom = rectTop(r->rect) - newHeight + 1;
					CGRect newRect2(rectRight(r->rect)-newTotalWidth*0.75,
												 newBottom,
												 newTotalWidth*0.75,
												 newHeight);

					ReplacingLog("ValidateLine: rule 0088 replacing [%c] with [.c] in word [%s]", (unsigned short)r->ch, toUTF8(r->word->text()).c_str());
					r->confidence = 0;		// Protect it against replacements in the future
					r->word->updateLetterWithNewCharAndNewRect(r, newCh1, newRect1);
					line->addLetterWithRectConfidenceAfterRect(newCh2, newRect2, 0, r);
					// Skip current char & next
					r = r->next->next;
					continue;	// We don't expect other substitutions
				}
			}

#if DEBUG
			if ((r != NULL) && (r->ch == 'I') && (r->previous != NULL) && (r->previous->ch == '-')) {
				DebugLog("Found it");
			}
#endif

            // Test S next to digits if looks like 8
            if ((r->ch == 'S') && (results->imageTests) && !(r->flags2 & FLAGS2_TESTED_S_AS_DIGIT)
                && digitsNearby(r)) {
                char digitAlternative = SingleLetterTestSAsDigit(r, r->rect, 1, results, true);
                // If suggestion is '5', don't replace now, regex will do it if part of a number. Only worry about it being actually a '8'
                if ((digitAlternative != '\0') && (digitAlternative != '5')) {
                    char newCh = digitAlternative;
					ReplacingLog("ValidateLine: rule 0203 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
					r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
					makeAnotherPass = true;
                }
            }

            // We just tested cases of lowercase letters that look like uppercase letters and upcased them. Now it's time to test 'a' that are tall as digits
            if ((r->ch == 'a') && (statsWithoutCurrent->averageHeightDigits.count > 1) && (r->rect.size.height > statsWithoutCurrent->averageHeightDigits.average * (1 - OCR_ACCEPTABLE_ERROR))
                && ((statsWithoutCurrent->averageHeightNormalLowercase.count < 2) || (r->rect.size.height > statsWithoutCurrent->averageHeightNormalLowercase.average * (1 + OCR_ACCEPTABLE_ERROR)))
                // Double-check that this 'a' is also as tall as uppercase letters (if there are enough) - just in case we had an aberrant few false (low) digits that made us think this 'a' is tall
                && ((statsWithoutCurrent->averageHeightUppercase.count < 3) || (r->rect.size.height > statsWithoutCurrent->averageHeightUppercase.average * (1 - OCR_ACCEPTABLE_ERROR)))
                ) 
            {
                if (round == 0) {
                    makeAnotherPass = true;
                } else {
                    char newCh = SingleLetterTestSAsDigit(r, r->rect, 1, results, true);
                    if ((newCh != '\0') && (newCh != r->ch)) {
                        ReplacingLog("Validate: rule 0105 replacing, single-letter indicates [%c] is [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                        r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                        makeAnotherPass = true;
                        r = r->next;
                        continue;
                    }
                }
            }
            
#if DEBUG
            if ((r->ch=='3') && (r->previous != NULL) && (r->previous->ch=='1') && (r->previous->previous != NULL) && (r->previous->previous->ch=='0')) {
                DebugLog("Found in word [%s]!", toUTF8(r->word->text()).c_str());
                DebugLog("");
            }
#endif

            if ((r->ch == '3') && results->imageTests && !(r->flags2 & FLAGS2_TESTED_AS_DIGIT)) 
            {
                if (round == 0) {
                    makeAnotherPass = true;
                } else {
                    char newCh = SingleLetterTestSAsDigit(r, r->rect, 1, results, true);
                    r->flags2 |= FLAGS2_TESTED_AS_DIGIT;
                    if ((newCh != '\0') && (newCh != r->ch)) {
                        ReplacingLog("Validate: replacing, rule 0182 single-letter indicates [%c] is [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                        r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                        makeAnotherPass = true;
                        r = r->next;
                        continue;
                    }
                }
            }
            
            // Very narrow E -> I
            // [E (0x45)] at [865,112 - 869,135] [w=5,h=24]
            if ((r->ch == 'E') && (r->rect.size.height > r->rect.size.width * 4) && results->imageTests && !(r->flags6 & FLAGS6_TESTED_AS_I) && (tallHeightTest(statsWithoutCurrent.getPtr(), r->rect.size.height, '\0', false, 0, true) == 1))
            {
                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results, true, SINGLE_LETTER_VALIDATE_COMP_SIZE | SINGLE_LETTER_VALIDATE_SINGLE_COMP);
                if (st != NULL) {
                    ConnectedComponentList cpl = st->getConnectedComponents();
                    // Re-test height-to-width ratio on main CC
                    if (cpl[1].getHeight() > cpl[1].getWidth() * 4) {
                        char newCh = 'I';
                        ReplacingLog("Validate: E replacing [%c] width [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                        r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                        makeAnotherPass = true;
                        r = r->next;
                        continue;
                    }
                    delete st;
                }
            }

			// Matching: 'i' or 'I' extending below line (and not surrounded by spaces which could mean tab)
			// Replacing with: 'j' or 'J'
			if ((r != NULL) && (((r->ch == 'i') || (r->ch == 'I'))
				&& (((r->previous == NULL) || (r->previous->ch != ' '))
					|| ((r->next == NULL) || (r->next->ch != ' '))) )) {
				// Could be a [j]
				if ((line->averageHeightNormalLowercase.count >= 2) && (heightBelow(r, upsideDown) > line->averageHeightNormalLowercase.average * 0.25)) {
					// We have a [j]!
					char newCh = ((r->ch == 'i')? 'j':'J');
					ReplacingLog("ValidateLine: rule 0203 replacing [%c] with [%c] in word [%ls]", (unsigned short)r->ch, newCh, r->word->text().c_str());
					r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
					makeAnotherPass = true;
				}
			}

			// Better keep this test after upper/lower adjustments because it relies on testing adjacent chars for lower/upper status
			if ((r != NULL) && !(r->flags4 & FLAGS4_TESTED_l_AS_1) && ((r->ch == 'l') || (r->ch == '|'))) 
            {
                r->flags4 |=  FLAGS4_TESTED_l_AS_1;
				// Check for lowercase l adjacent to digits, it's usually a '1'
                bool previousIsDigit = false;
                if ((r->previous != NULL) && isDigit(r->previous->ch))
                    previousIsDigit = true;
                bool nextIsDigit = false;
                if ((r->next != NULL) && isDigit(r->next->ch))
                    nextIsDigit = true;         
                char newCh = '\0';
                // One of the neigbors is a digit
				if (isClose(line->averageHeightDigits, r->rect.size.height, 0.08) && (nextIsDigit || previousIsDigit)) 
                {
                    newCh = '1';
                    // Revisit only if one of the neighbors is not a digit AND is a letter
                    if (!nextIsDigit && (r->next != NULL) && isLetter(r->next->ch)) {
                        // Decide who wins based on distance
                        float spaceWithPrevious = (rectLeft(r->rect) + rectRight(r->rect)) / 2 - (rectLeft(r->previous->rect) + rectRight(r->previous->rect)) / 2;
                        float spaceWithNext = (rectLeft(r->next->rect) + rectRight(r->next->rect)) / 2 - (rectLeft(r->rect) + rectRight(r->rect)) / 2;
                        if (spaceWithPrevious > spaceWithNext * 1.2) {
                            if (isUpper(r->next->ch)) {
                                newCh = 'I';
                            } else {
                                newCh = 'l';
                            }
                        }
                    }
                    else if (!previousIsDigit && (r->previous != NULL) && isLetter(r->previous->ch)) {
                        // Decide who wins based on distance
                        float spaceWithPrevious = (rectLeft(r->rect) + rectRight(r->rect)) / 2 - (rectLeft(r->previous->rect) + rectRight(r->previous->rect)) / 2;
                        float spaceWithNext = (rectLeft(r->next->rect) + rectRight(r->next->rect)) / 2 - (rectLeft(r->rect) + rectRight(r->rect)) / 2;
                        if (spaceWithNext > spaceWithPrevious * 1.2) {
                            if (isUpper(r->previous->ch)) {
                                newCh = 'I';
                            } else {
                                newCh = 'l';
                            }
                        }
                    }
                    if ((newCh != '\0') && (newCh != r->ch)) {
                        ReplacingLog("ValidateLine: rule 0204 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                        r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                        makeAnotherPass = true;
                        r = r->next;
                        continue;
                    }
                }
			}

#if DEBUG
//			if ((r->ch == 1) && (r->previous != NULL) && (r->previous->ch == 'c')) {
//				DebugLog("Found it");
//			}
#endif

			// Testing: "l'l"
			// Replacing with: 'h'
			if ((r != NULL)
                && !(r->flags4 & FLAGS4_TESTED_AS_h)
			    && isVerticalLine(r->ch)
				&& (r->next != NULL) && (isQuote(r->next->ch) || isDash(r->next->ch))
				&& (r->next->next != NULL) && isVerticalLine(r->next->next->ch)
				&& (tallHeightTest(statsWithoutCurrentAndNextTwo.getPtr(), r->rect.size.height, '\0', false, 0, false) == 1)
				&& (lowHeightTest(statsWithoutCurrentAndNextTwo.getPtr(), r->next->next->rect.size.height, 0, false, results) == 1)
				)
			{
				// Replace with 'h'
                r->flags4 |= FLAGS4_TESTED_AS_h;
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect, r->next->next->rect);
                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results, true, SINGLE_LETTER_VALIDATE_COMP_SIZE|SINGLE_LETTER_VALIDATE_SINGLE_COMP);
                if (st != NULL) 
                {
                    char newCh = 'h'; //pq104
                    replaceThreeWithRect(r, newCh, combinedRect);
                    makeAnotherPass = true;
                    delete st;
                }
			}

//#if DEBUG
//			if ((r->ch == 'I') && (r->next != NULL) && (r->next->ch == '-')) {
//				DebugLog("Found");
//			}
//#endif

			// Testing: "I-I" or "I~I"
			// Replacing with: 'H'
			if ((r != NULL) 
                && results->imageTests && !(r->flags4 & FLAGS4_TESTED_AS_h)
                && isVerticalLine(r->ch)
				&& (tallHeightTest(statsWithoutCurrent.getPtr(), r->rect.size.height, 'I', false, 0, false) == 1)
				&& (r->next != NULL) && isDash(r->next->ch)
				&& (r->next->next != NULL) && isVerticalLine(r->next->next->ch)
				&& (tallHeightTest(statsWithoutCurrent.getPtr(), r->next->next->rect.size.height, 'I', false, 0, false) == 1)
				&& (widthTest(statsWithoutCurrent.getPtr(), SmartPtr<OCRRect>(), rectRight(r->next->next->rect)-rectLeft(r->rect)+1, 'H', 3, 0) == 1)) 
            {
                r->flags4 |= FLAGS4_TESTED_AS_h;
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect, r->next->next->rect);
                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results, true, SINGLE_LETTER_VALIDATE_COMP_SIZE|SINGLE_LETTER_VALIDATE_SINGLE_COMP);
                if (st != NULL) 
                {
                    char newCh = 'H';
                    replaceThreeWithRect(r, newCh, combinedRect);
                    makeAnotherPass = true;
                    delete st;
                }
			}

			// Testing: "l=" or "\=" or "x=" (with = not centered but rather high up)
			// Replacing with: 'F'
			if ((r != NULL) && (((r->ch == 'l') || (r->ch == '|') || (r->ch == '\\') || (r->ch == 'x'))
				&& (r->next != NULL) && (r->next->ch == '=')
				&& (isCloseOrGreaterThanAverage(statsWithoutCurrent->averageHeightUppercase, r->rect.size.height, 0.11)
					 || isCloseOrGreaterThanAverage(statsWithoutCurrent->averageHeightTallLowercase, r->rect.size.height, 0.08))
				)) {
				float spaceBelow = rectTop(r->rect) - rectTop(r->next->rect);
				float spaceAbove = abs(rectBottom(r->rect) - rectBottom(r->next->rect));
				if ((spaceBelow > r->rect.size.height * 0.25) && (spaceAbove < r->rect.size.height * 0.08)) 
                {
					replaceTwo(r, 'F');
					makeAnotherPass = true;
				}
			}

			// Testing: "r;" with height of uppercase
			// Relacing with: 'E'
			// Special check to detect 'r;' that is in reality a 'n'
			if ((r != NULL) && ((r->ch == 'r') && (r->next != NULL) && (r->next->ch == ';'))
				&& ((spaceBetween = rectLeft(r->next->rect) - rectRight(r->rect) - 1) <= 0)
				&& (statsWithoutCurrentAndNext->averageSpacing.average > spaceBetween)
				) 
			{
				float gap = gapAboveBaselineOfOtherRect(r, r->next);
				if ((gap < r->rect.size.height * 0.12) && (gap < r->next->rect.size.height)) 
                {
					char newCh = 'n';
					if (isClose(statsWithoutCurrent->averageHeightUppercase, r->rect.size.height, 0.08)
						&& (isClose(statsWithoutCurrent->averageHeightUppercase, r->next->rect.size.height, 0.08))) {
						newCh = 'E';
					}
					replaceTwo(r, newCh);
					makeAnotherPass = true;
				}
			}

			// Replace "vs/" with 'w' if after or before w
			if ((r != NULL) && ( (toLower(r->ch) == 'v') && (r->next != NULL) && (toLower(r->next->ch) == 's')
				&& (r->next->next != NULL) && (r->next->next->ch == '/')
				&& ( ((r->next->next->next != NULL) && (toLower(r->next->next->next->ch) == 'w'))
					 || ((r->previous != NULL) && (toLower(r->previous->ch) == 'w'))
					) )) {
				// Replace with 'w' or W
				char newCh = 'W';
				if (((r->next->next->next != NULL) && (r->next->next->next->ch == 'w'))
					|| ((r->previous != NULL) && (r->previous->ch == 'w'))) {
					newCh = 'w';
				}

				// width is 3 char combined
				float newWidth = rectRight(r->next->next->rect) - rectLeft(r->rect);
				CGRect newRect(rectLeft(r->rect),
											 rectBottom(r->rect),
											 newWidth,
											 r->rect.size.height);

				ReplacingLog("ValidateLine: rule 0114 replacing [%c%c%c] with [w] in word [%ls]", (unsigned short)r->ch, (unsigned short)r->next->ch, (unsigned short)r->next->next->ch, r->word->text().c_str());
				r->confidence = 0;		// Protect it against replacements in the future
				r->word->updateLetterWithNewCharAndNewRect(r, newCh, newRect);
				r->word->removeLetter(r->next);	// Remove 's'
				r->word->removeLetter(r->next);	// Remove '/'
				// Skip current char & next
				r = r->next;
				continue;	// We don't expect other substitutions
			}

			// Check for 'vv' or 'VV' and replace with 'w' or 'W' (screw savvy ...)
			if ((r != NULL) && (toLower(r->ch) == 'v') && (r->next != NULL) && (toLower(r->next->ch) == 'v')
                && ((spaceBetween = rectLeft(r->next->rect) - rectRight(r->rect) - 1) <= 0)
                && results->imageTests
                && !(r->flags5 & FLAGS5_TESTED_AS_w)
                )
            {
                r->flags5 |= FLAGS5_TESTED_AS_w;
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
                if (st != NULL) {
                    ConnectedComponentList cpl = st->getConnectedComponents();
                    bool doit = validateConnectedComponents(cpl, combinedRect);
                    // Test that we have only 3 horizontal segments on top, which means the V's are touching.
                    if (!doit) {
                        SegmentList slTop = st->getHorizontalSegments(0.075, 0.15);
                        if ((slTop.size() == 3)
                            && (slTop[0].endPos < combinedRect.size.width * 0.50)
                            && (slTop[2].startPos > combinedRect.size.width * 0.50)) {
                            doit = true;
                        }
                    }
                    if (doit) {
                        char newCh = 'W';
                        if ((r->ch == 'v') || (r->next->ch == 'v')) {
                            newCh = 'w';
                        }

                        replaceTwoWithRect(r, newCh, combinedRect, "rule 0288");

                        // 'w' doesn't participate in other subst
                        r = r->next;
                        delete st;
                        continue;                    
                    }
                } // st != NULL
			}

			// No need to validate height of 'x' as close to normal lowercase because we are past the code that adjust low uppercase and hgh lowercase
			if ((r != NULL) && ( (r->ch == 'x') && (r->next != NULL) && (toLower(r->next->ch) == 'o')
				&& (r->next->next != NULL) && (toLower(r->next->next->ch) == 'm')
				&& ((r->next->next->next == NULL) || (r->next->next->next->ch == ' ') || (r->next->next->next->ch == '\t') || (r->next->next->next->ch == '\n')) )) {
				// Replace 'x' with '.c'
				float newTotalWidth = r->rect.size.width;
				if ((line->averageSpacing.count > 0) && (line->averageSpacing.average < newTotalWidth/4)) {
					newTotalWidth -= line->averageSpacing.average;
				}
				char newCh1 = '.';
				// Adjust current rect to be the '.', use height set to 25% of current rect (usual ratio for '. relative to 'c')
				float newHeight =  r->rect.size.height*0.25;
				float newBottom = rectTop(r->rect) - newHeight + 1;
				CGRect newRect1(rectLeft(r->rect),
											 newBottom,
											 newTotalWidth*0.25,
											 newHeight);
				char newCh2 = 'c';
				newHeight =  r->rect.size.height;
				newBottom = rectTop(r->rect) - newHeight + 1;
				CGRect newRect2(rectRight(r->rect)-newTotalWidth*0.75,
											 newBottom,
											 newTotalWidth*0.75,
											 newHeight);

				ReplacingLog("ValidateLine: rule 0090 replacing [%c] with [.c] in word [%ls]", (unsigned short)r->ch, r->word->text().c_str());
				r->confidence = 0;		// Protect it against replacements in the future
				r->word->updateLetterWithNewCharAndNewRect(r, newCh1, newRect1);
				line->addLetterWithRectConfidenceAfterRect(newCh2, newRect2, 0, r);
				// Skip current char & next
				r = r->next->next;
				continue;	// We don't expect other substitutions
			}

			// . sequences, including .cxx and .coxx
			if ((r != NULL) && ((r->ch == '.') || (r->ch == ','))) {
				// ".t:om" instead of ".com"
				if ((r->next != NULL) && (r->next->ch == 't')
					&& (r->next->next != NULL) && (r->next->next->ch == ':')
					&& (r->next->next->next != NULL) && (r->next->next->next->ch == 'o')
					&& (r->next->next->next->next != NULL) && (r->next->next->next->next->ch == 'm') ) {
					// Replace '.t:om' with '.com'
					char newCh = 'c';
					float newWidth = rectRight(r->next->next->rect) - rectLeft(r->next->rect);
					// Adjust next rect to be 'c'
					float newHeight = (r->next->rect.size.height + r->next->next->rect.size.height)/2;
					float newBottom = (rectTop(r->next->rect) + rectTop(r->next->next->rect))/2 - newHeight + 1;
					CGRect newRect(rectLeft(r->next->rect),
												newBottom,
												newWidth,
												newHeight);

					ReplacingLog("ValidateLine: rule 0115 replacing [.t:om] with [.com] in word [%ls]", r->word->text().c_str());
					r->next->confidence = 0;		// Protect it against replacements in the future
					// Replace ',' with '.' if needed
					if (r->ch != '.')
						r->word->updateLetterWithNewCharAndNewRect(r, '.', r->rect);
					r->word->updateLetterWithNewCharAndNewRect(r->next, newCh, newRect);
					r->word->removeLetter(r->next->next); // Remove the ':'
					// Skip entire .com sequence
					r = r->next->next->next->next;
					continue;	// We don't expect other substitutions
				} else if ((r->next != NULL) && (toLower(r->next->ch) == 'c')) {
// .co + connected blob with 3 letters + space or end => assume 'm'
					// Avoid messing with .co.il
					float firstSpace;
					float secondSpace;
					OCRRectPtr blobR;
					if (((r->next->next != NULL) && ((toLower(r->next->next->ch) == 'o') || (r->next->next->ch == '0')))
						&& ((blobR=r->next->next->next) != NULL) && (blobR->ch != '.')
						&& (blobR->next != NULL)
						&& (((blobR->ch == 'Y')
							     && ((blobR->next->ch == 'l') || (blobR->next->ch == '1') || (blobR->next->ch == '|')))
						     || ((firstSpace = (rectLeft(blobR->next->rect) - rectRight(blobR->rect) - 1)) <= 0))
						&& (blobR->next->next != NULL)
						&& (((blobR->next->next->ch == 'l') || (blobR->next->next->ch == '1') || (blobR->next->next->ch == '|'))
							 || ((secondSpace = (rectLeft(blobR->next->next->rect) - rectRight(blobR->next->rect) - 1)) <= 0))
						&& ((blobR->next->next->next == NULL) || (blobR->next->next->next->ch == ' '))
						) {
							// Replace connect blob with 'm'
						char newCh = 'm';
						float newWidth = rectRight(blobR->next->next->rect) - rectLeft(blobR->rect) + 1;
						float maxTop = MAX(MAX(rectTop(blobR->rect), rectTop(blobR->next->rect)), rectTop(blobR->next->next->rect));
						float minBottom = MIN(MIN(rectBottom(blobR->rect), rectBottom(blobR->next->rect)), rectBottom(blobR->next->next->rect));
						float newHeight = maxTop - minBottom + 1;
						float newBottom = maxTop - newHeight + 1;
						CGRect newRect(rectLeft(blobR->rect),
													newBottom,
													newWidth,
													newHeight);
						ReplacingLog("Validate: replacing [%c%c%c] with [%c] in word [%s]",
									 (unsigned short)blobR->ch, (unsigned short)blobR->next->ch, (unsigned short)blobR->next->next->ch, newCh, toUTF8(r->word->text()).c_str());
						r->word->removeLetter(blobR->next);
						r->word->removeLetter(blobR->next);
						r->word->updateLetterWithNewCharAndNewRect(blobR, newCh, newRect);
						if (r->next->next->ch == '0') {
							r->word->updateLetterWithNewCharAndNewRect(r->next->next, 'o', r->next->next->rect);
						}
						r = blobR->next;
						continue;
					//}
					}
					// Spurious ':' or '.' within ".c:om"
					if ((r->next->next != NULL) && ((r->next->next->ch == ':') || (r->next->next->ch == '.'))
						&& (r->next->next->next != NULL) && (r->next->next->next->ch == 'o')
						&& (r->next->next->next->next != NULL) && (r->next->next->next->next->ch == 'm')) {
						// Replace '.c:om' with '.com'
						ReplacingLog("ValidateLine: rule 0205 replacing [.c:om] with [.com] in word [%s]", toUTF8(r->word->text()).c_str());
						// Replace ',' with '.' if needed
						if (r->ch != '.')
							r->word->updateLetterWithNewCharAndNewRect(r, '.', r->rect);
						// Absorb the space created by removing the spurious char by adding it to the 'c'
						r->word->updateLetterWithNewCharAndNewRect(r->next,r->next->ch,
								CGRect(rectLeft(r->next->rect), rectBottom(r->next->rect),
										   rectRight(r->next->next->rect)-rectLeft(r->next->rect)+1, r->next->rect.size.height));
						r->word->removeLetter(r->next->next);
						// Skip entire .com sequence
						r = r->next->next->next->next;
						continue;	// We don't expect other substitutions
					// ".com" on email address got returned as ".corn"
					} else if ( (r->next->next != NULL) && (r->next->next->ch == 'o')
							&& (r->next->next->next != NULL) && (r->next->next->next->ch == 'r')
							&& (r->next->next->next->next != NULL) && (r->next->next->next->next->ch == 'n') ) {
							// Replace '.corn' with '.com'
							char newCh = 'm';
							float newWidth = rectRight(r->next->next->next->next->rect) - rectLeft(r->next->next->next->rect);
							// Adjust current rect to be the '.', use height set to 25% of current rect (usual ratio for '. relative to 'c')
							float newHeight = (r->next->next->next->rect.size.height + r->next->next->next->next->rect.size.height)/2;
							float newBottom = (rectTop(r->next->next->next->rect) + rectTop(r->next->next->next->next->rect))/2 - newHeight + 1;
							CGRect newRect(rectLeft(r->next->next->next->rect),
														newBottom,
														newWidth,
														newHeight);

							ReplacingLog("ValidateLine: rule 0206 replacing [.corn] with [.com] in word [%ls]", r->word->text().c_str());
							r->next->next->next->confidence = 0;		// Protect it against replacements in the future
							// Replace ',' with '.' if needed
							if (r->ch != '.')
								r->word->updateLetterWithNewCharAndNewRect(r, '.', r->rect);
							r->word->updateLetterWithNewCharAndNewRect(r->next->next->next, newCh, newRect);
							r->word->removeLetter(r->next->next->next->next);
							// Skip entire .corn sequence
							r = r->next->next->next->next;
							continue;	// We don't expect other substitutions

					} else if ( (r->next->next != NULL) && (r->next->next->ch == 'Q')
						&& (r->next->next->next != NULL) && (toLower(r->next->next->next->ch) == 'm') ) {
						// Replace '.cQm' with '.com'
						char newCh = 'o';
						if ((r->next->ch == 'C') && (r->next->next->next->ch == 'M'))
							newCh = 'O';
						ReplacingLog("Validate: rule 0528 replacing [%c] with [%c] in word [%ls]", r->next->next->ch, newCh, r->word->text().c_str());
						r->word->updateLetterWithNewCharAndNewRect(r->next->next, newCh, r->next->next->rect);
						// Skip entire .com sequence
						r = r->next->next->next->next;
						continue;	// We don't expect other substitutions
					}
				}
			}

			// Mape "lnc" to "inc"
			if ((r != NULL) && ( (r->previous != NULL) && ((r->previous->ch == ' ') || (r->previous->ch == '\n') || (r->previous->ch == '\t'))
				&& (r->ch == 'l')
				&& (r->next != NULL) && (r->next->ch == 'n')
				&& (r->next->next != NULL) && (r->next->next->ch == 'c')
				&& (r->next->next->next != NULL) && ((r->next->next->next->ch == '.') || (r->next->next->next->ch == ' ') || (r->next->next->next->ch == '\t') || (r->next->next->next->ch == '\n'))
				)) {
				// Replace 'l' with 'I'
				char newCh = 'I';
				ReplacingLog("ValidateLine: rule 0207 replacing [lnc] with [Inc] in word [%ls]", r->word->text().c_str());
				r->confidence = 0;		// Protect it against replacements in the future
				r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
				r = r->next->next->next;
				continue;	// We don't expect other substitutions
			}

//#if DEBUG
//			if ((r->ch == '|') && (r->next->ch == '2')) {
//				DebugLog("Found it");
//			}
//#endif

			// Testing: low '|' & wider than super narrow
			// Replacing with: 'r'
			// Setting cert level to 3 to make sure we don't perform that subst at the wrong places
			if ((r != NULL) && ((r->ch == '|')
				&& (tallHeightTest(statsWithoutCurrent.getPtr(), r->rect.size.height, 'r', false, 3, true) == 0)
                && (isTallRelativeToNeigbors(r, r->rect.size.height, false) == false)
				&& ((statsWithoutCurrent->averageWidthSuperNarrow1.count == 0)
					// '|' had width = 3 vs average narrow = 2.25 => 1.33x
					  || (r->rect.size.width > statsWithoutCurrent->averageWidthSuperNarrow1.average * 1.35)))) 
            {
				char newCh = '\0';
                if (results->imageTests) 
                {
                    SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                    if (st != NULL) {
                        ConnectedComponentList cpl = st->getConnectedComponents();
                        // Only one component (or next one less than  1/20th)
                        // Could be a 'i'!
                        if ((cpl.size() > 2) && (cpl[2].area < cpl[1].area * 0.06)
                            // Dot above
                            && (cpl[2].ymax < cpl[1].ymin)) 
                        {
                            newCh = 'i';
                            r->confidence += 500; // Force single-letter testing!
                        } else 
                        {
                            // If it's a 'r', look for bounded opening
                            OpeningsTestResults resRight;
                            bool success = st->getOpenings(resRight, SingleLetterTests::Right, 
                                0.00,      // Start of range to search (top/left)
                                0.50,    // End of range to search (bottom/right)
                                SingleLetterTests::Bound,   // Require start (top/left) bound
                                SingleLetterTests::Unbound  // Require end (bottom/right) bound
                                );
                            if (success && (resRight.maxDepth > cpl[1].getWidth() * 0.15)) {
                                newCh = 'r';
                            } else {
                                newCh = 'l';
                                r->confidence += 500; // Force single-letter testing!
                            }
                        }
                        delete st;
                    }
                } // singleletter
                if (newCh == '\0') {
                    newCh = 'r';
                }
				ReplacingLog("ValidateLine: rule 0208 replacing [%c] with [%c] in word [%ls]", (unsigned short)r->ch, newCh, r->word->text().c_str());
				// Don't protect, iffy subst
				//r->confidence = 0;		// Protect it against replacements in the future
				r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
				makeAnotherPass = true;
			}
            
//#if DEBUG
//			if (isQuote(r->ch) && (r->next != NULL) && (r->next->ch == '-')) {
//				DebugLog("Found it");
//			}
//#endif

            OCRVerboseLog("OCRValidate: about to check rule 0298");
			// Replace "'/" or "-/" with '7'
            // 0x2018 + ! -> 7
            // [- (0x2d)] at [856,267 - 865,270] [w=10,h=4]
            // [/ (0x2f)] at [860,250 - 870,270] [w=11,h=21]
			if ((isQuote(r->ch) || (r->ch == '-')) 
                && (r->next != NULL) && (isVerticalLine(r->next->ch) || (r->next->ch == '?'))
                // Quote above mid-point of the next letter                
                && (rectTop(r->next->rect) - rectTop(r->rect) > r->next->rect.size.height * 0.50)
                // Overlapping
                && (rectSpaceBetweenRects(r->rect, r->next->rect) < 0)
                // Rest of line not glued
                && ((r->next->next == NULL) || (rectSpaceBetweenRects(r->next->rect, r->next->next->rect) > 0))
                 )
            {
                // One more test: check that the bottom of the next letter is not touching the right side (i.e. that it is sloping right like a /)
                bool doit = true;
                char newCh = '7';
                if (results->imageTests && !(r->flags3 & FLAGS3_TESTED_AS_7)) {
                    float minX = MIN(rectLeft(r->rect), rectLeft(r->next->rect));
                    float maxX = MAX(rectRight(r->rect), rectRight(r->next->rect));
                    float minY = MIN(rectBottom(r->rect), rectBottom(r->next->rect));
                    float maxY = MAX(rectTop(r->rect), rectTop(r->next->rect));
                    CGRect combinedRect (minX, minY, maxX - minX + 1, maxY - minY + 1);
                    SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
                    if (st != NULL) {
                        // Has a top like 7?
                        bool hasTop = st->getSide(SingleLetterTests::Top, 0.90, true);
                        if (hasTop) {
                            SegmentList sl = st->getHorizontalSegments(0.95, 0.05);
                            if (sl.size() >= 1) {
                                Segment lastSegment = sl[sl.size() - 1];
                                if (lastSegment.endPos > combinedRect.size.width * 0.80) {
                                    doit = false;
                                }
                            }
                        } // hasTop
                        else {
                            if ( (combinedRect.size.height > combinedRect.size.width * 1.4)
                                  && (((r->previous != NULL) && isDigit(r->previous->ch))
                                     || ((r->previous != NULL) && (r->previous->ch == ' ') && (r->previous->previous != NULL) && isDigit(r->previous->previous->ch))
                                     // Next ch is the vertical line, skip it
                                     || ((r->next != NULL) && (r->next->next != NULL) && isDigit(r->next->next->ch))
                                     || ((r->next != NULL) && (r->next->next != NULL) && (r->next->next->ch == ' ') && (r->next->next->next != NULL) && isDigit(r->next->next->next->ch))
                                     ) ) {
                                newCh = '1';
                            } else {
                                doit = false;
                            }
                        }
                    }
                    delete st;
                }
                if (doit) {
                    replaceTwo(r, newCh, "rule 0298"); // = '7' or = '1'
                    makeAnotherPass = true;
                }
			}

			// Replace "l\" with 'k' if '\' low relative to 'l'
			if (((r->ch == 'l') && (r->next != NULL) && (r->next->ch == '\\')
				&& (r->next->rect.size.height < r->rect.size.height * (13.0/20.0)))) {
				float spaceBetween = rectLeft(r->next->rect) - rectRight(r->rect) - 1;
				if ((spaceBetween <= 0) && (statsWithoutCurrent->averageSpacing.average > 0)) {
					char newCh = 'k';
					if (((r->previous == NULL) || (r->previous->ch == ' '))
						|| ((r->next != NULL) && isupper(r->next->ch))) {
						newCh = 'K';
					}
					replaceTwo(r, newCh);
					makeAnotherPass = true;
				}
			}
            
#if DEBUG
            if ((r->ch =='o') && (r->previous != NULL) && (r->previous->ch =='o')) {
                DebugLog("Found it");
                if (!line->isItalic()) {
                    DebugLog("Not italic!!!");
                }
            }
#endif
            
            bool gluedToNext = false, gluedToPrevious = false;
            if ((r->previous != NULL) && (rectSpaceBetweenRects(r->previous->rect, r->rect) <= 0) && (r->previous->ch != ' '))
                gluedToPrevious = true;
            
            if ((r->next != NULL) && (rectSpaceBetweenRects(r->rect, r->next->rect) <= 0) && (r->next->ch != ' '))
                gluedToNext = true;
            
            // 'a' instead of 'c'
            // 'u' instead of 'c'
            // [u (0x75)] at [722,83 - 730,96] [w=9,h=14]
            // Depth was 5 pixels of of width=9 => 55%, opening width was 3.5 pixels (out of height 14) => 25%
            if ((results->imageTests)
                    // U+00FC		c3 bc	LATIN SMALL LETTER U WITH DIAERESIS
                     && ((r->ch == 'a') || (r->ch == 'u') || (r->ch == 0xfc))
                    && !(r->flags & TESTED_OPENING_RIGHT)
                    // Don't test if letter to the right is glued, could block the opening!
                    && ((r->next == NULL) || (r->next->ch == ' ') || !gluedToNext)) {
                if (round == 0) {
                    makeAnotherPass = true;
                } else 
                {   
                    SingleLetterTests * st = CreateSingleLetterTests(r->rect, results);
                    if ((st != NULL) && validateConnectedComponents(st, r->rect))
                    {
                        LimitedOpeningsTestResults resRight;
                        bool successRight = st->getOpeningsLimited(resRight, SingleLetterTests::Right, 
                            0.10,      // Start of range to search (top/left)
                            0.90,    // End of range to search (bottom/right)
                            0.50,
                            SingleLetterTests::Bound,   // Require start (top/left) bound
                            SingleLetterTests::Bound  // Require end (bottom/right) bound
                            );
                        
                        r->flags |= TESTED_OPENING_RIGHT;
                        
                        // Valid results
                        if (successRight
                            // Opening on right side with a depth at least 35% of width
                            && (resRight.maxDepth > r->rect.size.width * ((r->ch == 'u')? 0.50:0.35)) 
                            // Opening is at least 20% of height in  width
                            && (resRight.minWidth > r->rect.size.height * 0.20)) 
                        {
                            // Opening on right size, assume 'c'
                            char newCh = 'c';
                            
                            ReplacingLog("ValidateLine: rule 0209 replacing [%c] with [%c] in word [%s], depth was %.2f (%%%.2f)", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str(), resRight.maxDepth, (float)resRight.maxDepth/r->rect.size.height);
                            r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);					
                            makeAnotherPass = true;
                            r = r->next;
                            delete st;
                            continue;
                        }
                    } // st != NULL
                    if (st != NULL)
                        delete st;
                }
            }          
            
#if DEBUG
            if ((r->ch =='o') && (r->next != NULL) && (r->next->ch =='f')) {
                DebugLog("Found");
            }
#endif            
            
            // 'c' instead of 'e'
            // We have another 'c' -> 'e' test based on finding a hole on top. It appears to catch some cases not handled by the below.
            if ((r->ch == 'c') && !(r->flags4 & FLAGS4_TESTED_AS_c) && results->imageTests) {
                if (round == 0) {
                    makeAnotherPass = true;
                } else {
                    bool doit = false;
                    r->flags4 |= FLAGS4_TESTED_AS_c;
                    SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                    if (st != NULL) {
                        // Check top area: ideally we want to find two segments when looking at vertical sections left and right because of the eye of the 'e'
                        SegmentList slLeft = st->getVerticalSegments(0.45, 0.01);
                        SegmentList slRight = st->getVerticalSegments(0.70, 0.01);
                        // Make sure left & right segments start not too far below top - this test seems to require letters like c/o/e/a (rounded on top) as opposed to i/t/l etc. Not sure why this test is important here but it's certainly far from sufficient. Also requires a 2nd segment (presumed at bottom)
                        if ((slLeft.size() >=2) && (slLeft[0].startPos < r->rect.size.height * 0.15)
                            && (slRight.size() >=2) && (slRight[0].startPos < r->rect.size.height * 0.15)) 
                        {
                            // Case with 3 segments => increases the chance we have a semi-closed eye on top
                            if (slLeft.size() >= 3) {
                                float bottomStroke = slLeft[slLeft.size()-1].endPos - slLeft[slLeft.size()-1].startPos + 1;
                                float eyeHeight = slLeft[1].startPos - slLeft[0].endPos + 1;
                                // Eye not dropping too low
                                if ((eyeHeight < r->rect.size.height * 0.50)
                                    // Eye tall enough
                                    && (eyeHeight > r->rect.size.height * 0.15)
                                    // Taller than bottom thickness (stroke)
                                    && (eyeHeight >= bottomStroke * 1.5)) {
                                    doit = true;
                                }
                            }
                            // Last attempt: search for a deep opening left or right
                            if (!doit) {
                                CGRect leftSide(rectLeft(r->rect), rectBottom(r->rect), r->rect.size.width / 2, r->rect.size.height / 2);
                                SingleLetterTests *stLeft = CreateSingleLetterTests(leftSide, results, false, 0, 0.03, true);
                                if (stLeft != NULL) {
                                    OpeningsTestResults resLeft;
                                    bool success = stLeft->getOpenings(resLeft, SingleLetterTests::Left, 
                                        0,      // Start of range to search (top/left)
                                        1.00,    // End of range to search (bottom/right)
                                        SingleLetterTests::Bound,   // Require start (top/left) bound
                                        SingleLetterTests::Bound  // Require end (bottom/right) bound
                                        );
                                    if (success && (resLeft.maxDepth > r->rect.size.width * 0.25)) {
                                        doit = true;
                                    }
                                    delete stLeft;
                                }
                                if (!doit) {
                                    CGRect RightSide(rectRight(r->rect) - r->rect.size.width / 2, rectBottom(r->rect), r->rect.size.width / 2, r->rect.size.height / 2);
                                    SingleLetterTests *stRight = CreateSingleLetterTests(RightSide, results);
                                    if (stRight != NULL) {
                                        OpeningsTestResults resRight;
                                        bool success = stRight->getOpenings(resRight, SingleLetterTests::Right, 
                                            0,      // Start of range to search (top/left)
                                            1.00,    // End of range to search (bottom/right)
                                            SingleLetterTests::Bound,   // Require start (top/left) bound
                                            SingleLetterTests::Bound  // Require end (bottom/right) bound
                                            );
                                        // Demand deeper on the right side because some 'c's may have a little thing on the right
                                        if (success && (resRight.maxDepth > r->rect.size.width * 0.35)) {
                                            doit = true;
                                        }
                                        delete stRight;
                                    }                            
                                }
                            }
                        } // left & right segments start not too far below top
                        delete st;
                    }
                    if (doit) {
                        char newCh = 'e';
                        ReplacingLog("ValidateLine: rule 0210 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                        r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);					
                        makeAnotherPass = true;
                        r = r->next;
                        continue;
                    }
                }
            }
            
            // o instead of a - test for the presence of an opening on the left side
            // Only test this 'o' in any way if we didn't find open a's here - otherwise leave this 'o' alone
            if ((results->imageTests) && (r->ch == 'o') && !lineHasRealAs) {
                // Test if it has an opening to the left => real 'a', replace
                if (!(r->flags6 & FLAGS6_TESTED_AS_Reala)) {
                    r->flags6 |= FLAGS6_TESTED_AS_Reala;
                    wchar_t newCh = '\0';
                    if (SingleLetterTestAsa(r, statsWithoutCurrent, results, newCh,
                                        // Pretend line has real a's in the test below so that TestAsa doesn't call this one a 'a' just because it finds a dent bottom right
                                        true, NULL,
                                        // Not strict
                                        false) && (newCh != '\0') && (newCh != r->ch)) {
                        lineHasRealAs = true;
                        ReplacingLog("ValidateLine: rule 0011 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)newCh, toUTF8(r->word->text()).c_str());
                        r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                        makeAnotherPass = true;
                    } else {
                        // Allow this letter to be tested as 'a' again
                        r->flags2 &= ~ FLAGS2_TESTED_AS_a;
                    }
                } else {
                    if (round == 0) {
                        // If first round, wait: we may discover open a's later on this line
                        makeAnotherPass = true;
                    } else {
                        // Now test this 'o' while accepting closed 'a's
                        wchar_t newCh = '\0';
                        if (SingleLetterTestAsa(r, statsWithoutCurrent, results, newCh,
                                                lineHasRealAs, NULL,
                                                // Not strict
                                                false) && (newCh != '\0') && (newCh != r->ch))
                        {
                            ReplacingLog("ValidateLine: rule 0012 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)newCh, toUTF8(r->word->text()).c_str());
                            r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                            makeAnotherPass = true;
                        }
                    }
                }
            }
            
#if DEBUG
            if ((r->ch =='0') && (r->previous != NULL) && (r->previous->ch =='9') && (r->previous->previous != NULL) && (r->previous->previous->ch =='.')) {
                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results); if (st != NULL) delete st;
                DebugLog("Found in word [%s]!", toUTF8(r->word->text()).c_str());
                DebugLog("Found");
            }
#endif
            
            // Count if we have 'a' letters on this line which have a real opening to the left. If so, remember that for round 2 and then test other 'a' letters and demand that they have an opening too, otherwise they are 'o's!
            if ((results->imageTests)
                && (r->ch == 'a')
                     // Not tested for 'o' yet
                && !(r->flags & a_TESTED_AS_o)) 
            {
                if (!lineHasRealAs) {
                    // No real a's detected yet. Check if there is a chance that it will help to test that 'a'
                    // Helpful only if there is another 'a'/'o' on the line, otherwise we won't dare correct even if we look like 'o'
                    if ((OCRLine::isPresentInLineAfterRect('a', r) || OCRLine::isPresentInLineBeforeRect('a', r)
                         // Or we have lowercase 'o's on the line (who need protection against being tested as a closed 'a')
                         || OCRLine::isPresentInLineAfterRect('o', r) || OCRLine::isPresentInLineBeforeRect('o', r))
                        // Don't test if letter to the left is glued, could block the opening!
                         && ((r->previous == NULL) || (r->previous->ch == ' ') || !gluedToPrevious)) {
                        float width = 0, height = 0, depth = 0, openingWidth = 0;
                        bool success = OCRUtilsOpeningsTest(r->rect, results, GET_OPENINGS_LEFT, false,
                                 // Look at bottom half
                                 0.00,         //start position
                                 0.70,         //end position
                                 true,         //bounds_required
                                 0.2,			// letter_thickness (determines the depth at which we test the opening width)
                                 &width,			// outWidth 
                                 &height,		// outHeight,
                                 &depth,	// outMaxDepth (can have a width of just 1 pixel)
                                 NULL,			// outAverageWidth
                                 &openingWidth,			// outOpeningWidth (can be larger than letter thickness but not less)
                                 NULL,			// outMaxWidth
                                 NULL);			// outArea
                        
                        r->flags |= TESTED_OPENING_LEFT;
                        
                        if ((success && (width > 0)) && (depth > width * 0.20) && (openingWidth > height * 0.10)
                            // && (height * width > r->rect.size.height * r->rect.size.width * 0.75)
                            ) {
                            // Pretend we tested this 'a' as 'o': we found an opening on the left so we conclude that other 'a's must have an opening too, but this one doesn't need to be tested as a possible 'o'
                            r->flags |= a_TESTED_AS_o;
                            lineHasRealAs = true;
                            ReplacingLog("ValidateLine: real (open) a in word [%s]", toUTF8(r->word->text()).c_str());
                            makeAnotherPass = true;
                        }
                    } else {
                        // This is very esoteric: we set this value so that we test 'u' for 'a' at pass 1, so that next pass we may discover that we have real a's
                        if (round == 0)
                            testUAnyhow = true;
                    }
                } // !lineHasRealAs
                else if // Don't test if letter to the left is glued, could block the opening!
                     ((r->previous == NULL) || (r->previous->ch == ' ') || !gluedToPrevious) 
                {
                    // There ARE real a's - so test the current one and if it doesn't pass, change to 'o'!
                    r->flags |= a_TESTED_AS_o;
                    wchar_t newCh = '\0';
                    if (SingleLetterTestAsa(r, statsWithoutCurrent, results, newCh, lineHasRealAs, NULL, false)
                        && (newCh != '\0') && (newCh != r->ch)) 
                    {
                        ReplacingLog("ValidateLine: rule 0011 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)newCh, toUTF8(r->word->text()).c_str());
                        r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);					
                        makeAnotherPass = true;
                    }
                }
            }
    
            
			// 'U' instead of 'O'
			// 'u' instead of 'a'
			if ((results->imageTests)
                // U+00DC		c3 9c	LATIN CAPITAL LETTER U WITH DIAERESIS
				&& ((r->ch == 'U') || (r->ch == 0xdc) || (r->ch == 'u') || (r->ch == 0xfc))
                && (!(r->flags6 & FLAGS6_TESTED_AS_U) || !(r->flags2 & FLAGS2_TESTED_AS_a))
                ) {
				// Wait till 2nd round just in case further adjustments from uppercase to lowercase will be done
				if ((round == 0) && !testUAnyhow) {
					makeAnotherPass = true;
				} else 
				{
                    if (!line->isItalic()) {
                        wchar_t newCh1;
                        wchar_t newCh2;
                        CGRect newRect1, newRect2;
                        if ((SingleLetterTestU(r, r->rect, statsWithoutCurrent, results, newCh1, newCh2, newRect1, newRect2) == 1.0)
                                && ((newCh1 != r->ch) || (newCh2 != '\0'))) {
                            ReplacingLog("ValidateLine: rule 0005 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)newCh1, toUTF8(r->word->text()).c_str());
                            r->word->updateLetterWithNewCharAndNewRect(r, newCh1, newRect1);
                            if (newCh2 != '\0') {
                                ReplacingLog("ValidateLine: rule 0005 replacing, adding [%c] after [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)newCh2, toUTF8(r->word->text()).c_str());
                                line->addLetterWithRectConfidenceAfterRect(newCh2, newRect2, r->confidence, r);
                            }					
                            makeAnotherPass = true;
                            r = r->next;
                            continue;
                        }
                    }
                    testUAnyhow = false;
                    float height = 0, topDepth, width = 0;
                   
                    // False 'u' had a bad rect whereby top part was empty. This caused the opening test to return a too deep opening (4 instead of 1)
                    // test real height
                    SingleLetterTests *st = CreateSingleLetterTests(r->rect, results, false, SINGLE_LETTER_VALIDATE_COMP_SIZE | SINGLE_LETTER_VALIDATE_SINGLE_COMP);
                    if (st != NULL)
                    {
                        ConnectedComponentList cpl = st->getConnectedComponents();
                        // Adjust rect
                        if (cpl.size() == 2)
                        {
                            ConnectedComponent mainCC = cpl[1];
                            CGRect adjustedRect (rectLeft(r->rect) + mainCC.xmin, rectBottom(r->rect) + mainCC.ymin, mainCC.getWidth(), mainCC.getHeight());

                            if ((rectLeft(adjustedRect) != rectLeft(r->rect))
                                || (rectBottom(adjustedRect) != rectBottom(r->rect))
                                || (rectRight(adjustedRect) != rectRight(r->rect))
                                || (rectTop(adjustedRect) != rectTop(r->rect))) {
#if DEBUG                                
                                ReplacingLog("ValidateLine: rule 0211 replacing WARNING adjusting rect of [%c] from [%f,%f - %f,%f] to [%f,%f - %f,%f] in word [%s]",
                                    (unsigned short)r->ch,
                                    rectLeft(r->rect), rectBottom(r->rect), rectRight(r->rect),rectTop(r->rect),
                                    rectLeft(adjustedRect), rectBottom(adjustedRect), rectRight(adjustedRect), rectTop(adjustedRect),
                                    toUTF8(r->word->text()).c_str());
#endif                                     
                                r->word->updateLetterWithNewCharAndNewRect(r, r->ch, adjustedRect);
                            }
                            bool success = OCRUtilsOpeningsTest(r->rect, results, GET_OPENINGS_TOP, false,
                                                  0.25,         //start position
                                                  // If italic line, accept opening all the way till the right side
                                                  (line->isItalic()? 1.00:0.75),         //end position
                                                  true,         //bounds_required
                                                  0.2,			// letter_thickness 
                                                  &width,			// outWidth 
                                                  &height,		// outHeight,
                                                  &topDepth,	// outMaxDepth
                                                  NULL,			// outAverageWidth
                                                  NULL,			// outOpeningWidth
                                                  NULL,			// outMaxWidth
                                                  NULL);			// outArea
            
                            r->flags |= TESTED_OPENING_TOP;
                            
                            if ((success & (height > 0)) && (width * height > r->rect.size.width * r->rect.size.height * 0.75) && (topDepth < height * 0.20)) {
                                wchar_t newCh = 'O';
                                // Could be a 'D'
                                // No need to test returned value, will affect newCh if necessary
                                SingleLetterTestAsD(r, r->rect, results, newCh, &st);
                                if ((r->ch == 'u') || (r->ch == 0xfc)) {
                                
                                    // 'a' or 'o'?
                                    newCh = 'a';
                                    wchar_t suggestCh = '\0';
                                    
                                    bool isRealA = false;
                                    if (SingleLetterTestAsa(r, statsWithoutCurrent, results, suggestCh, lineHasRealAs, &isRealA,
                                                            // Not strict
                                                            false, &st)
                                            && (suggestCh != '\0')) {
                                        newCh = suggestCh;
                                        if (newCh == 'a')
                                            lineHasRealAs = isRealA;
                                    }
                                    
                                    // Could it be within .com?
                                    if ((r->ch != 'o') && (r->previous != NULL) && (r->previous->ch == 'c')
                                        && (r->previous->previous != NULL) && (r->previous->previous->ch == '.')
                                        && (r->next != NULL) && (r->next->ch == 'm')
                                        && ((r->next->next == NULL) || (r->next->next->ch == ' ') || (r->next->next->ch == '/'))
                                        ) {
                                        newCh = 'o';
                                        r->confidence = 0;
                                    }
                                } else {
                                    // U - could be a '0'
                                    if (((r->previous != NULL) && isDigit(r->previous->ch)) || ((r->next != NULL) && isDigit(r->next->ch))) {
                                        newCh = '0';
                                    }
                                }
                                ReplacingLog("ValidateLine: rule 0006 replacing [%c] with [%c] in word [%s]", r->ch, (unsigned short)newCh, toUTF8(r->word->text()).c_str());
                                r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);					
                                makeAnotherPass = true;
                                r = r->next;
                                delete st;
                                continue;
                            }
                        } // Single connected component
                        delete st;
					} else if ((r->ch == 'U') && (height > 0)
                        && (tallHeightTest(statsWithoutCurrent.getPtr(), height, 'U', false, 0, true) == 0)) {
                        // This is the case where we are not replacing - but perhaps we found out that the 'U' is not tall enough based on the actual main component height ...
                        char newCh = 'u';
                        CGRect newRect(rectLeft(r->rect),
                                       rectTop(r->rect) - height + 1,
                                       r->rect.size.width,
                                       height);
                        ReplacingLog("ValidateLine: rule 0007 replacing [%c] with [%c] in word [%s] because of opening test", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
						r->word->updateLetterWithNewCharAndNewRect(r, newCh, newRect);					
						makeAnotherPass = true;
						r = r->next;
						continue;
                    }
				}
			}		
            // '5' instead of '6'
            else if ((results->imageTests)
                // If FLAGS_TESTED_AS_5 is set, it means this was a '6' we fixed, do not fix back
                && (((r->ch == '5') && !(r->flags & FLAGS_TESTED_AS_5)) || (r->ch == 'S'))
                && !(r->flags2 & FLAGS2_TESTED_S_AS_DIGIT)
                // Either not italic or else not glued to next
                && (!line->isItalic() || ((r->next == NULL) || (r->next->ch == ' ') || (rectSpaceBetweenRects(r->rect, r->next->rect) > 0)))
                // Don't test if letter to the left is glued, could block the opening!
                && ((r->previous == NULL) || (r->previous->ch == ' ') || (rectSpaceBetweenRects(r->previous->rect, r->rect) > 0))) 
            {
            
//#if DEBUG
//                if ((r->ch =='5') && (r->previous != NULL) && (r->previous->ch =='0') && (r->next != NULL) && (r->next->ch =='1')) {
//                    DebugLog("Found in word [%s]!", toUTF8(r->word->text()).c_str());
//                    DebugLog("Found");
//                }
//#endif
                char newCh = SingleLetterTestSAsDigit(r, r->rect, 1, results, false);

// Putting this aside, triggered too often for 'S' etc. Then again, such 'S's should not be treated as '5' (just not like '6' either) hence the dillema ... marking as possible '6' is wrong in these case, yet right in some cases of '6' with a spurious opening on the left.
//                if ((newCh == '\0') || (newCh == '5')) {
//                    // Test if possible suspected '6', in which case set ch2
//                    SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
//                    if (st != NULL) {
//                        SegmentList slTop = st->getHorizontalSegments(0.05, 0.10);
//                        SegmentList slTop20 = st->getHorizontalSegments(0.20, 0.01);
//                        if ((slTop.size() == 1) && (slTop20.size() >= 1)) {
//                            float topWidth = slTop[0].endPos - slTop[0].startPos + 1;
//                            float topLeftMargin = slTop[0].startPos;
//                            float top20LeftMargin = slTop20[0].startPos;
//                            if ((topWidth - r->rect.size.width * 0.80 < 0.01) || (topLeftMargin - top20LeftMargin > r->rect.size.width * 0.08)) {
//                                r->ch2 = '6';
//                                r->flags |= FLAGS_SUSPECT;
//                            }
//                        }
//                    }
//                    delete st;
//                }
                
                if ((newCh != '\0') && (newCh != r->ch)) {
                    wchar_t validCharForUPC = '\0';
                    if (results->retailerParams.productNumberUPC) {
                        // If current char is part of a possible UPC number replace instead with whatever char makes it a UPC code!
                        validCharForUPC = RegexUtilsDetermineMissingUPCDigits(r);
                        if (validCharForUPC != '\0') {
                            ReplacingLog("ValidateLine: rule 0008 ABORTING replacement of [%c] with [%c] in word [%s], replacing instead with digit for UPC match [%c]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str(), validCharForUPC);
                            newCh = validCharForUPC;
                        }
                    }
                    // Check again, code above may have reset newCh to r->ch
                    if (newCh != r->ch) {
                        ReplacingLog("ValidateLine: rule 0008 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                        r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);					
                        makeAnotherPass = true;
                        r = r->next;
                        continue;
                    }
                }
            }
            // '8' instead of '6'
            // '&' instead of '8'
            // '8' instead of '3'
            // 2015-06-15 rule misfired in a case where rect was NOT glued to the previous letter yet sliced off the left piece of the '8'
            // 7 quality: 96 [640,90 w=15,h=27]
            // 8 quality: 96 [656,90 w=16,h=26]
            else if (!(r->flags2 & FLAGS2_TESTED) // && !(r->flags6 & FLAGS6_TESTED_AS_ANDSIGN)
                    && ((r->ch == '8') || (r->ch == '&')
                    || ((r->ch == 'B') && digitsNearby(r) && (statsWithoutCurrent->averageHeightDigits.count > 0)))
                    && ((r->previous == NULL) || (r->previous->ch == ' ') || (rectSpaceBetweenRects(r->previous->rect, r->rect) > 0))
                    && ((r->next == NULL) || (r->next->ch == ' ') || (rectSpaceBetweenRects(r->rect, r->next->rect) > 0))
                    )
            {
                // Before we test ANYTHING, make sure previous AND next rects are single comps (i.e. don't slice off something from the '8'. If previous / next legitimately have multiple components (e.g. 'i') never mind, skip that rule anyhow
                bool doit = true;
                if ((r->previous != NULL) && (r->previous->ch != ' ')) {
                    CGRect rect = r->previous->rect;
                    rect.size.width = rectLeft(r->rect) - rectLeft(r->previous->rect) + 1;
                    SingleLetterTests *stLeft = CreateSingleLetterTests(rect, results, false, SINGLE_LETTER_VALIDATE_SINGLE_COMP);
                    if (stLeft == NULL) {
#if DEBUG
                        wchar_t newCh = SingleLetterTest8(r, results);
                        if ((newCh != '\0') && (r->ch == '8') && (newCh != '8')) {
                            ReplacingLog("ValidateLine: ABORTING rule 0212 replacing [%c] in word [%s], suspect previous pattern", (unsigned short)r->ch, toUTF8(r->word->text()).c_str());
                        }
#endif
                        doit = false;
                    } else {
                        delete stLeft;
                    }
                }
                
                if (doit && (r->next != NULL) && (r->next->ch != ' ')) {
                    CGRect rect = r->next->rect;
                    rect.origin.x = rectRight(r->rect) + 1;
                    rect.size.width = rectRight(r->next->rect) - rect.origin.x + 1;
                    SingleLetterTests *stRight = CreateSingleLetterTests(rect, results, false, SINGLE_LETTER_VALIDATE_COMP_SIZE | SINGLE_LETTER_VALIDATE_SINGLE_COMP);
                    if (stRight == NULL) {
#if DEBUG
                        wchar_t newCh = SingleLetterTest8(r, results);
                        if ((newCh != '\0') && (r->ch == '8') && (newCh != '8')) {
                            ReplacingLog("ValidateLine: ABORTING rule 0212 replacing [%c] in word [%s], suspect next pattern", (unsigned short)r->ch, toUTF8(r->word->text()).c_str());
                        }
#endif
                        doit = false;
                    } else {
                        delete stRight;
                    }
                }
                
                if (doit) {
                    wchar_t newCh = SingleLetterTest8(r, results);
                    
                    if ((newCh != '\0') && (newCh != r->ch)) {
                        ReplacingLog("ValidateLine: rule 0212 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)newCh, toUTF8(r->word->text()).c_str());
                        r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);					
                        makeAnotherPass = true;
                        r = r->next;
                        continue;
                    }
                }
            }
            
            
#if DEBUG
//            if ((r->ch=='0') && (r->previous!= NULL) && (r->previous->ch=='1') && (r->previous->previous != NULL) && (r->previous->previous->ch=='.')) {
//            if (((r->ch=='0') || (r->ch=='O') || (r->ch=='Q')) && (r->next != NULL) && (r->next->ch=='.') && (r->next->next != NULL) && (r->next->next->ch=='9')) {
            if ((r->ch=='6') && (r->previous!= NULL) && (r->previous->ch=='5') && (r->previous->previous != NULL) && (r->previous->previous->ch=='.')) {
                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results); if (st != NULL) delete st;
                DebugLog("Found in [%s]", toUTF8(r->word->text()).c_str());
                DebugLog("");
            }
#endif

            //  -----------
            //0|           |
            //1|      1    |
            //2|   11111   |
            //3|  1111111  |
            //4|  11   111 |
            //5|  11   111 |
            //6|  11   111 |
            //7|  11   11  |
            //8|  1111111  |
            //9|  11   11  |
            //a|  11   11  |
            //b|  11   11  |
            //c|  11   11  |
            //d| 111   11  |
            //e|  11   11  |
            //f|  11  111  |
            //#|  1111111  |
            //#|   11111   |
            //#|   11      |
            //#|           |
            //  -----------
            // '0' instead of '8'
            
            if (((r->ch == '0') || (r->ch == 'O') || (r->ch == 'Q') || (r->ch == 'D')) && !(results->retailerParams.has0WithDiagonal) && (results->imageTests) && !(r->flags3 & FLAGS3_TESTED_AS_8)) {
                r->flags3 |= FLAGS3_TESTED_AS_8;
                bool doit = false;
                wchar_t newCh = '\0';
                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                if (st != NULL) {
                    ConnectedComponentList inverseCpl = st->getInverseConnectedComponents();
                    if (inverseCpl.size() >= 3) {
                        ConnectedComponent topHole, bottomHole;
                        bool foundTopHole = false, foundBottomHole = false;
                        for (int i=1; i<inverseCpl.size(); i++) {
                            ConnectedComponent cc = inverseCpl[i];
                            float midPoint = (cc.ymin + cc.ymax) / 2;
                            if ((midPoint < r->rect.size.height * 0.35) && !foundTopHole) {
                                foundTopHole = true;
                                topHole = cc;
                                continue;
                            }
                            if ((midPoint > r->rect.size.height * 0.50) && !foundBottomHole) {
                                foundBottomHole = true;
                                bottomHole = cc;
                                continue;
                            }
                        }
                        if (foundTopHole && foundBottomHole) {
                            if ((topHole.getHeight() > r->rect.size.height * 0.15)
                                && (bottomHole.getHeight() > r->rect.size.height * 0.15)
                                && (topHole.getWidth() > r->rect.size.width * 0.15)
                                && (bottomHole.getWidth() > r->rect.size.width * 0.15)
                                && (topHole.ymax <= bottomHole.ymin)) {
                                doit = true;
                                if (r->ch == 'D')
                                    newCh = 'B';
                                else
                                    newCh = '8';
                            }
                        }
                    } else {
                        //  ----------
                        //0|          |
                        //1|    11    |
                        //2|   111111 |
                        //3|  111 111 |
                        //4| 111   11 |
                        //5|  11   11 |
                        //6|  11   11 |
                        //7|  11   11 |
                        //8|  111 111 |
                        //9|  11  111 |
                        //a|  11   11 |
                        //b|  11   11 |
                        //c|  11   11 |
                        //d|  11   11 |
                        //e|  11   11 |
                        //f| 111   11 |
                        //#|  1111111 |
                        //#|   11111  |
                        //#|    1     |
                        //#|          |
                        //  ----------
                        // Give this one a chance too, require gap in the middle to be no more than 1 out of 8 (12.5%)
                        SegmentList sl25 = st->getHorizontalSegments(0.25, 0.10);
                        SegmentList slMiddle = st->getHorizontalSegments(0.50, 0.20);
                        SegmentList sl75 = st->getHorizontalSegments(0.75, 0.10);
                        if ((sl25.size() == 2) && (slMiddle.size() == 2) && (sl75.size() == 2)) {
                            float gap25 = largestGap(sl25), gapMiddle = largestGap(slMiddle), gap75 = largestGap(sl75);
                            if ((gapMiddle <= r->rect.size.width * 0.13)
                                 && (gap25 > gapMiddle) && (gap25 > r->rect.size.width * 0.20)
                                 && (gap75 > gapMiddle) && (gap75 > r->rect.size.width * 0.20)) {
                                 doit = true;
                                if (r->ch == 'D')
                                    newCh = 'B';
                                else
                                    newCh = '8';
                            }
                        }
                    }
                    delete st;
                }
                if ((newCh != '\0') && (newCh != r->ch) && doit) {
                    ReplacingLog("ValidateLine: rule 0685 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);					
                    makeAnotherPass = true;
                }
            }
            
#if DEBUG
//            if ((r->ch=='0') && (r->previous!= NULL) && (r->previous->ch=='1') && (r->previous->previous != NULL) && (r->previous->previous->ch=='.')) {
//            if (((r->ch=='0') || (r->ch=='O') || (r->ch=='Q')) && (r->next != NULL) && (r->next->ch=='.') && (r->next->next != NULL) && (r->next->next->ch=='9')) {
            if ((r->ch=='8') && (r->next != NULL) && (r->next->ch=='5') && (r->next->next != NULL) && (r->next->next->ch=='4')) {
                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results); if (st != NULL) delete st;
                DebugLog("Found in [%s]", toUTF8(r->word->text()).c_str());
                DebugLog("");
            }
#endif
            
            //  --------------
            //0|              |
            //1|   1111111    |
            //2|   11   111   |
            //3| 111     111  |
            //4| 111       1  |
            //5| 11        11 |
            //6| 11       111 |
            //7| 11      1111 |
            //8| 11   111  1  |
            //9| 11  1111  11 |
            //a| 111 1     11 |
            //b| 1111      11 |
            //c| 11        11 |
            //d| 11        11 |
            //e| 111      11  |
            //f|  111    111  |
            //#|   11111111   |
            //#|    111111    |
            //#|              |
            //  --------------
            // '8' instead of '0'
            if ((r->ch == '8') && (results->retailerParams.has0WithDiagonal) && (results->imageTests) && !(r->flags7 & FLAGS7_TESTED_AS_0)) {
                r->flags7 |= FLAGS7_TESTED_AS_0;
                bool doit = false;
                wchar_t newCh = '\0';
                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                if (st != NULL) {
                    ConnectedComponentList inverseCpl = st->getInverseConnectedComponents();
                    if (inverseCpl.size() >= 3) {
                        ConnectedComponent topHole, bottomHole;
                        bool foundTopHole = false, foundBottomHole = false;
                        for (int i=1; i<inverseCpl.size(); i++) {
                            ConnectedComponent cc = inverseCpl[i];
                            float midPoint = (cc.ymin + cc.ymax) / 2;
                            if ((midPoint < r->rect.size.height * 0.35) && !foundTopHole) {
                                foundTopHole = true;
                                topHole = cc;
                                continue;
                            }
                            if ((midPoint > r->rect.size.height * 0.50) && !foundBottomHole) {
                                foundBottomHole = true;
                                bottomHole = cc;
                                continue;
                            }
                        }
                        if (foundTopHole && foundBottomHole
                            // If the holes overlap => it's a 0!
                            && (topHole.ymax >= bottomHole.ymin)) {
                            doit = true;
                            newCh = '0';
                            
                        }
                    } else if (inverseCpl.size() == 2) {
                        //  ---------------
                        //0|               |
                        //1|    1111111    |
                        //2|    11   111   |
                        //3|  111     111  |
                        //4|  111      11  |
                        //5|  11        1  |
                        //6|  11       111 |
                        //7| 111      1111 |
                        //8|  1   111  111 |
                        //9|  1   111   11 |
                        //a|  11        11 |
                        //b|  111       11 |
                        //c|  11        11 |
                        //d|  11       11  |
                        //e|  111      11  |
                        //f|   11     111  |
                        //#|    1111111    |
                        //#|    1111111    |
                        //#|               |
                        //  ---------------
                        // Family Dollar, see https://drive.google.com/open?id=0B4jSQhcYsC9VU2FNOHQ1cnF6a28
                        ConnectedComponent ccHole = inverseCpl[1];
                        if ((ccHole.getHeight() > r->rect.size.height * 0.65)
                            && (ccHole.getWidth() > r->rect.size.width * 0.40)) {
                            doit = true; newCh = '0';
                        }
                    }
                    delete st;
                }
                if ((newCh != '\0') && (newCh != r->ch) && doit) {
                    ReplacingLog("ValidateLine: rule 0689 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);					
                    makeAnotherPass = true;
                }
            }
            
            //  ----------
            //0|          |
            //1|  11111   |
            //2|  111111  |
            //3| 111  111 |
            //4| 11   111 |
            //5| 11   111 |
            //6| 111  11  |
            //7| 1111111  |
            //8| 111  11  |
            //9| 111  111 |
            //a| 111  111 |
            //b| 11   111 |
            //c| 11   111 |
            //d| 11   111 |
            //e| 11   111 |
            //f| 11111111 |
            //#|  111111  |
            //#|  11111   |
            //#|          |
            //  ----------
            // '6' instead of '8', see https://drive.google.com/open?id=0B4jSQhcYsC9VWXo5YWVReGhRU28 (blur radius 1)
            if ((r->ch == '6') && !(results->retailerParams.has0WithDiagonal) && (results->imageTests) && !(r->flags3 & FLAGS3_TESTED_AS_8)) {
                r->flags3 |= FLAGS3_TESTED_AS_8;
                bool doit = false;
                wchar_t newCh = '\0';
                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                if (st != NULL) {
                    ConnectedComponentList inverseCpl = st->getInverseConnectedComponents();
                    if (inverseCpl.size() >= 3) {
                        ConnectedComponent topHole, bottomHole;
                        bool foundTopHole = false, foundBottomHole = false;
                        for (int i=1; i<inverseCpl.size(); i++) {
                            ConnectedComponent cc = inverseCpl[i];
                            float midPoint = (cc.ymin + cc.ymax) / 2;
                            if ((midPoint < r->rect.size.height * 0.35) && !foundTopHole) {
                                foundTopHole = true;
                                topHole = cc;
                                continue;
                            }
                            if ((midPoint > r->rect.size.height * 0.50) && !foundBottomHole) {
                                foundBottomHole = true;
                                bottomHole = cc;
                                if (foundTopHole) {
                                    // If top hole is larger than bottom hole, can't be a 6!
                                    doit = true;
                                    newCh = '8';
                                }
                                continue;
                            }
                        }
                        if (!doit && foundTopHole && foundBottomHole) {
                            if ((topHole.getHeight() > r->rect.size.height * 0.15)
                                && (bottomHole.getHeight() > r->rect.size.height * 0.15)
                                && (topHole.getWidth() > r->rect.size.width * 0.15)
                                && (bottomHole.getWidth() > r->rect.size.width * 0.15)) {
                                // Now we also need to test that top part is as wide as bottom part (which can't happen for '6')
                                SegmentList sl25 = st->getHorizontalSegments(0.25, 0.10);
                                SegmentList sl75 = st->getHorizontalSegments(0.75, 0.10);
                                float width25 = totalWidth(sl25), width75 = totalWidth(sl75);
                                if (width25 >= width75) {
                                    doit = true;
                                    newCh = '8';
                                }
                            }
                        }
                    }
                    delete st;
                }
                if ((newCh != '\0') && (newCh != r->ch) && doit) {
                    ReplacingLog("ValidateLine: rule 0686 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);					
                    makeAnotherPass = true;
                }
            } // 6 instead of 8
            
            //  ---------------
            //0|               |
            //1|  1111111      |
            //2|  11111111     |
            //3| 111111  111   |
            //4|  11     111   |
            //5|  11      11   |
            //6| 111      11   |
            //7|  11       1   |
            //8|  11      11   |
            //9|  11     111   |
            //a| 111    1111   |
            //b|  1111111111   |
            //c|  1111111111   |
            //d|  11      11   |
            //e|  11      111  |
            //f| 111       11  |
            //#|  11       11  |
            //#|  11       111 |
            //#| 111       111 |
            //#| 111       111 |
            //#| 111       11  |
            //#| 111       11  |
            //#| 11111  11111  |
            //#| 11111111111   |
            //#|  1111  1111   |
            //#|  11           |
            //#|               |
            //  ---------------
            // '8' instead of 'B', see https://drive.google.com/open?id=0B4jSQhcYsC9VdGJTeEd5SHg4Rjg in 8LUBERRY
            if ((r->ch == '8') && (results->imageTests) && !(r->flags6 & FLAGS6_TESTED_AS_B)) {
                r->flags6 |= FLAGS6_TESTED_AS_B;
                wchar_t newCh = '\0';
                // Check if one of the holes has a straight edge on right side of left edge + concave right edge
                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                if (st != NULL) {
                    ConnectedComponentList invertCpl = st->getInverseConnectedComponents();
                    if (invertCpl.size() == 3) {
                        for (int i=1; i<invertCpl.size(); i++) {
                            ConnectedComponent cc = invertCpl[i];
                            SegmentList slTop20 = st->getHorizontalSegmentsPixels(cc.ymin + cc.getHeight() * 0.15, cc.ymin + cc.getHeight() * 0.15);
                            SegmentList slBottom20 = st->getHorizontalSegmentsPixels(cc.ymax - cc.getHeight() * 0.15, cc.ymax - cc.getHeight() * 0.15);
                            SegmentList slMiddle = st->getHorizontalSegmentsPixels((cc.ymin + cc.ymax)/2, (cc.ymin + cc.ymax)/2);
                            if ((slTop20.size() == 2) && (slMiddle.size() == 2) && (slBottom20.size() == 2)) {
                                float gapTop20 = largestGap(slTop20);
                                float gapMiddle = largestGap(slMiddle);
                                float gapBottom20 = largestGap(slBottom20);
                                if ((slTop20[0].endPos <= slMiddle[0].endPos)
                                    && (slBottom20[0].endPos <= slMiddle[0].endPos)
                                    && (((gapTop20 < gapMiddle) && (gapBottom20 <= gapMiddle))
                                        || ((gapTop20 <= gapMiddle) && (gapBottom20 < gapMiddle)))) {
                                        // Also make sure very top or bottom of entire pattern is not more indented right than the most indented part of the hole
                                        float maxHoleIndent = MAX(slTop20[0].startPos, slBottom20[0].startPos);
                                        if (slMiddle[0].startPos > maxHoleIndent)
                                            maxHoleIndent = slMiddle[0].startPos;
                                        float topOrBottomIntent = -1;
                                        if ((cc.ymin + cc.ymax)/2 < r->rect.size.height * 0.50) {
                                            SegmentList sl = st->getHorizontalSegments(0.05, 0.10);
                                            if (sl.size() >= 1)
                                                topOrBottomIntent = sl[0].startPos;
                                        } else {
                                            SegmentList sl = st->getHorizontalSegments(0.95, 0.10);
                                            if (sl.size() >= 1)
                                                topOrBottomIntent = sl[0].startPos;
                                        }
                                        if ((topOrBottomIntent >= 0)
                                            && (topOrBottomIntent <= maxHoleIndent)) {
                                            newCh = 'B';
                                            break;
                                        }
                                    }
                                } // got expected horiz segments
                            } // iterate over holes
                        } // 2 holes
                    delete st;
                } // st != NULL
                if ((newCh != '\0') && (newCh != r->ch)) {
                    ReplacingLog("ValidateLine: rule 0683 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);					
                    makeAnotherPass = true;
                }
            }
            
            OCRVerboseLog("OCRValidate: about to check rule 0213");
            // 'e' tall like digits and is actually a '6'
            // 'e' instead of '6', default digit replacement would turn to '8'
            if (results->imageTests
                     && !(r->flags2 & FLAGS2_TESTED_e_AS_6)
                     && (r->ch == 'e') && (statsWithoutCurrent->averageHeightDigits.count >= 4) && (r->rect.size.height > statsWithoutCurrent->averageHeightDigits.average * (1 - OCR_ACCEPTABLE_ERROR))
                        // If there are lowercase letters, also demand that current 'e' be taller than normal lowerase (we test that in case digits are special in that they are not much taller than lowercase)
                     && ( ((statsWithoutCurrent->averageHeightNormalLowercase.count == 0) 
                           || (r->rect.size.height > statsWithoutCurrent->averageHeightNormalLowercase.average * (1 + OCR_ACCEPTABLE_ERROR)))
                           // If not, since we already tested that '3' is tall like digits, still do the test if next to digits
                          || ((r->previous != NULL) && isDigit(r->previous->ch))
                          || ((r->next != NULL) && isDigit(r->next->ch))
                        )
                )
            {
                r->flags2 |= FLAGS2_TESTED_e_AS_6;
                
                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                if (st != NULL) {
                    ConnectedComponentList cpl = st->getConnectedComponents();
                        // Only one component (or next one less than  1/20th)
                    if (((cpl.size() == 2) || ((cpl.size() > 2) && (cpl[2].area < cpl[1].area * 0.05)))
                        // Rect essentially matches the main component
                        && (cpl[1].getWidth() * cpl[1].getHeight() > r->rect.size.width * r->rect.size.height * 0.90))
                    {
                        ConnectedComponent mainComp = cpl[1];
                        ConnectedComponentList inverts = st->getInverseConnectedComponents();
                        // One hole, below mid-point
                        if (((inverts.size() == 2) 
                            || ((inverts.size() == 3) && (inverts[1].xmin == inverts[2].xmin) && (inverts[1].xmax == inverts[2].xmax) && (inverts[1].ymin == inverts[2].ymin) && (inverts[1].ymax == inverts[2].ymax)))
                            && ((inverts[1].ymin + inverts[1].ymax) / 2 > (mainComp.ymin + mainComp.ymax) / 2)) 
                        {
                            // Now also expect to find an opening on the top half, on the right
                            OpeningsTestResults resRight;
                            bool success = st->getOpenings(resRight, SingleLetterTests::Right, 
                                0,      // Start of range to search (top/left)
                                (inverts[1].ymin - 1) / r->rect.size.height,    // End of range to search (bottom/right)
                                SingleLetterTests::Bound,   // Require start (top/left) bound
                                SingleLetterTests::Bound  // Require end (bottom/right) bound
                                );
                            if (success && (resRight.maxDepth > mainComp.getWidth() * 0.15)) {
                                char newCh = '6';
                    
                                ReplacingLog("ValidateLine: rule 0213 replacing [%c] with [%c] in word [%s] ('e' tall like digits + tested as '6')", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                                r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);					
                                makeAnotherPass = true;
                                r = r->next;
                                continue;                                
                            }
                        } // one hole, below
                    }   // one main component
                } // st != NULL
            }
            // '9' instead of '0'
            else if ((results->imageTests)
                 && !(r->flags3 & FLAGS3_TESTED_OPENING_BOTTOM_LEFT)
                 && (r->ch == '9')
                 && !line->isItalic()
                 // Don't test if letter to the left is glued, could block the opening!
                 && ((r->previous == NULL) || (r->previous->ch == ' ') || (rectSpaceBetweenRects(r->previous->rect, r->rect) > 0))) 
            {
            
//#if DEBUG
//                if ((r->ch == '9') && (r->previous != NULL) && (r->previous->ch == '1') && (r->previous->previous != NULL) && (r->previous->previous->ch=='.')) {
//                    DebugLog("Found in word [%s]!", toUTF8(r->word->text()).c_str());
//                    DebugLog("");
//                }
//#endif
                r->flags3 |= FLAGS3_TESTED_OPENING_BOTTOM_LEFT;
                 SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                 if (st != NULL) {
                    // First test: make sure we don't have a broken set of components!
                    ConnectedComponentList cpl = st->getConnectedComponents();
                    if (((cpl.size() == 2) || ((cpl.size() >= 3) && (cpl[2].area < cpl[1].area * 0.04)))
                        // Make sure main CC spans the entire expected height
                        && (cpl[1].getHeight() >= r->rect.size.height * 0.85))
                    {
                        OpeningsTestResults bottomLeftOpening;
                        bool success = st->getOpenings(bottomLeftOpening, SingleLetterTests::Left, 
                            0.50,      // Start of range to search (top/left)
                            1.00,    // End of range to search (bottom/right)
                            SingleLetterTests::Bound,   // Require start (top/left) bound
                            SingleLetterTests::Bound  // Require end (bottom/right) bound
                            );
                        if (!success || (bottomLeftOpening.maxDepth < r->rect.size.width * ((r->rect.size.height <= 18)? 0.05:0.10))) {
                            // Further verify that the opening is also less than 10% of the main component
                            ConnectedComponentList cpl = st->getConnectedComponents();
                            if (cpl.size() > 1) {
                                if (!success || (bottomLeftOpening.maxDepth < cpl[1].getHeight() * ((r->rect.size.height <= 18)? 0.05:0.10))) {
                                    // See Marco Amaral, real 9, opening depth was 3 vs width = 32 (i.e. 3 is less than 10%)
                                    bool doit = true;
                                    ConnectedComponentList invertedCpl = st->getInverseConnectedComponents();
                                    if (success && (bottomLeftOpening.maxDepth > r->rect.size.width * 0.05)) {
                                        if (invertedCpl.size() >= 3) {
                                            ConnectedComponent topHole = invertedCpl[1];
                                            ConnectedComponent bottomHole = invertedCpl[2];
                                            if ((topHole.ymax < bottomHole.ymin)
                                                && (OverlappingX(topHole, bottomHole))) {
                                                doit = false;
                                            }
                                        }
                                        // Test height of midpoint of hole
                                        else if (invertedCpl.size() > 1) {
                                            ConnectedComponent hole = invertedCpl[1];
                                            if ((hole.ymin + hole.ymax)/2 < r->rect.size.height * 0.40) {
                                                // Abort! We have a high hole and a smallish opening (but still some opening)
                                                doit = false;
                                            }                                
                                        }
                                    }
                                    // Test that we don't have a pattern with too many black pixels, but where the main invert cpl is entirely above the center, and there is *some* smaller inverted comp below center => likely to be a valid '9'
                                    if (doit && (invertedCpl.size() >= 3)) {
                                        if (invertedCpl[1].ymax < cpl[1].getHeight()*0.70) {
                                            for (int j=2; j<invertedCpl.size(); j++) {
                                                ConnectedComponent cc = invertedCpl[j];
                                                // Entirely below mid-height?
                                                if (cc.ymin > cpl[1].getHeight()*0.70) {
                                                    doit = false;
                                                    ReplacingLog("ValidateLine: NOT replacing [%c] with [0] in word [%s], found larger top hole and smaller bottom hole", (unsigned short)r->ch, toUTF8(r->word->text()).c_str());
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    // One more test: perhaps it's a modern 9 with a high hole and a straight tail?
                                    if (doit) {
                                        OpeningsTestResults bottomLeftBoundedTopOpening;
                                        bool success = st->getOpenings(bottomLeftBoundedTopOpening, SingleLetterTests::Left, 
                                            0.20,    // Start of range to search (top/left)
                                            1.00,    // End of range to search (bottom/right)
                                            SingleLetterTests::Bound,   // Require start (top/left) bound
                                            SingleLetterTests::Unbound  // Require end (bottom/right) bound
                                            );
                                        if (success && (bottomLeftBoundedTopOpening.maxDepth > r->rect.size.width * 0.50)) {
                                            doit = false;
                                        }
                                    }
                                    if (doit) {
                                        // We failed to find an opening to the left, must be a '0'!
                                        char newCh = '0';
                                        ReplacingLog("ValidateLine: rule 0214 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                                        r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);					
                                        makeAnotherPass = true;
                                        r = r->next;
                                    }
                                    delete st;
                                    continue;
                                }
                            }
                        }
                    } // single connected component
                    delete st;
                } // st != NULL
            }
            
//#if DEBUG
//            if ((r->ch == '0') && (r->previous != NULL) && (r->previous->ch == '.') && (r->previous->previous != NULL) && (r->previous->previous->ch=='2') && (r->next != NULL) && (r->next->ch == '0')) {
//                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results); if (st != NULL) delete st;
//                DebugLog("Found in word [%s]!", toUTF8(r->word->text()).c_str());
//                DebugLog("");
//            }
//#endif

            OCRVerboseLog("OCRValidate: about to check rule 0215");
            // 'Q' instead of '9'
            // '8' instead of '9'
            if (((r->ch == '0') || (r->ch == '8') || ((statsWithoutCurrent->averageHeightDigits.count >= 2) && ((r->ch == 'O') || (r->ch == 'Q')))) && !(r->flags3 & FLAGS3_TESTED_OPENING_BOTTOM_LEFT) && (results->imageTests)) {
                char newCh = '\0';
                r->flags3 |= FLAGS3_TESTED_OPENING_BOTTOM_LEFT;
                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results, false, SINGLE_LETTER_VALIDATE_COMP_SIZE | SINGLE_LETTER_VALIDATE_SINGLE_COMP);
                if (st != NULL) {
                    LimitedOpeningsTestResults bottomLeftOpening;
                    bool success = st->getOpeningsLimited(bottomLeftOpening, SingleLetterTests::Left, 
                        0.50,   // Start of range to search (top/left)
                        1.00,   // End of range to search (bottom/right)
                        0.50,   // Test depth
                        SingleLetterTests::Bound,   // Require start (top/left) bound
                        SingleLetterTests::Bound,  // Require end (bottom/right) bound
                        false,
                        true    // Require bounds to be in the specified range
                        );
                    
                    r->flags3 |= FLAGS3_TESTED_OPENING_BOTTOM_LEFT;
                        
                    if (success && (bottomLeftOpening.maxDepth > r->rect.size.width * 0.40)) {
                        // One more test: check that we have 3 intersections along vertical axis in the middle
                        SegmentList sl = st->getVerticalSegments(0.50, 0.05);
                        if (sl.size() >= 3) {
                            bool doit = true;
                            // And one final test when letter is '8' (to be extra safe)
                            if (r->ch == '8') {
                                ConnectedComponentList invertCpl = st->getInverseConnectedComponents();
                                if (invertCpl.size() >= 3)
                                    doit = false;
                                // And another: test that we don't have a significant opening on the right (unlikely to be a '9'). Do that only if the opening on the left is not very large
                                // Sometimes opening IS deep on left side because of image processing disconnecting upper/lower loops from the center - so test even if left opening is deep - 42% in this case (just no deeper than 60% I guess)
                                if (doit && (bottomLeftOpening.minWidth < r->rect.size.height * 0.60)) {
                                    OpeningsTestResults rightOpening;
                                    bool success = st->getOpenings(rightOpening, SingleLetterTests::Right, 
                                        0.30,   // Start of range to search (top/left)
                                        0.80,   // End of range to search (bottom/right)
                                        SingleLetterTests::Bound,   // Require start (top/left) bound
                                        SingleLetterTests::Bound  // Require end (bottom/right) bound
                                    );
                                    // 8 with misleading opening on the left had a 2 pixels deep opening on right vs width 16 (12.5%)
                                    if (success) {
                                        if (rightOpening.maxDepth > r->rect.size.width * 0.124)
                                            doit = false;
                                        else {
                                            // OK, so opening on right was not very deep - stil suspicious, check horiz segments just above, in a real 9 we expect only one segment
                                            if (bottomLeftOpening.minWidthStartCoord >= 2) {
                                                SegmentList sl = st->getHorizontalSegments((bottomLeftOpening.minWidthStartCoord - 1)/r->rect.size.height-0.03, 0.06);
                                                if (sl.size() > 1) {
                                                    // Abort!
                                                    doit = false;
                                                }
                                            }
                                        }
                                    }
                                }
                            } // ch is 8
                            else if (r->ch == '0') {
                                // We'll go ahead with the replacement but may mark it as suspect + set alt char
                                bool suspect = false;
                                ConnectedComponentList invertCpl = st->getInverseConnectedComponents();
                                if (invertCpl.size() == 0) {
                                    suspect = true; // Missing hole!
                                } else if (invertCpl.size() >= 1) {
                                    // Check if largest hole is in top part
                                    float centerY = (invertCpl[0].ymin + invertCpl[0].ymax)/2 + rectBottom(r->rect);
                                    if ((centerY > rectBottom(r->rect) + r->rect.size.height * 0.40)) {
                                        suspect = true;
                                    } else if (invertCpl[0].ymax > r->rect.size.height * 0.80) {
                                        suspect = true;
                                    }
                                    if (suspect) {
                                        r->flags |= FLAGS_SUSPECT;
                                        r->ch2 = r->ch;
                                    }
                                }
                            } // r->ch is 0
                            if (doit) {
                                newCh = '9';
                            }
                        } /// 3 intersection vertical around middle
                    }
                    
                    //  -------------
                    //0|             |
                    //1|      11     |
                    //2|    11111    |
                    //3|   11111111  |
                    //4|   111111111 |
                    //5|  1111   111 |
                    //6|  111    111 |
                    //7|  111    111 |
                    //8|  111    111 |
                    //9|  1111   111 |
                    //a|   111  1111 |
                    //b|  1111111111 |
                    //c|  1111111111 |
                    //d|  1111   111 |
                    //e|  111    111 |
                    //f|  111    111 |
                    //#|  111    111 |
                    //#|  111    111 |
                    //#| 1111    111 |
                    //#|  111    111 |
                    //#|  1111  1111 |
                    //#|  1111111111 |
                    //#|  111111111  |
                    //#|    111111   |
                    //#|    11  11   |
                    //#|             |
                    //  -------------
                    if (newCh == '\0') {
                        // Now also test for a possible '8'
                        // It's a '8' is we have small indentations on both sides and two inverted components
                        ConnectedComponentList invertedCpl = st->getInverseConnectedComponents();
                        if (invertedCpl.size() == 3) {
                            if ((r->ch != '8') && ((r->ch != '0') || !results->retailerParams.has0WithDiagonal)) {
                                // Possible '8', now check indentations
                                OpeningsTestResults left;
                                bool hasOneIndent = false;
                                bool success = st->getOpenings(left, SingleLetterTests::Left, 
                                    0.20,      // Start of range to search (top/left)
                                    0.80,    // End of range to search (bottom/right)
                                    SingleLetterTests::Bound,   // Require start (top/left) bound
                                    SingleLetterTests::Bound  // Require end (bottom/right) bound
                                );
                                if (success && (left.maxDepth > 0)) {
                                    hasOneIndent = true;
                                }
                                OpeningsTestResults right;
                                success = st->getOpenings(right, SingleLetterTests::Right,
                                    0.20,      // Start of range to search (top/left)
                                    0.80,    // End of range to search (bottom/right)
                                    SingleLetterTests::Bound,   // Require start (top/left) bound
                                    SingleLetterTests::Bound  // Require end (bottom/right) bound
                                );
                                if (success && (right.maxDepth > 0)) {
                                    hasOneIndent = true;
                                    // One last check! Could be a zero where a diagonal exists - check that we don't have 3 horiz segments along the middle
                                    SegmentList sl = st->getHorizontalSegments(0.50, 0.01);
                                    if (sl.size() < 3) {
                                        SegmentList sl = st->getHorizontalSegments(0.45, 0.01);
                                        if (sl.size() < 3) {
                                            SegmentList sl = st->getHorizontalSegments(0.55, 0.01);
                                            if (sl.size() < 3) {
                                                //  -------------
                                                //0|             |
                                                //1|    1111111  |
                                                //2|  111111111  |
                                                //3|  1111  111  |
                                                //4|  11     111 |
                                                //5| 111     1111|
                                                //6| 111      111|
                                                //7| 111      11 |
                                                //8| 111      11 |
                                                //9| 111     11  |
                                                //a| 111     11  |
                                                //b| 111     111 |
                                                //c| 111     111 |
                                                //d| 111     111 |
                                                //e| 111     111 |
                                                //f| 111      11 |
                                                //#| 111      111|
                                                //#| 111     111 |
                                                //#| 1111    111 |
                                                //#|  1111  1111 |
                                                //#|  111111111  |
                                                //#|   11111111  |
                                                //#|    11111    |
                                                //#|             |
                                                //  -------------
                                                // So far, tests were ready to accept the above as a '8', need to be more strict: test that we don't have a wide gap in the middle!
                                                SegmentList slMiddle = st->getHorizontalSegments(0.50, 0.25);
                                                if (slMiddle.size() == 1) {
                                                    newCh = '8';
                                                } else if (slMiddle.size() == 2) {
                                                    float gap = slMiddle[1].startPos - slMiddle[0].endPos - 1;
                                                    if (gap < r->rect.size.width * 0.20)
                                                        newCh = '8';
                                                }
                                            }
                                        }
                                    }
                                }
                                /* Last chance: if no intendations found left & right, accept if we find two well defined inverted comps. In the pattern above:
                                    - top hole had height = 6 versus h=24
                                    - bottom hole had height = 8 versus h=24
                                    - both holes had width = 4 vs w=11
                                    - separator between them had height = 2
                                 */
                                 if ((newCh == '\0') && hasOneIndent) {
                                    if ((invertedCpl[1].getHeight() >= r->rect.size.height * 0.25) && (invertedCpl[2].getHeight() >= r->rect.size.height * 0.25) && (invertedCpl[1].getWidth() >= r->rect.size.width * 0.25) && (invertedCpl[2].getWidth() >= r->rect.size.width * 0.25)) {
                                        ConnectedComponent ccTop, ccBottom;
                                        if (invertedCpl[1].ymax < invertedCpl[2].ymin) {
                                            ccTop = invertedCpl[1];
                                            ccBottom = invertedCpl[2];
                                        } else {
                                            ccTop = invertedCpl[2];
                                            ccBottom = invertedCpl[1];
                                        }
                                        if (ccBottom.ymin - ccTop.ymax >= r->rect.size.height * 0.083) {
                                            newCh = '8';
                                        }
                                    }
                                 }
                                
                            } // not '8'
                        } else if ((r->ch != '6') && (r->ch != '8')) {
                            // Possible '6'. Not testing '8' because rule 0212 already does that
                            OpeningsTestResults topRight;
                            bool success = st->getOpenings(topRight, SingleLetterTests::Right, 
                                0.00,      // Start of range to search (top/left)
                                0.50,    // End of range to search (bottom/right)
                                SingleLetterTests::Bound,   // Require start (top/left) bound
                                SingleLetterTests::Bound  // Require end (bottom/right) bound
                            );
                            if (success && (topRight.maxDepth > r->rect.size.width * 0.50)) {
                                ConnectedComponentList cpl = st->getConnectedComponents();
                                if (cpl.size() > 1) {
                                    // A '6' would have at most a small gap in the center (unlike a zero), test it
                                    SegmentList slMiddle = st->getHorizontalSegments(0.50, 0.30);
                                    bool doit = false;
                                    if (slMiddle.size() == 1) {
                                        if (slMiddle[0].endPos - slMiddle[0].startPos + 1 >= cpl[1].getWidth() * 0.70)
                                            doit = true;
                                     } else if (slMiddle.size() == 2) {
                                        if ((slMiddle[1].startPos - slMiddle[0].endPos - 1) < cpl[1].getWidth() * 0.15)
                                            doit = true;
                                     }
                                     if (doit) {
                                        // Could still be a bogus small opening created by imperfect image processing - check if there is a large dent middle/left (as in an '8'
                                        // e.g. receipt where left opening was 2 pixels out of width 13 => a little over 15%
                                        OpeningsTestResults middleLeftOpening;
                                        bool success = st->getOpenings(middleLeftOpening,
                                                SingleLetterTests::Left,
                                                0.25,      // Start of range to search (top/left)
                                                0.75,      // End of range to search (bottom/right)
                                                SingleLetterTests::Bound,   // Require start (top/left) bound
                                                SingleLetterTests::Bound  // Require end (bottom/right) bound
                                                );
                                        if (!success || (middleLeftOpening.maxDepth < cpl[1].getWidth() * 0.12)) {
                                            newCh = '6';
                                        } else {
                                            ReplacingLog("Validate: aborting rule 0215 [%c -> 6] replacing because of depth %.0f opening on middle left (out of width %.0f) in word [%s]", (unsigned short)r->ch, middleLeftOpening.maxDepth, cpl[1].getWidth(), toUTF8(r->word->text()).c_str());
                                        }
                                    } // doit
                                } // cpl.size() > 1
                            }
                        }
                    }
                    
                    if ((newCh != '\0') && (newCh != r->ch)) {
                        ReplacingLog("ValidateLine: rule 0215 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                        r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);					
                        makeAnotherPass = true;
                    }
                    
                    delete st;
                }
            }
            // 'G' instead of 'C' or 'E'
            else if ((r->ch == 'G') && !(r->flags3 & FLAGS3_TESTED_AS_G) && (results->imageTests)) {
                r->flags3 |= FLAGS3_TESTED_AS_G;
                SingleLetterTests *st1 = CreateSingleLetterTests(r->rect, results, false, SINGLE_LETTER_VALIDATE_COMP_SIZE|SINGLE_LETTER_VALIDATE_SINGLE_COMP);
                if (st1 != NULL) 
                {
                    // G instead of E
                    SegmentList sl = st1->getVerticalSegments(0.50, 0.01);
                    if ((sl.size() == 3) 
                        && (sl[1].startPos > r->rect.size.height * 0.20) 
                        && (sl[1].endPos < r->rect.size.height * 0.70))
                    {
                        LimitedOpeningsTestResults resTopRight;
                        bool successTopRight = st1->getOpeningsLimited(resTopRight, SingleLetterTests::Right, 
                            0.10,      // Start of range to search (top/left)
                            sl[1].startPos/r->rect.size.height,    // End of range to search (bottom/right)
                            0.25,
                            SingleLetterTests::Bound,   // Require start (top/left) bound
                            SingleLetterTests::Bound  // Require end (bottom/right) bound
                            );
                        if (successTopRight && (resTopRight.maxDepth > r->rect.size.width * 0.20)) 
                        {
                            LimitedOpeningsTestResults resBottomRight;
                            bool successBottomRight = st1->getOpeningsLimited(resBottomRight, SingleLetterTests::Right, 
                                sl[1].endPos/r->rect.size.height,
                                0.90,
                                0.25,
                                SingleLetterTests::Bound,   // Require start (top/left) bound
                                SingleLetterTests::Bound  // Require end (bottom/right) bound
                                );
                            if (successBottomRight && (resBottomRight.maxDepth > r->rect.size.width * 0.20)) 
                            {
                                char newCh = 'E';
                                ReplacingLog("ValidateLine: rule 0216 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                                r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);					
                                makeAnotherPass = true;                                
                                r = r->next;
                                delete st1;
                                continue;
                            }                        
                        }
                    }
                    
                    // Tricky test - need to slice & dice!
                    // First, find the opening from the right side
                    bool doit = true;
                    LimitedOpeningsTestResults openingLimitedRight;
                    bool success = st1->getOpeningsLimited(
                            openingLimitedRight, SingleLetterTests::Right, 
                            0.00, 1.00, 
                            0.50,   // test depth, 
                            SingleLetterTests::Bound,   // Require start (top/left) bound
                            SingleLetterTests::Bound  // Require end (bottom/right) bound 
                            );  
                    if (success && (openingLimitedRight.maxDepth > r->rect.size.width * 0.45)) {
                        // Found opening, now cut out just the bottom part
                        CGRect bottomPart (rectLeft(r->rect), rectBottom(r->rect) + openingLimitedRight.maxDepthCoord,
                            r->rect.size.width, r->rect.size.height - openingLimitedRight.maxDepthCoord);
                        SingleLetterTests *stBottomPart = CreateSingleLetterTests(bottomPart, results);
                        if (stBottomPart != NULL) 
                        {
                            OpeningsTestResults topOpening;
                            bool success = stBottomPart->getOpenings(topOpening, SingleLetterTests::Top, 
                                0.00,      // Start of range to search (top/left)
                                1.00,    // End of range to search (bottom/right)
                                SingleLetterTests::Bound,   // Require start (top/left) bound
                                SingleLetterTests::Bound  // Require end (bottom/right) bound
                                );
                            if (success && (topOpening.maxDepth > r->rect.size.height * 0.15))
                            {
                                // Now carve out the bottom-right quartile
                                // Cut vertically at the max depth coord
                                CGRect bottomRightPart (rectLeft(bottomPart) + topOpening.maxDepthCoord, 
                                    rectBottom(bottomPart),
                                    bottomPart.size.width - topOpening.maxDepthCoord,
                                    bottomPart.size.height);
                                SingleLetterTests *stBottomRightPart = CreateSingleLetterTests(bottomRightPart, results);
                                if (stBottomRightPart != NULL) 
                                {
                                    OpeningsTestResults bottomLeftOpening;
                                    bool successOpeningFromLeftAtBottomRight = stBottomRightPart->getOpenings(bottomLeftOpening, SingleLetterTests::Left,
                                        0.00,      // Start of range to search (top/left)
                                        1.00,    // End of range to search (bottom/right)
                                        SingleLetterTests::Bound,   // Require start (top/left) bound
                                        SingleLetterTests::Bound  // Require end (bottom/right) bound
                                        );
                                    // Don't replace if we found a bounded opening in the bottom-right corner
                                    if (!successOpeningFromLeftAtBottomRight || (bottomLeftOpening.maxDepth < r->rect.size.width * 0.10))
                                    {
                                        // Not quite done yet! Some G's have just a straight up bottom part, we must also test that the top part has no such thing (or much less tall)
                                        CGRect topPart (rectLeft(r->rect), rectBottom(r->rect),
                                            r->rect.size.width, openingLimitedRight.maxDepthCoord);
                                        SingleLetterTests *stTopPart = CreateSingleLetterTests(topPart, results);
                                        if (stTopPart != NULL) 
                                        {
                                            OpeningsTestResults topBottomOpening;
                                            bool success = stTopPart->getOpenings(topBottomOpening, 
                                                SingleLetterTests::Bottom, 
                                                0.00,      // Start of range to search (top/left)
                                                1.00,    // End of range to search (bottom/right)
                                                SingleLetterTests::Bound,   // Require start (top/left) bound
                                                SingleLetterTests::Bound  // Require end (bottom/right) bound
                                                );
                                            // Replace with C only if there is an opening on top and it's at least 60% of the one at the bottom 
                                            if (success && (topBottomOpening.maxDepth > topOpening.maxDepth * 0.60)) 
                                            {
                                                float widthTop = -1, widthBottom = -1;
                                                // Need to carve out right side of top, so we can hone in on the top-right element only
                                                CGRect rectTopRight(rectLeft(topPart) + topPart.size.width / 2, rectBottom(topPart),  topPart.size.width / 2, topPart.size.height);
                                                SingleLetterTests *stTopRight = CreateSingleLetterTests(rectTopRight, results);
                                                if (stTopRight != NULL) 
                                                { 
                                                    ConnectedComponentList cplTop = stTopRight->getConnectedComponents();
                                                    if (cplTop.size() >= 2) 
                                                    {
                                                        if (successOpeningFromLeftAtBottomRight && (bottomLeftOpening.maxDepth > r->rect.size.width * 0.05))
                                                        {
                                                                OpeningsTestResults topLeftOpening;
                                                                bool successOpeningFromLeftAtTopRight = stTopRight->getOpenings(topLeftOpening, SingleLetterTests::Left,
                                                                    0.00,      // Start of range to search (top/left)
                                                                    1.00,    // End of range to search (bottom/right)
                                                                    SingleLetterTests::Bound,   // Require start (top/left) bound
                                                                    SingleLetterTests::Bound  // Require end (bottom/right) bound
                                                                );
                                                                // Don't replace if we found a bounded opening in the bottom-right corner
                                                                if (!successOpeningFromLeftAtTopRight) {
                                                                    doit = false;
                                                                }
                                                        }
            
                                                        if (doit) {
                                                            float mainTopCompBottom = cplTop[1].ymin;
                                                            float mainTopCompHeight = cplTop[1].getHeight();
                                                            SegmentList slTop = stTopRight->getHorizontalSegments((mainTopCompBottom + mainTopCompHeight * 0.875) / topPart.size.height, 0.15);
                                                            if (slTop.size() >= 1) {
                                                                // Line below seems redundant, why look at the top part when we have a more precise top-right part?
                                                                // SegmentList slTop = stTopPart->getHorizontalSegments(0.75, 0.01);
                                                                // Get the last segment (rightmost)
                                                                Segment sTopLast = slTop[slTop.size()-1];
                                                                widthTop = sTopLast.endPos - sTopLast.startPos + 1;
                                                                // Complication: bottom-right may have lots of empty space on top, need to get the main component
                                                                ConnectedComponentList cpl = stBottomRightPart->getConnectedComponents();
                                                                if (cpl.size() >= 2) {
                                                                    float mainCompTop = cpl[1].ymax;
                                                                    float mainCompHeight = cpl[1].getHeight();
                                                                    SegmentList slBottom = stBottomRightPart->getHorizontalSegments((mainCompTop - mainCompHeight * 0.875) / bottomRightPart.size.height, 0.15);
                                                                    if (slBottom.size() >= 1) 
                                                                    {
                                                                        // Get the last segment (rightmost)
                                                                        Segment s = slBottom[slBottom.size()-1];
                                                                        widthBottom = s.endPos - s.startPos + 1;
                                                                    }
                                                                }
                                                            } // slTop.size() >= 1
                                                        } // doit
                                                    }
                                                    delete stTopRight;
                                                } // stTopRight != NULL
                                                // Real 'G' had bottom width = 6 vs top width = 3
                                                // Why 1.75 acceptable? Should abstain at a much smaller diff ...
                                                if (doit && (((widthTop < 0) || (widthBottom < 0)) || (widthBottom < widthTop * 1.50))) {
                                                    char newCh = 'C';
                                                    ReplacingLog("ValidateLine: rule 0217 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                                                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);					
                                                    makeAnotherPass = true;     
                                                }
                                            }
                                            delete stTopPart;
                                        } // stTopPart != NULL
                                    }
                                    delete stBottomRightPart;
                                }
                            }
                            delete stBottomPart;
                        }
                    }
//                        delete st;
//                    }
                    delete st1;
                } // St1 != NULL
            } 
            // 'Q' instead of 'O'
            else if ((r->ch == 'Q') && !(r->flags3 & FLAGS3_TESTED_AS_Q) && (results->imageTests)) 
            {
                r->flags3 |= FLAGS3_TESTED_AS_Q;
                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                if (st != NULL) 
                {
                    OpeningsTestResults bottomRightOpening;
                    // Is there a little element at the bottom with a bottom part pointing right (as expected in 'Q')?
                    bool success = st->getOpenings(bottomRightOpening, SingleLetterTests::Right, 
                        0.50,      // Start of range to search (top/left)
                        1.00,    // End of range to search (bottom/right)
                        SingleLetterTests::Bound,   // Require start (top/left) bound
                        SingleLetterTests::Bound  // Require end (bottom/right) bound
                        );
                    if (!success || (bottomRightOpening.maxDepth < r->rect.size.width * 0.05)) 
                    {
                        // No little right pointing thingy. Test if there is *anything* below the O shape
                        SegmentList sl = st->getHorizontalSegments(0.95, 0.01);
                        if (sl.size() > 0) 
                        {
                            Segment s = sl[0];
                            // Check if segment is more or less to the right of the center
                            if ((s.startPos < r->rect.size.width * 0.40) 
                                // Or very wide (bottom of O)
                                || ((s.endPos - s.startPos + 1) > r->rect.size.width * 0.20))
                            {
                                OpeningsTestResults bottomRightSideOpening;
                                bool success = st->getOpenings(bottomRightSideOpening, SingleLetterTests::Bottom, 
                                    0.50,      // Start of range to search (top/left)
                                    1.00,    // End of range to search (bottom/right)
                                    SingleLetterTests::Bound,   // Require start (top/left) bound
                                    SingleLetterTests::Bound  // Require end (bottom/right) bound
                                    );
                                if (!success || (bottomRightSideOpening.maxDepth < r->rect.size.width * 0.05)) 
                                {
                                    char newCh = 'O';
                                    ReplacingLog("ValidateLine: rule 0218 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);					
                                    makeAnotherPass = true;     
                                }
                            }
                        }
                    }
                    delete st;
                }
            }
            
            OCRVerboseLog("OCRValidate: about to check rule 0219");
            // [x (0x78)] at [448,53 - 462,69] [w=15,h=17]
            // [a (0x61)] at [464,53 - 473,69] [w=10,h=17]
            if (((r->ch == 'x') || (r->ch == 'X'))
                && results->imageTests
                && !(r->flags4 & FLAGS4_TESTED_AS_c)
                && ((statsWithoutCurrent->averageWidthNormalLowercase.count > 1) && (r->rect.size.width > statsWithoutCurrent->averageWidthNormalLowercase.average * 1.25)))
            {
                r->flags4 |= FLAGS4_TESTED_AS_c;
                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                if (st != NULL) {
                    ConnectedComponentList cpl = st->getConnectedComponents();
                    CGRect rect1;
                    CGRect rect2;
                    bool foundDot = needToInsertDot (r, statsWithoutCurrent, cpl, rect1, rect2);
                    if (foundDot) {
                        line->addLetterWithRectConfidenceAfterRect(r->ch, rect2, r->confidence, r);
                        r->word->updateLetterWithNewCharAndNewRect(r, '.', rect1);                                    
                        makeAnotherPass = true;
                        r = r->next;
                        // Now we need to figure out if the letter is 'x' or something else (e.g. 'c')
                        // Need to recalculate st to (try to) skip the dot
                        // TODO need to add a parameter to the segments tests to ignore non-main components elements
                        SingleLetterTests *stRight = CreateSingleLetterTests(r->rect, results);
                        if (stRight != NULL) 
                        {
                            ConnectedComponentList cplRight = stRight->getConnectedComponents();
                            if (validateConnectedComponents(cplRight, r->rect)) 
                            {
                                OpeningsTestResults resLeft;
                                bool successLeft = st->getOpenings(resLeft, SingleLetterTests::Left, 
                                    0.15,      // Start of range to search (top/left)
                                    0.85,    // End of range to search (bottom/right)
                                    SingleLetterTests::Bound,   // Require start (top/left) bound
                                    SingleLetterTests::Bound  // Require end (bottom/right) bound
                                    );
                                OpeningsTestResults resTop;
                                bool successTop = st->getOpenings(resTop, SingleLetterTests::Top, 
                                    0.15,      // Start of range to search (top/left)
                                    0.85,    // End of range to search (bottom/right)
                                    SingleLetterTests::Bound,   // Require start (top/left) bound
                                    SingleLetterTests::Bound  // Require end (bottom/right) bound
                                    );    
                                OpeningsTestResults resBottom;
                                bool successBottom = st->getOpenings(resTop, SingleLetterTests::Bottom, 
                                    0.15,      // Start of range to search (top/left)
                                    0.85,    // End of range to search (bottom/right)
                                    SingleLetterTests::Bound,   // Require start (top/left) bound
                                    SingleLetterTests::Bound  // Require end (bottom/right) bound
                                    );                                                                     
                                if ((!successLeft || (resLeft.maxDepth < r->rect.size.width * 0.10))
                                    && (!successTop || (resTop.maxDepth < r->rect.size.height * 0.10))
                                    && (!successBottom || (resBottom.maxDepth < r->rect.size.height * 0.10))) 
                                {
                                    // Assume it's a 'c'
                                    char newCh = 'c';
                                    if (r->ch == 'X')
                                        newCh = 'C';
                                    ReplacingLog("ValidateLine: rule 0219 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);					
                                }
                            }
                            delete stRight;
                        } // stRight != NULL
                    }
                    delete st;
                } // st != NULL
            }
            
            OCRVerboseLog("OCRValidate: about to check rule 0057");
            // 'D' instead of 'O'
            if ((r->ch == 'D') && results->imageTests && !(r->flags5 & FLAGS5_TESTED_AS_D)) {
                r->flags5 |= FLAGS5_TESTED_AS_D;
                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                if (st != NULL) {
                    ConnectedComponentList cpl = st->getConnectedComponents();
                    // Test for 'D' instead of ".O"
                    CGRect rect1;
                    CGRect rect2;
                    bool foundDot = needToInsertDot (r, statsWithoutCurrent, cpl, rect1, rect2);
                    if (foundDot) {
                        line->addLetterWithRectConfidenceAfterRect(r->ch, rect2, r->confidence, r);
                        r->word->updateLetterWithNewCharAndNewRect(r, '.', rect1);                                    
                        r = r->next;
                        // Need to recalculate st to (try to) skip the dot
                        // TODO need to add a parameter to the segments tests to ignore non-main components elements 
                        delete st;
                        st = CreateSingleLetterTests(r->rect, results);
                        if (st != NULL) {
                            cpl = st->getConnectedComponents();
                        }
                    }
                    if ( (st != NULL) && ((cpl.size() == 2) || ((cpl.size() >= 3)
                                               && (foundDot || (cpl[2].area < cpl[1].area * 0.05)))) ) {
                        // This test fails if the 'D' doesn't touch the rect top & bottom, adjust rect if needed
                        if ((cpl[1].getHeight() > r->rect.size.height * 0.85)
                            && (cpl[1].getHeight() < r->rect.size.height)) {
                            CGRect newRect;
                            newRect.origin.x = r->rect.origin.x + cpl[1].xmin;
                            newRect.size.width = cpl[1].getWidth();
                            newRect.origin.y = r->rect.origin.y + cpl[1].ymin;
                            newRect.size.height = cpl[1].getHeight();
                            r->word->updateLetterWithNewCharAndNewRect(r, r->ch, newRect);
                                                    delete st;
                            st = CreateSingleLetterTests(r->rect, results);
                            if (st != NULL) {
                                cpl = st->getConnectedComponents();
                            }
                        }
                    }
                    if ( (st != NULL) && ((cpl.size() == 2) || ((cpl.size() >= 3) 
                                               && (foundDot || (cpl[2].area < cpl[1].area * 0.05)))) ) {
                        // This test fails if the 'D' doesn't touch the rect top & bottom, adjust rect if needed
                        if ((cpl[1].getHeight() > r->rect.size.height * 0.85)
                            && (cpl[1].getHeight() < r->rect.size.height)) {
                            CGRect newRect;
                            newRect.origin.x = r->rect.origin.x + cpl[1].xmin;
                            newRect.size.width = r->rect.size.width;
                            newRect.origin.y = r->rect.origin.y + cpl[1].ymin;
                            newRect.size.height = r->rect.size.height;
                            r->word->updateLetterWithNewCharAndNewRect(r, r->ch, newRect);
                                                    delete st;
                            st = CreateSingleLetterTests(r->rect, results);
                            if (st != NULL) {
                                cpl = st->getConnectedComponents();
                            }
                        }
                        ConnectedComponent mainComp = cpl[1];
                        SegmentList slTop = st->getHorizontalSegments(0.05, 0.05);
                        SegmentList slMiddle = st->getHorizontalSegments(0.50, 0.05);
                        SegmentList slBottom = st->getHorizontalSegments(0.95, 0.05);
#if DEBUG               
                        SingleLetterPrint(slTop, r->rect.size.width);
                        SingleLetterPrint(slMiddle, r->rect.size.width);
                        SingleLetterPrint(slBottom, r->rect.size.width);
                        if ((slTop.size() >= 1) && (slBottom.size() >= 1) && (slMiddle.size() >= 1)) {
                            ReplacingLog("validate: D test - %d away on top, %d away at the bottom with width=%d", slTop[0].startPos - slMiddle[0].startPos, slBottom[0].startPos - slMiddle[0].startPos, (unsigned short)mainComp.getWidth());
                        }
#endif                       
                        bool doit = false;
                        if ((slTop.size() >= 1) && (slMiddle.size() >= 1) && (slBottom.size() >= 1)
                            && (slTop[0].startPos - slMiddle[0].startPos > mainComp.getWidth() * 0.05)
                            && (slBottom[0].startPos - slMiddle[0].startPos > mainComp.getWidth() * 0.05)
                        ) {
                            doit = true;
                            SegmentList slVeryTop = st->getHorizontalSegments(0.00, 0.00);
                            SegmentList slVeryBottom = st->getHorizontalSegments(0.00, 0.00);

                            if (slVeryTop.size() >= 1) {
                                int topRightMargin = mainComp.xmax - slVeryTop[slVeryTop.size()-1].endPos;
                                int topLeftMargin = slVeryTop[0].startPos - mainComp.xmin;
                                ReplacingLog("validate: D test - top left marging = %d, top right margin = %d", topLeftMargin, topRightMargin);
                                if (topLeftMargin < topRightMargin * 0.50)
                                    doit = false;
                            }
                            if (doit & (slVeryBottom.size() >= 1)) {
                                int bottomRightMargin = mainComp.xmax - slVeryBottom[slVeryBottom.size()-1].endPos;
                                int bottomLeftMargin = slVeryBottom[0].startPos - mainComp.xmin;
                                ReplacingLog("validate: D test - bottom left marging = %d, bottom right margin = %d", bottomLeftMargin, bottomRightMargin);
                                if (bottomLeftMargin < bottomRightMargin * 0.50)
                                    doit = false;
                            }
                            // One more test: small 'D' (height 12) where 2nd line had one more pixel on the right and one before last line had one more pixel to the right and it was a genuine 'D'
                            if (r->rect.size.height >= 5) {
                                SegmentList slTop0 = st->getHorizontalSegmentsPixels(0, 0);
                                SegmentList slTop1 = st->getHorizontalSegmentsPixels(1, 1);
                                SegmentList slBottom0 = st->getHorizontalSegmentsPixels(mainComp.getHeight()-1, mainComp.getHeight()-1);
                                SegmentList slBottom1 = st->getHorizontalSegmentsPixels(mainComp.getHeight()-2, mainComp.getHeight()-2);
#if DEBUG
                                SingleLetterPrint(slTop0, r->rect.size.width);
                                SingleLetterPrint(slTop1, r->rect.size.width);
                                SingleLetterPrint(slBottom0, r->rect.size.width);
                                SingleLetterPrint(slBottom1, r->rect.size.width);
#endif
                                if ((slTop0.size() >= 1) && (slTop1.size() >= 1) && (slBottom0.size() >= 1) && (slBottom1.size() >= 1)) {
                                    float deltaTopLeft = slTop0[0].startPos - slTop1[0].startPos;
                                    float deltaTopRight = slTop1[slTop1.size()-1].endPos - slTop0[slTop0.size()-1].endPos;
                                    float deltaBottomLeft = slBottom0[0].startPos - slBottom1[0].startPos;
                                    float deltaBottomRight = slBottom1[slBottom1.size()-1].endPos - slBottom0[slBottom0.size()-1].endPos;
                                    if ((deltaTopRight > deltaTopLeft) && (deltaBottomRight > deltaBottomLeft)) {
                                        doit = false;
                                        ReplacingLog("ValidateLine: rule 0057 NOT replacing [%c] with [%c] in word [%s] because curved top/right & bottom/right detected", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                                    }
                                }
                            }
                        } else {
                            // Test for square 'O'
                            // Top / bottom: slice of thickness 2 (out of height 25 => 0.08%) would yield a horiz segment 22 wide (out of 25) => 88% (use 85%)
                            // Left / right: slice of thickness 2 (out of width 33 => 0.06%, use 0.08%) would yield a vert segment 27 wide (out of width 33) => 81.8%, use 80%
                            SegmentList slTop = st->getHorizontalSegments(0.04, 0.08);
                            SegmentList slBottom = st->getHorizontalSegments(0.96, 0.08);
                            SegmentList slLeft = st->getVerticalSegments(0.04, 0.08);
                            SegmentList slRight = st->getVerticalSegments(0.96, 0.08);
#if DEBUG
                            SingleLetterPrint(slTop, r->rect.size.width);
                            SingleLetterPrint(slBottom, r->rect.size.width);
                            SingleLetterPrint(slLeft, r->rect.size.height);
                            SingleLetterPrint(slRight, r->rect.size.height);
#endif
                            if ((slTop.size()==1) && (slBottom.size()==1) && (slLeft.size()==1) && (slRight.size()==1)) {
                                int leftHeight = slLeft[0].endPos - slLeft[0].startPos + 1;
                                int rightHeight = slRight[0].endPos - slRight[0].startPos + 1;
                                int topWidth = slTop[0].endPos - slTop[0].startPos + 1;
                                int topRightOffset = r->rect.size.width - slTop[0].endPos - 1;
                                int bottomWidth = slBottom[0].endPos - slBottom[0].startPos + 1;
                                int bottomRightOffset = r->rect.size.width - slBottom[0].endPos - 1;
                                int bottomLeftOffset = slBottom[0].startPos;
                                if (((topWidth > r->rect.size.width * 0.90)
                                        // If not super wide, demand that right side not much more detached than left side
                                        || ((topWidth > r->rect.size.width * 0.85) && (topRightOffset < slTop[0].startPos * 2)))
                                    && ((bottomWidth > r->rect.size.width * 0.90)
                                        // If not super wide, demand that right side not much more detached than left side
                                        || ((bottomWidth >= r->rect.size.width * 0.85) && ((bottomRightOffset < bottomLeftOffset * 2)
                                                                            || ((bottomRightOffset == 2) && (bottomLeftOffset == 1)))))
                                    && (leftHeight > r->rect.size.height * 0.80)
                                    && (rightHeight > r->rect.size.height * 0.80)
                                    // Avoid cases where left side is much longer (as in 'D')
                                    && (rightHeight > leftHeight * 0.85)) {
                                    doit = true;
                                }
                            }
                        }
                        if (doit) {
                            char newCh = 'O';
                            ReplacingLog("ValidateLine: rule 0057 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                            r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);					
                            makeAnotherPass = true;                             
                        }
                    }
                    delete st;
                } // st != NULL
            }
            
//#if DEBUG
//            if (r->ch =='h')  { /*&& (r->next != NULL) && (r->next->ch =='a')*/
//                DebugLog("Found");
//            }
//#endif 
            
            // 'h' instead of 'b'
            if ((results->imageTests)
                     && !(r->flags & TESTED_OPENING_BOTTOM)
                     && (r->ch == 'h')
                     ) 
            {
                bool doit = false;
                r->flags |= TESTED_OPENING_BOTTOM;
                // Try 8-neigbors for this one
                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results, false);
                if (st != NULL) {
                    doit = true;
                    // Test we have a single component
                    ConnectedComponentList cpl = st->getConnectedComponents();
                    if ((cpl.size() >= 3) && (cpl[2].area > cpl[1].area * 0.05)) {
                        doit = false;
                    }
                    if (doit) {
                        OpeningsTestResults resBottom;
                        bool success = st->getOpenings(resBottom, SingleLetterTests::Bottom, 
                            0.00,      // Start of range to search (top/left)
                            1.00,    // End of range to search (bottom/right)
                            SingleLetterTests::Bound,   // Require start (top/left) bound
                            SingleLetterTests::Bound  // Require end (bottom/right) bound
                            );
                        if (success && (resBottom.maxDepth >= r->rect.size.height * 0.15)) {
                            doit = false;
                        } else {
                            // There is a small opening: if there is no inverted component better abort, likely a legit 'h'
                            // maxdepth was 2 out of height 20 (10%)
                            ConnectedComponentList invertCpl = st->getInverseConnectedComponents();
                            if (invertCpl.size() != 2) {
                                doit = false;
                            }
                        }
                    }
                    // Test that we really don't have an opening through segments test
                    if (doit) {
                        SegmentList sl = st->getHorizontalSegments(0.90, 0.20);
                        if (sl.size() != 1) {
                            DebugLog("Validate: not replacing [%c] with [b] in [%s]", (unsigned short)r->ch, toUTF8(r->word->text()).c_str());
                            doit = false;
                        }
                    }
                    // We didn't find an opening at the bottom
                    // SINGLETODO need a test for rounded corners, if found assume it's a b and abort
                    // One more test: some 'h' ARE closed at the bottom, but then they have little thingies left and right
                    if (doit) {
                        OpeningsTestResults resLeft;
                        bool successLeft = st->getOpenings(resLeft, SingleLetterTests::Left, 
                            0.75,      // Start of range to search (top/left)
                            1.00,    // End of range to search (bottom/right)
                            SingleLetterTests::Any,   // Require start (top/left) bound
                            SingleLetterTests::Bound  // Require end (bottom/right) bound
                        );
                        OpeningsTestResults resRight;
                        bool successRight = st->getOpenings(resRight, SingleLetterTests::Right, 
                            0.75,      // Start of range to search (top/left)
                            1.00,    // End of range to search (bottom/right)
                            SingleLetterTests::Any,   // Require start (top/left) bound
                            SingleLetterTests::Bound  // Require end (bottom/right) bound
                        );
                        if (successLeft && successRight) {
                            doit = false;
                        }
                    }
                    delete st;
                } // st != NULL
                if (doit) {
                    char newCh = 'b';
                    ReplacingLog("ValidateLine: rule 0020 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);					
                    makeAnotherPass = true;
                    r = r->next;
                    continue;
                }
            }

            // U instead of Li
            if (r->ch == 'U') {
                wchar_t newCh1 = '\0';
                wchar_t newCh2 = '\0';
                CGRect newRect1;
                CGRect newRect2;
                if ((SingleLetterTestU(r, r->rect, statsWithoutCurrent, results, newCh1, newCh2, newRect1, newRect2) >= 0.75) && (newCh1 != '\0') && ((newCh1 != r->ch) || (newCh2 != '\0')))
                {
                    if (newCh1 != r->ch) {
                        ReplacingLog("ValidateLine: rule 0220 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)newCh1, toUTF8(r->word->text()).c_str());
                        r->word->updateLetterWithNewCharAndNewRect(r, newCh1, r->rect);
                    }
                    if (newCh2 != '\0') {
                        ReplacingLog("ValidateLine: rule 0220 replacing - adding [%c] after [%c] in word [%s]", (unsigned short)newCh2, (unsigned short)r->ch, toUTF8(r->word->text()).c_str());
                        line->addLetterWithRectConfidenceAfterRect(newCh2, newRect2, r->confidence, r);
                    }
                }
            }
            
            // 'Y' instead of 'T'
            if ((results->imageTests)
                     && !(r->flags & TESTED_OPENING_TOP)
                     && (r->ch == 'Y')) {
                float width = 0, height = 0, depth = 0, openingWidth = 0;
                bool success = OCRUtilsOpeningsTest(r->rect, results, GET_OPENINGS_TOP, false,
                                     0.00,          //start position
                                     1.00,          //end position
                                     true,          //bounds_required
                                     0.1,			// letter_thickness (determines the depth at which we test the opening width)
                                     &width,		// outWidth
                                     &height,		// outHeight,
                                     &depth,        // outMaxDepth (can have a width of just 1 pixel)
                                     NULL,			// outAverageWidth
                                     &openingWidth,	// outOpeningWidth (can be larger than letter thickness but not less)
                                     NULL,			// outMaxWidth
                                     NULL);			// outArea
                
                r->flags |= TESTED_OPENING_TOP;
                
                // leftDepth was 6.00 (%0.26), openingWidth=5.33 (%0.31)
                // depth = 8 (28% of height 29), opening width = 5.67 (15% of width 38)
                if ((success && (width > 0)) && ((depth < height * 0.20) || (openingWidth < width * 0.12)) && (height * width > r->rect.size.height * r->rect.size.width * 0.75)) {
                    // We failed to find an opening on top, must be a 'T'
                    // One more test, to eliminate the case where the Y is broken (right arm detached)
                    bool res;
                    if (!OCRUtilsTopTest(r->rect, results, &res) || res) {
                        char newCh = 'T';
                        
                        ReplacingLog("ValidateLine: rule 0221 replacing [%c] with [%c] in word [%s], leftDepth was %.2f (%%%.2f), openingWidth=%.2f (%%%.2f)", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str(), depth, depth/height, openingWidth, openingWidth/width);
                        r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);					
                        makeAnotherPass = true;
                        r = r->next;
                        continue;
                    } else {
                        ReplacingLog("ValidateLine: rule 0221 NOT replacing [%c] with [T] in word [%s] failed TopTest test, leftDepth was %.2f (%%%.2f), openingWidth=%.2f (%%%.2f)", (unsigned short)r->ch, toUTF8(r->word->text()).c_str(), depth, depth/height, openingWidth, openingWidth/width);
                    }
                }
            }
            
            OCRVerboseLog("OCRValidate: about to check rule 0004");
            // 'F' instead of 'P'
            if ((results->imageTests)
                && (r->ch == 'F')
                // Should not be glued to next as that may obstruct the opening
                && ((r->next == NULL) || (rectSpaceBetweenRects(r->rect, r->next->rect) > 0)))
            {
                wchar_t newCh = SingleLetterTestAsFP(r, r->rect, results, false);
                if ((newCh != '\0') && (newCh != r->ch)) {
                    ReplacingLog("ValidateLine: rule 0004 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                    makeAnotherPass = true;
                    r = r->next;
                    continue;
                }
            }            

            // 'c' instead of 'e'
            // Note: it's not the only 'e' test we do
            if ((r->ch == 'c') && (results->imageTests) && !(r->flags5 & FLAGS5_TESTED_AS_e)) 
            {
                r->flags5 |= FLAGS5_TESTED_AS_e;
                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                if (st != NULL)
                {
                    // Make sure we have a single connected component or more than one but 2nd is smaller than 5% of 1st
                    ConnectedComponentList cpl = st->getConnectedComponents();
                    if ((cpl.size() == 2) || ((cpl.size() >= 3) && (cpl[2].area < cpl[1].area * 0.05)))
                    {
                        ConnectedComponentList invertCpl = st->getInverseConnectedComponents();
                        if (invertCpl.size() >= 2) {
                            ConnectedComponent hole = invertCpl[1];
                            DebugLog("Validate: testing [c] as [e], found hole at [%d,%d]-[%d,%d], size=%d (%.0f%% of main component area) in word [%s]", hole.xmin, hole.ymin, hole.xmax, hole.ymax, hole.area, (float)hole.area / (float)cpl[1].area * 100.00, toUTF8(r->word->text()).c_str());
                            if ((hole.ymax < r->rect.size.height * 0.40) && (hole.area > cpl[1].area * 0.05)) {
                                char newCh = 'e';
                                ReplacingLog("ValidateLine: rule 0222 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                                r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);					
                                makeAnotherPass = true;                          
                            }
                        }
                    }
                    delete st;
                } // st != NULL
            }

//#if DEBUG
//            if ((r->ch=='0') && (r->previous != NULL) && (r->previous->ch=='1') && (r->next != NULL) && (r->next->ch =='6')) {
//                DebugLog("Found");
//            }
//#endif
            // 'y' instead of 'g'
            // 'g' instead of 'y'
            // 'q' instead of 'y'
            if ((results->imageTests)
                && !(r->flags & TESTED_OPENING_TOP)
                && ((r->ch == 'y') || (r->ch == 'g') || (r->ch == 'q')))
            {
                bool isQ = (r->ch == 'q');
                if (isQ) {
                    // Pretend current letter is a 'g'. If test g vs y says 'y', accept it
                    r->ch = 'g';
                }
                wchar_t newCh = SingleLetterTestAsgOry(r, results);
                r->flags |= TESTED_OPENING_TOP;
                if (isQ && (newCh != 'y')) {
                    // Do nothing and repair original letter
                    r->ch = 'q';
                }
                else if ((newCh != '\0') && (newCh != r->ch))
                {
                    ReplacingLog("ValidateLine: rule 0223 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)newCh, toUTF8(r->word->text()).c_str());
                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);					
                    makeAnotherPass = true;
                    r = r->next;
                    continue;                        
                }
            }
            // '0' instead of 'c'
            else if ((results->imageTests)
                     && !(r->flags & TESTED_OPENING_RIGHT)
                     && ((r->ch == '0') || (r->ch == 'O') || (r->ch == 'o'))
                     //PQPQNOTINDIGITS
                     && ((r->next == NULL) || !isDigit(r->next->ch))
                     && ((r->previous == NULL) || !isDigit(r->previous->ch))
                     ) {
                float width = 0, height = 0, depth = 0, openingWidth = 0;
                // Call below used neigbors4 = true which cause a '0' to be mapped to 'C'!
                bool success = OCRUtilsOpeningsTest(r->rect, results, GET_OPENINGS_RIGHT, false,
                                                    // Look at top half
                                                    0.15,         //start position
                                                    0.85,         //end position
                                                    true,         //bounds_required
                                                    0.10,			// letter_thickness (determines the depth at which we test the opening width)
                                                    &width,			// outWidth 
                                                    &height,		// outHeight,
                                                    &depth,	// outMaxDepth (can have a width of just 1 pixel)
                                                    NULL,			// outAverageWidth
                                                    &openingWidth,			// outOpeningWidth (can be larger than letter thickness but not less)
                                                    NULL,			// outMaxWidth
                                                    NULL);			// outArea
                
                r->flags |= TESTED_OPENING_RIGHT;
                
#if DEBUG
                if ((r->next != NULL) && (r->next->ch == '.')) {
                    DebugLog("Found");
                }
#endif            

                // False 'O' with depth=11, width=17 => 0.647
                float requiredDepth = 0.62;
                if (gluedToNext) {
                    // Be even more conservative in case glued material on the right side makes the whole main component larger and thus may create a false deep opening spanning a large % of the width
                    requiredDepth = 0.65;
                }
                
                if ((success && (width > 0)) && (height * width > r->rect.size.height * r->rect.size.width * 0.75)
                    && (depth > width * requiredDepth)
                    // Require an opening (not too huge, let's be reasonable)
                    && (openingWidth > height * 0.20)) {
                    char newCh = ((r->ch == 'o')? 'c':'C');

                    ReplacingLog("ValidateLine: rule 0055 replacing [%c] with [%c] in word [%s], rightDepth was %.2f (%%%.2f), openingWidth was %.2f (%%%.2f), percent covered by main comp=%.0f", (unsigned short)r->ch, (unsigned short)newCh, toUTF8(r->word->text()).c_str(), depth, depth/width, openingWidth, openingWidth/height, height * width / (r->rect.size.height * r->rect.size.width) * 100);
                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);					
                    makeAnotherPass = true;
                }
            }
            
            OCRVerboseLog("OCRValidate: about to check rule 0224");
            // 'W' instead of "Vi"
            if ((r->ch == 'W') 
            && (results->imageTests)
            && (!(r->flags & TESTED_OPENING_MULTI))
            && (r->next != NULL) && isLower(r->next->ch)) {
                SingleLetterTests* st = CreateSingleLetterTests(r->rect, results);
                
                r->flags |= TESTED_OPENING_MULTI;
                
                if (st != NULL) {
                    ConnectedComponentList cpl = st->getConnectedComponents();
                    
                    // Check that we have a main component (not the case if image is empty) + another (the 'i' on the right)
                    if (cpl.size() > 2) {
                        // Get main component dimensions
                        ConnectedComponent mainComp = cpl[1];
                        float height = mainComp.getHeight();
                        float width = mainComp.getWidth();
                        
                        ConnectedComponent minorComp = cpl[2];

                        // main area=190, minor area=66 (34% of main)
                        if ((height * width > r->rect.size.height * r->rect.size.width * 0.75) 
                            && (minorComp.area > mainComp.area * 0.20)
                            // Starts in the right 35% side
                            && (minorComp.xmin > r->rect.size.width * 0.65)
                            // Narrow minor comp
                            && (minorComp.getWidth() < r->rect.size.width * 0.22))
                        {
                            OpeningsTestResults resLeft;
                            bool success = st->getOpenings(resLeft, SingleLetterTests::Bottom, 
                                0,      // Start of range to search (top/left)
                                0.1,    // End of range to search (bottom/right)
                                SingleLetterTests::Unbound,   // Require start (top/left) bound
                                SingleLetterTests::Bound  // Require end (bottom/right) bound
                                );
                        
                            if (success && (resLeft.maxDepth > height * 0.80)) {
                                OpeningsTestResults resTop;
                                bool success = st->getOpenings(resTop, SingleLetterTests::Top, 
                                    0,      // Start of range to search (top/left)
                                    1,    // End of range to search (bottom/right)
                                    SingleLetterTests::Bound,   // Require start (top/left) bound
                                    SingleLetterTests::Bound  // Require end (bottom/right) bound
                                    );
                                // Shaped like a V?
                                // V had top depth=16 out of height=23 => 0.69
                                if (success && (resTop.maxDepth > height * 0.65)
                                    // Make sure it's really a V and not a W (area is around 50% of the V shape, could be a bit less)
                                    && (resTop.area > resTop.maxDepth * resTop.maxWidth * 0.45)) {
                                    // Replace with V + i !
                                    // Could be l but we don't have the tools to determine at that point
                                    char newCh1 = 'V';
                                    char newCh2 = 'i';
                                    // Test height of minor comp: if almost entire height => l
                                    if (minorComp.getHeight() > r->rect.size.height * 0.90)
                                        newCh2 = 'l';
                                    
                                    ReplacingLog("ValidateLine: rule 0224 replacing [%c] with [%c%c] in word [%s]", (unsigned short)r->ch, newCh1, newCh2, toUTF8(r->word->text()).c_str());
                                    float newHeight2 = r->rect.size.height * 0.75;
                                    float newWidth2 = width * 0.20;
                                    CGRect newRect2(rectRight(r->rect) - newWidth2 + 1,
                                       rectBottom(r->rect) + (r->rect.size.height - newHeight2),
                                       newWidth2,
                                       newHeight2);
                                    line->addLetterWithRectConfidenceAfterRect(newCh2, newRect2, r->confidence, r);
                                    
                                    CGRect newRect1(rectLeft(r->rect),
                                        rectBottom(r->rect),
                                        r->rect.size.width - newWidth2,
                                        r->rect.size.height);
                                    r->word->updateLetterWithNewCharAndNewRect(r, newCh1, r->rect);
                                }
                            }
                        }
                    }
                    delete st;
                } // st != NULL
             }   
            
            OCRVerboseLog("OCRValidate: about to check rule 0225");
            // 'n' instead of 'o'
            if ((r->ch == 'n') 
            && (!(r->flags & TESTED_OPENING_MULTI))) {
                
                // [t (0x74)] at [329,244 - 337,262] [w=9,h=19]
                // [n (0x6e)] at [340,244 - 343,258] [w=4,h=15]
                // [v (0x76)] at [346,244 - 360,258] [w=15,h=15]
                // averageHeightNormalLowercase = , averageWidthNormalLowercase = (ratio = )
                // False n ratio / av. ratio  = 1.93
                if ((r->rect.size.height > r->rect.size.width * 3) && (statsWithoutCurrent->averageWidthNormalLowercase.count > 0) && (statsWithoutCurrent->averageWidthNormalLowercase.average > 0)) {
                    float ratioCurrentLetter = r->rect.size.height / r->rect.size.width;
                    float avRatio = statsWithoutCurrent->averageHeightNormalLowercase.average / statsWithoutCurrent->averageWidthNormalLowercase.average;
                    if (ratioCurrentLetter / avRatio > 1.8) {
                        char newCh = 'l';
                        ReplacingLog("ValidateLine: rule 0225 replacing [%c] with [%c] in word [%s] (too narrow)", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                        r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                        ReplacingLog("(after replacement [%s])", toUTF8(r->word->text()).c_str());
                        r-> confidence += 500; // Force single letter examination, could be a 'i'
                        makeAnotherPass = true;
                    }
                } else {
                
                    if (results->imageTests) {
                        bool testFailed = false;
            
                        bool use4Neighbors = true;
                        if (((r->previous == NULL) || (rectSpaceBetweenRects(r->previous->rect, r->rect) > 0))
                            && ((r->next == NULL) || (rectSpaceBetweenRects(r->rect, r->next->rect) > 0))) {
                                use4Neighbors = false;
                        }
                        SingleLetterTests* st = CreateSingleLetterTests(r->rect, results, use4Neighbors);
                        
                        r->flags |= TESTED_OPENING_MULTI;
                        
                        if (st != NULL) {
                        
                            // Test that we have a single major main component
                            ConnectedComponentList cpl = st->getConnectedComponents();
                            if ((cpl.size() < 2) || ((cpl.size() >= 3) && (cpl[2].area > cpl[1].area * 0.10))) {
                                testFailed = true;
                            }

                            if (!testFailed) {
                                // Test left side
                                OpeningsTestResults resBottomLeft;
                                bool successBottomLeft = st->getOpenings(resBottomLeft, SingleLetterTests::Left, 
                                        0.80,      // Start of range to search (top/left)
                                        1.00,    // End of range to search (bottom/right)
                                        SingleLetterTests::Bound,   // Require start (top/left) bound
                                        SingleLetterTests::Bound  // Require end (bottom/right) bound
                                        );
                                
                                // We are looking for the left side to have a little protuberance on top & bottom. Accept any width of opening as suspect
                                if (successBottomLeft && (resBottomLeft.maxDepth > 0)) {
                                    testFailed = true;
                                }
                            }
                            
                            // Also test for a case where there is a thingy top-left
                            // Thinghy ended 2 pixels below top out of height 10 => take 4 out of 10
                            if (!testFailed) {
                                OpeningsTestResults resTopLeft;
                                bool successTopLeft = st->getOpenings(resTopLeft, SingleLetterTests::Left, 
                                    0,      // Start of range to search (top/left)
                                    0.40,    // End of range to search (bottom/right)
                                    SingleLetterTests::Bound,   // Require start (top/left) bound
                                    SingleLetterTests::Any  // Require end (bottom/right) bound
                                    );
                                
                                // We are looking for the left side to have a little dent located high (otherwise we will just catch the dent at the bottom left of the 'o'
                                if (successTopLeft && (resTopLeft.maxDepth > 0)) {
                                    testFailed = true;
                                }
                            }
                            
                            // Test top (little notch of 'n' top-left
                            if (!testFailed) {
                                OpeningsTestResults resTop;
                                bool successTop = st->getOpenings(resTop, SingleLetterTests::Top, 
                                        0,      // Start of range to search (top/left)
                                        0.40,    // End of range to search (bottom/right)
                                        SingleLetterTests::Bound,   // Require start (top/left) bound
                                        SingleLetterTests::Bound  // Require end (bottom/right) bound
                                        );

                                if (successTop && (resTop.maxDepth > 0)) {
                                    testFailed = true;
                                }
                            }
                            
                            // Also test for a case where there is a thingy bottom-right
                            // Thinghy ended 3 pixels above bottom out of height 10 => take 4 out of 10 (and was 2 pixels deep)
                            
                            if (!testFailed) {
                                OpeningsTestResults resBottomRight;
                                bool successBottomRight = st->getOpenings(resBottomRight, SingleLetterTests::Right, 
                                    0.60,      // Start of range to search (top/left)
                                    1,    // End of range to search (bottom/right)
                                    SingleLetterTests::Any,   // Require start (top/left) bound
                                    SingleLetterTests::Bound  // Require end (bottom/right) bound
                                    );
                                
                                // We are looking for the left side to have a little protuberance on top & bottom => big width of opening
                                if (successBottomRight && (resBottomRight.maxDepth > 0)) {
                                    testFailed = true;
                                }
                            }
                            
                            // Finally, test bottom
                            if (!testFailed) {
                                OpeningsTestResults resBottom;
                                bool successBottom = st->getOpenings(resBottom, SingleLetterTests::Bottom, 
                                    0,      // Start of range to search (top/left)
                                    1,    // End of range to search (bottom/right)
                                    SingleLetterTests::Bound,   // Require start (top/left) bound
                                    SingleLetterTests::Bound  // Require end (bottom/right) bound
                                    );
                                
                                if (!successBottom || (resBottom.maxDepth == 0)) {
                                    // Must be a 'o'!
                                    char newCh = 'o';
                                    ReplacingLog("ValidateLine: rule 0226 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                                    ReplacingLog("(after replacement [%s])", toUTF8(r->word->text()).c_str());
                                    makeAnotherPass = true;
                                }
                            }   
                            delete st;
                        } // st != NULL
                    } // if results->imageTests
                }
            }
            
            OCRVerboseLog("OCRValidate: about to check rule 0027");
            if ((r->ch == 'b') && (results->imageTests) && !(r->flags & TESTED_OPENING_BOTTOM)) 
            {
                r->flags |= TESTED_OPENING_BOTTOM;
                bool doit = true;
                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                if (st != NULL) 
                {
                    // Careful not to replace 'b' when only a tiny opening exists at the bottom
                    // Determine width of bottom part via a tall segment at bottom
                    SegmentList sl = st->getHorizontalSegments(0.95,0.05);
                    if (sl.size() >= 1) {
                        float bottomWidth = sl[sl.size()-1].endPos - sl[0].startPos + 1;
                        // Identify the bottom part (thicker part)
                        float bottomHeight = r->rect.size.height * 0.50; // Until proven otherwise
                        OpeningsTestResults resTopRight;
                        bool success = st->getOpenings(resTopRight, SingleLetterTests::Top, 
                                0.05,      // Start of range to search (top/left)
                                0.80,    // End of range to search (bottom/right)
                                SingleLetterTests::Bound,   // Require start (top/left) bound
                                SingleLetterTests::Unbound  // Require end (bottom/right) bound
                                );
                        if (success && (resTopRight.maxDepth > r->rect.size.height * 0.30) && (resTopRight.maxDepth < r->rect.size.height * 0.80)) {
                            bottomHeight = r->rect.size.height - resTopRight.maxDepth;
                            if ((bottomHeight > r->rect.size.height * 0.80) || (bottomHeight < r->rect.size.height * 0.30))
                                bottomHeight = 0.50;
                        }
                        
                        // Now measure the width of the letter at the midpoint: in a 'h' it should be not wider than at the bottom
                        SegmentList midSl = st->getHorizontalSegments((r->rect.size.height - bottomHeight/2)/r->rect.size.height,0.05);
                        float midWidth = 0;
                        if (midSl.size() >= 2) {
                            midWidth = midSl[midSl.size()-1].endPos - midSl[0].startPos + 1;
                            if (bottomWidth < midWidth * 0.85) {
                                doit = false;
                            }
                        }

                        if (doit) {
                            LimitedOpeningsTestResults resBottom;
                            success = st->getOpeningsLimited(resBottom, SingleLetterTests::Bottom, 
                                    0.00,      // Start of range to search (top/left)
                                    1.00,    // End of range to search (bottom/right)
                                    0.35,
                                    SingleLetterTests::Bound,   // Require start (top/left) bound
                                    SingleLetterTests::Bound  // Require end (bottom/right) bound
                                    );
                            if (success && (resBottom.maxDepth > r->rect.size.height * 0.30) && (resBottom.maxDepth < r->rect.size.height * 0.75) 
                                // Just to be safe
                                && (bottomWidth > 0) && (bottomWidth < r->rect.size.width) 
                                // Opening at bottom must be significant enough
                                && ((resBottom.minWidth > bottomWidth * 0.22)
                                        // Or narrower but with a wide bottom (like in a 'h')
                                      || ((resBottom.minWidth > bottomWidth * 0.25) && (midWidth != 0) && (bottomWidth >= midWidth))) )
                            {
                                // Must be a 'h'!
                                char newCh = 'h';
                                ReplacingLog("ValidateLine: rule 0027 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                                r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                            }
                        }
                    } // segments OK
                    delete st;
                } // st != NULL
            } // 'b' instead of 'h'
            
//#if DEBUG
//            if ((r->ch =='P') && (r->next != NULL) && (r->next->ch =='8')) {
//                DebugLog("Found");
//            }
//#endif            
            
            OCRVerboseLog("OCRValidate: about to check rule 0228");
            // 'P' instead of '7'
            if ((r->ch == 'P') && (results->imageTests) && !(r->flags & TESTED_OPENING_LEFT)
                && ( ((r->previous != NULL) && isDigit(r->previous->ch)) 
                     || ((r->next != NULL) && isDigit(r->next->ch)) )
               ) 
            {
                r->flags |= TESTED_OPENING_LEFT;
                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                if (st != NULL) 
                {
                    OpeningsTestResults resLeft;
                    bool success = st->getOpenings(resLeft, SingleLetterTests::Left, 
                            0.00,    // Start of range to search (top/left)
                            1.00,    // End of range to search (bottom/right)
                            SingleLetterTests::Bound,   // Require start (top/left) bound
                            SingleLetterTests::Bound  // Require end (bottom/right) bound
                            );
                    if (success && (resLeft.maxDepth > r->rect.size.width * 0.40)) 
                    {
                        // pq102
                        // Make sure 20% below top we have nothing on the left side (i.e. there isn't a bar like in a 'P')
                        SegmentList sl = st->getHorizontalSegments(0.20, 0.01);
                        if (sl.size() > 0) 
                        {
                            Segment s = sl[0];
                            // Verify that segment starts beyond 40%
                            if (s.startPos > r->rect.size.width * 0.40) 
                            {
                                // Must be a '7'!
                                char newCh = '7';
                                ReplacingLog("ValidateLine: rule 0228 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                                r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                            }
                        }
                    }
                    delete st;
                } // st != NULL
            } // 'P' instead of '7'
            
            OCRVerboseLog("OCRValidate: about to check rule 0229");
            // 'P' instead of 'F'
            if ((r->ch == 'P') && (results->imageTests) && !(r->flags2 & FLAGS2_TESTED_AS_F)
                && ((r->next == NULL) || (rectSpaceBetweenRects(r->rect, r->next->rect) > 0))
               ) 
            {
                r->flags2 |= FLAGS2_TESTED_AS_F;
                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results, false, SINGLE_LETTER_VALIDATE_COMP_SIZE|SINGLE_LETTER_VALIDATE_SINGLE_COMP);
                if (st != NULL) 
                {
                    // Make sure there is no invert component (as in a real 'P')
                    ConnectedComponentList inverts = st->getInverseConnectedComponents();
                    if (inverts.size() < 2) {
                        // Look for a deep opening from the right, bounded top & bottom
                        OpeningsTestResults resRight;
                        bool success = st->getOpenings(resRight, SingleLetterTests::Right, 
                                0.00,    // Start of range to search (top/left)
                                0.50,    // End of range to search (bottom/right)
                                SingleLetterTests::Bound,   // Require start (top/left) bound
                                SingleLetterTests::Bound  // Require end (bottom/right) bound
                                );
                        if (success && (resRight.maxDepth > r->rect.size.width * 0.40)) 
                        {
                            char newCh = 'F';
                            ReplacingLog("ValidateLine: rule 0229 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                        }
                    }
                    delete st;
                } // st != NULL
            } // 'P' instead of 'F'
            

            OCRVerboseLog("OCRValidate: about to check rule 0230");
			if ( ((r->ch == '\'') && (r->rect.size.height < r->rect.size.width))
				|| ((r->ch == '\"') && (r->rect.size.width > r->rect.size.height * 1.6)) )
			{
				// False ' was at 7-9 pixels above (ends way below the 80% height mark)
                OCRLog("ValidateLine: rule 0230 - about to call gapAboveBaseLine on char [%c] [%d,%d - w=%d,h=%d] in word [%s]", r->ch, (int)(rectLeft(r->rect)), (int)(rectBottom(r->rect)), (int)r->rect.size.width, (int)r->rect.size.height, toUTF8(r->word->text()).c_str());
				float gap = gapAboveBaselinePercent(r, r->rect, true);
                OCRLog("ValidateLine: rule 0230 - back from gapAboveBaseLine");
                OCRLog("ValidateLine: rule 0230 - gap=%.2f", gap);
				if ((gap != -1) && (gap < 0.65)) {
					char newCh = ((r->rect.size.width > r->rect.size.height * 1.25)? '-':'.');
					ReplacingLog("ValidateLine: rule 0070 replacing [0x%x] with [%c] in word [%s]", r->ch, newCh, toUTF8(r->word->text()).c_str());
					r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
					r = r->next;
					continue;
				} 
				// We could not measure the gap because not next to a letter, but if next is a tall height, test if we are way on top and delete
				else if ((gap == -1) && (r->next != NULL) && (r->next->ch != ' ')
						&& (tallHeightTest(statsWithoutCurrent.getPtr(), r->next->rect.size.height, '\0', false, 0, false) == 1)) {
					float gap = gapAboveBaselineOfOtherRect(r, r->next);
					if (gap > r->next->rect.size.height * 0.80) {
						// Remove
						ReplacingLog("ValidateLine: rule 0230 replacing - eliminating [0x%x] in word [%s]", r->ch, toUTF8(r->word->text()).c_str());
                        // There is a space next, just remove
                        SmartPtr<OCRRect> p = r->next; // Save r->next
                        r->word->removeLetter(r);
                        r = p;
						continue;
					}
				}
			}
			
            OCRVerboseLog("OCRValidate: about to check rule 0231");
			// Map large '.' to 'O' or 'o'
			if (r->ch == '.') {
				char newCh = '\0';
				if (tallHeightTest(statsWithoutCurrent.getPtr(), r->rect.size.height, '\0', false, 1, true) == 1) {
					// Set to 0 only if pretty sure, otherwise leave as 'O' because phone regex will handle just fine and map to '0'
					if ((r->previous != NULL) && isDigit(r->previous->ch)) {
						newCh = '0';
					} else {
						newCh = 'O';
					}
				} else if ((statsWithoutCurrent->averageHeightNormalLowercase.count > 1) 
							&& (r->rect.size.height > statsWithoutCurrent->averageHeightNormalLowercase.average * 0.85)) 
				{
					newCh = 'o';
				}
				float ratio;
				if (r->rect.size.height > r->rect.size.width) {
					ratio = (r->rect.size.height - r->rect.size.width) / r->rect.size.width;
				} else {
					ratio = (r->rect.size.width - r->rect.size.height) / r->rect.size.height;
				}
				
				if ((newCh != '\0') && (ratio < 1.35)) {
					ReplacingLog("ValidateLine: rule 0231 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
					r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
					r->confidence = 0;	// Protect from single-letter inspection!
					makeAnotherPass = true;				
				}
			}
			
            OCRVerboseLog("OCRValidate: about to check rule 0232");
			if ((r->ch == '\'') && (statsWithoutCurrent->averageHeightNormalLowercase.count > 2)
			&& (r->rect.size.height > statsWithoutCurrent->averageHeightNormalLowercase.average * 0.85))
			{
				// TODO: in Greek could be the small iota (but not if within an email or URL)
				char newCh = 'r';
				ReplacingLog("ValidateLine: rule 0232 replacing [%c] with [%c] in word [%s]", r->ch, newCh, toUTF8(r->word->text()).c_str());
				r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
				makeAnotherPass = true;
			} 
#if !TARGET_IPHONE
            // Blacklisted
			// Eliminate diminutive \ if in a line with lots of digits otherwise it will get mapped to a '1'
			else if ((r->ch == '\\') && (statsWithoutCurrent->averageHeightDigits.count >= 4) 
							&& (r->rect.size.height < statsWithoutCurrent->averageHeightDigits.average * 0.50)) {
				// Also check that this is next to digits
				if ( ((r->previous != NULL) && (isDigit(r->previous->ch) || ((r->previous->previous != NULL) && isDigit(r->previous->previous->ch))))
				     || ((r->next != NULL) && (isDigit(r->next->ch) || ((r->next->next != NULL) && isDigit(r->next->next->ch)))) ) {
					char newCh = ' ';
					ReplacingLog("ValidateLine: rule 0233 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
					r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
				}
			}
#endif
            if ((r != NULL) && isQuote(r->ch) && (r->next != NULL) && isVerticalLine(r->next->ch)
                && (statsWithoutCurrentAndNext->averageWidthDigits.count > 0)
                && (r->next->rect.size.width < statsWithoutCurrentAndNext->averageWidthDigits.average * 0.45)
                && (rectLeft(r->next->rect) - rectRight(r->rect) - 1 <= 0)
                && ( ((r->previous != NULL) && isDigit(r->previous->ch))
                      || ((r->next->next != NULL) && isDigit(r->next->next->ch)))
                ) {
                replaceTwo(r, '1', "rule 0450");
                makeAnotherPass = true;
            }
            
            // Replace tall | with comma. TODO: better split as distinct matches
            if (((r->ch == '|') && (r->next != NULL) && (r->previous != NULL) && strictTallTest(r, r->rect.size.height * 1.20, 0) && extendsBelowLineRelativeToNeighbors(r, false))
                || ((r->ch == 'l') && (r->next != NULL) && (r->previous != NULL) && (r->previous->ch == ' ') && (r->next->ch == ' ')
                    && strictTallTest(r, r->rect.size.height, 0) && extendsBelowLineRelativeToNeighbors(r, false))
                ) {
                // Replace with comma
                char newCh = ',';
                ReplacingLog("ValidateLine: rule 0234 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                r->confidence = 0; // Don't mess with it
            }
            
            OCRVerboseLog("OCRValidate: about to check rule 0235");
            // False 'I' that's really a '''
            if ((r->ch == 'I') && (r->previous != NULL) && (isUpper(r->previous->ch) || isTallLowercase(r->previous->ch))
                // Narrow
                && (r->rect.size.width < r->rect.size.height * 0.40)) 
            {
                float gapAboveBaseline = rectTop(r->previous->rect) - rectTop(r->rect);
                if (gapAboveBaseline > 0.80 * r->previous->rect.size.height) {
                    // We don't test how high the false 'I' climbs, this is enough to conclude
                    char newCh = '\'';
                    ReplacingLog("ValidateLine: rule 0235 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                    r->confidence = 0; // Don't mess with it
                }
            }
            
            OCRVerboseLog("OCRValidate: about to check rule 0236");
            // 'I' at start of word dipping way below line
            if ((r->ch == 'I') && ((r->previous == NULL) || (r->previous->ch == ' '))
                && (gapBelow(r,1) > r->rect.size.height * 0.17)) {
                char newCh = 'J';
                ReplacingLog("ValidateLine: rule 0236 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                r->confidence = 0; // Don't mess with it
            }
            
            // 'I' instead of 'J'
            // [N (0x4e)] at [813,239 - 826,263] [w=14,h=25]
            // [I (0x49)] at [830,239 - 839,263] [w=10,h=25]
            // Candidate for applying always when singleletter efficient
            if ((r->ch == 'I') && !(r->flags2 & FLAGS2_TESTED_AS_J) && (results->imageTests) && (statsWithoutCurrent->averageWidthUppercase.count > 0) && (r->rect.size.width > statsWithoutCurrent->averageWidthUppercase.average * 0.60)
                // Not glued to previous
                && ((r->previous == NULL) || (r->previous->ch == ' ') || (rectSpaceBetweenRects(r->previous->rect,r->rect) > 0))) {
                r->flags2 |= FLAGS2_TESTED_AS_J;
                bool doit = false;
                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results, false, SINGLE_LETTER_VALIDATE_COMP_SIZE | SINGLE_LETTER_VALIDATE_SINGLE_COMP);
                if (st != NULL) {
                    // Look for deep opening from top, at the bottom
                    CGRect newRect = CGRect(rectLeft(r->rect), rectBottom(r->rect) + r->rect.size.height * 0.50, r->rect.size.width, r->rect.size.height / 2);
                    SingleLetterTests *stBottom = CreateSingleLetterTests(newRect, results, SINGLE_LETTER_VALIDATE_COMP_SIZE | SINGLE_LETTER_VALIDATE_SINGLE_COMP);
                    if (stBottom != NULL) {
                        OpeningsTestResults topOpening;
                        bool success = stBottom->getOpenings(topOpening,
                               SingleLetterTests::Top,
                               0.05,
                               0.95,
                               SingleLetterTests::Bound,
                               SingleLetterTests::Bound
                               );
                        if (success && (topOpening.maxDepth > r->rect.size.height * 0.12)) {
                            doit = true;
                        }
                        delete stBottom;
                    }
                    delete st;
                }
                if (doit) {
                    char newCh = 'J';
                    ReplacingLog("ValidateLine: rule 0041 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                    makeAnotherPass = true;
                }
            }
            
            OCRVerboseLog("OCRValidate: about to check rule 0237");
            // Replace narrow 'u' with 'l'
            // [r (0x72)] at [133,213 - 149,234] [w=17,h=22]
            // [u (0x75)] at [153,213 - 160,234] [w=8,h=22]
            // [c (0x63)] at [165,212 - 185,235] [w=21,h=24]
            // and narrow 'a'
            // [B (0x42)] at [695,435 - 727,475] [w=33,h=41]
            // [a (0x61)] at [733,435 - 742,465] [w=10,h=31]
            // [z (0x7a)] at [747,435 - 773,465] [w=27,h=31]
            if (((r->ch == 'u') || (r->ch == 'a')) && (r->rect.size.height > r->rect.size.width * 2.40)
                && ((statsWithoutCurrent->averageWidthNormalLowercase.count == 0) || (r->rect.size.width < statsWithoutCurrent->averageWidthNormalLowercase.average * 0.50)))
            {
                char newCh = 'l';
                ReplacingLog("ValidateLine: rule 0237 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                if (results->imageTests)
                    r->confidence += 500; // Test even if line is italic
                makeAnotherPass = true;
            }
            
//#if DEBUG
//            if ((r->ch =='X') && (r->next != NULL) && (r->next->ch =='Q')) {
//                DebugLog("Found it: h/w=%f, uppercase count=%d", r->rect.size.height / r->rect.size.width, statsWithoutCurrent->averageHeightUppercase.count);
//            }
//#endif            
            
            // X instead of I
            // [T (0x54)] at [485,171 - 501,190] [w=17,h=20]
            // [X (0x58)] at [503,171 - 515,190] [w=13,h=20] (height-to-width-ratio = 1.538
            // [Q (0x51)] at [517,166 - 535,190] [w=19,h=25]
            // averageHeightUppercase = 21.083334, averageWidthUppercase = 18.217392 (ratio = 1.157)
            // False X ratio / av. ratio  = 1.33
            // X instead of I
            // [X (0x58)] at [833,380 - 838,397] [w=6,h=18]
            // [n (0x6e)] at [840,380 - 851,393] [w=12,h=14]
            // [c (0x63)] at [853,380 - 865,393] [w=13,h=14]
            // x instead of i
            // [h (0x68)] at [761,99 - 777,123] [w=17,h=25]
            // [x (0x78)] at [780,100 - 785,117] [w=6,h=18]
            // [n (0x6e)] at [788,100 - 803,118] [w=16,h=19]
            if ( (((r->ch == 'X') && (statsWithoutCurrent->averageHeightUppercase.count >= 1))
                || ((r->ch == 'x') && (statsWithoutCurrent->averageHeightNormalLowercase.count >= 2))) 
                && (r->rect.size.height > r->rect.size.width * 1.46) 
                ) {
                float heightToWidthRatio = r->rect.size.height / r->rect.size.width;
                float averageHeightToWidthRatio = ((r->ch == 'X')? (statsWithoutCurrent->averageHeightUppercase.average / statsWithoutCurrent->averageWidthUppercase.average) : (statsWithoutCurrent->averageWidthNormalLowercase.average / statsWithoutCurrent->averageWidthNormalLowercase.average));
                if (heightToWidthRatio / averageHeightToWidthRatio > 1.28) {
                    // One more test: check that there is no significant opening at the bottom (which would imply it's a 'X')
                    bool doit = true;
                    if (results->imageTests) {
                        SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                        if (st != NULL) {
                            OpeningsTestResults bottomOpening;
                            bool success = st->getOpenings(bottomOpening, 
                                SingleLetterTests::Right, 
                                0,  
                                1,
                                SingleLetterTests::Bound,
                                SingleLetterTests::Bound
                                );
                            if (success && (bottomOpening.maxDepth > r->rect.size.height * 0.12)) {
                                doit = false;
                            }
                            
                            if (doit) {
                                OpeningsTestResults topOpening;
                                bool success = st->getOpenings(topOpening, 
                                    SingleLetterTests::Right, 
                                    0,  
                                    1,
                                    SingleLetterTests::Bound,
                                    SingleLetterTests::Bound
                                    );
                                if (success && (topOpening.maxDepth > r->rect.size.height * 0.12)) {
                                    doit = false;
                                }
                            }
 
                            delete st;
                        }
                    }
                    if (doit) {
                        char newCh = ((r->ch == 'X')? 'I':'i');
                        ReplacingLog("ValidateLine: rule 0239 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                        r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                        if (results->imageTests)
                            r->confidence += 500; // Test even if line is italic
                        makeAnotherPass = true;
                    }
                }
            }
            
            // ? instead of P
            if ((r->ch == '?') && !((r->next == NULL) && ((r->previous != NULL) && isLower(r->previous->ch)))
                && results->imageTests && !(r->flags6 & FLAGS6_TESTED_AS_P)) 
            {
                wchar_t newCh = SingleLetterTestAsFP(r, r->rect, results, ((r->next == NULL)? false:true));
                if ((newCh != '\0') && (newCh != r->ch))
                {
                    ReplacingLog("ValidateLine: rule 0240 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)newCh, toUTF8(r->word->text()).c_str());
                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                    makeAnotherPass = true;                
                }
            }             
            // E instead of B
            else if ((r->ch == 'E')
                && ((r->next == NULL) || (rectSpaceBetweenRects(r->rect, r->next->rect) > 0))
                && results->imageTests && !(r->flags6 & FLAGS6_TESTED_AS_B)) 
            {
                wchar_t newCh = '\0';
                if ((SingleLetterTestAsB(r, r->rect, results, newCh) >= 0.50) && (newCh != '\0') && (newCh != r->ch))
                {
                    ReplacingLog("ValidateLine: rule 0250 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)newCh, toUTF8(r->word->text()).c_str());
                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                    makeAnotherPass = true;                
                }
            }
            
            // Narrow overlapping Z
            if ((r->ch == 'Z') && (statsWithoutCurrent->averageWidthUppercase.count > 2) && (r->rect.size.width <  statsWithoutCurrent->averageWidthUppercase.average * 0.40)
                    && ( ((r->previous != NULL) && isUpper(r->previous->ch) && (rectSpaceBetweenRects(r->previous->rect, r->rect) < 0))
                                    || ((r->previous != NULL) && isUpper(r->previous->ch) && (rectSpaceBetweenRects(r->previous->rect, r->rect) < 0))))
            {
                ReplacingLog("ValidateLine: rule 0251 replacing - eliminating small [%c] in word [%s]", (unsigned short)r->ch, toUTF8(r->word->text()).c_str());
                SmartPtr<OCRRect> p = r->next;
                r->word->removeLetter(r);
                r = p;                
                makeAnotherPass = true;
                continue;
            }
            
            
            // '1' looking like a ')'
            if ((r->ch == '1') && (OCRLine::isPresentInLineBeforeRect('(', r) || OCRLine::isPresentInLineBeforeRect('[', r))) {
                wchar_t newCh = '\0';
                if ((SingleLetterTestAsSquareBracket(r, r->rect, results, newCh) > 0.60) && (newCh == ')')) {
                    ReplacingLog("ValidateLine: rule 0252 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)newCh, toUTF8(r->word->text()).c_str());
                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                    makeAnotherPass = true;
                }
            }
            
            // narrow '3'
            if ((r->ch == '3') && !(r->flags2 & FLAGS2_TESTED) && (r->rect.size.height > r->rect.size.width * 1.75) && (statsWithoutCurrent->averageHeightDigits.count > 2) && ( ((r->previous != NULL) && (isDigit(r->previous->ch) || (r->previous->ch == '-'))) || ((r->next != NULL) && (isDigit(r->next->ch) || (r->next->ch == '-'))))) {
                float heightToWidthRatio = r->rect.size.height / r->rect.size.width;
                float averageHeightToWidthRatio = (statsWithoutCurrent->averageHeightDigits.average / statsWithoutCurrent->averageWidthDigits.average);
                if (heightToWidthRatio / averageHeightToWidthRatio > 1.60) {
                    bool doit = true;
                    char newCh = '1';
                    if (results->imageTests) {
                        SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                        r->flags2 |= FLAGS2_TESTED;
                        if (st != NULL) {
                            // Any large bounded opening on the left is a sign it can't be a '1'
                            OpeningsTestResults resLeft;
                            bool success = st->getOpenings(resLeft, SingleLetterTests::Left, 
                                0, 
                                1,
                                SingleLetterTests::Bound,
                                SingleLetterTests::Bound
                                );
                            if (success && (resLeft.maxDepth > r->rect.size.width * 0.35)) {
                                ReplacingLog("ValidateLine: NOT replacing [%c] with [%c] in word [%s] (single-letter confirmed OCR decision)", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                                doit = false;
                            }
                            delete st;
                        }
                    }
                    if (doit) {
                        ReplacingLog("ValidateLine: rule 0046 replacing [%c] with [%c] in word [%s] (too narrow)", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                        r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                        makeAnotherPass = true;
                    }
                }
            }
            
            // Low '5'
            if ((r->ch == '5') && (statsWithoutCurrent->averageHeightNormalLowercase.count >= 3) && (statsWithoutCurrent->averageHeightDigits.count == 0) && (tallHeightTest(statsWithoutCurrent.getPtr(), r->rect.size.height, 's', false, 3, true) == 0)) {
                char newCh = 's';
                ReplacingLog("ValidateLine: rule 0253 replacing [%c] with [%c] in word [%s] (too low)", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                makeAnotherPass = true;
            }
            
            // Make sure to test a false '8' last, to give other tests a chance first such as 8 -> 6
            // 8 instead of B
            // 3 instead of B
            // Skip this whole test if within a digits sequence!
            if (results->imageTests && !(r->flags2 & FLAGS2_TESTED_AS_B) && ((r->ch == '8') || (r->ch == '3'))
                && !digitsOnly && ((r->previous == NULL) || (r->previous->ch == ' ') || (rectSpaceBetweenRects(r->previous->rect, r->rect) > 0))
                && ((r->next == NULL) || (r->next->ch == ' ') || (rectSpaceBetweenRects(r->rect, r->next->rect) > 0)) ) 
            {
                if (round == 0) {
                    makeAnotherPass = true;
                } else {
                    r->flags2 |= FLAGS2_TESTED_AS_B; 
                    
                    SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                    
                    if (st != NULL) {
                    
                        OpeningsTestResults resLeft;
                        bool success1 = st->getOpenings(resLeft, SingleLetterTests::Left, 
                            0, 
                            1,
                            SingleLetterTests::Bound,
                            SingleLetterTests::Bound
                            );
                        if (!success1 || ((resLeft.maxDepth <= r->rect.size.width * 0.075) && (resLeft.maxWidth < r->rect.size.height * 0.10))) {
                            // Suspected 'B', now check that the right side has an opening
                            OpeningsTestResults resRight;
                            bool success2 = st->getOpenings(resRight, SingleLetterTests::Right, 
                                0, 
                                1,
                                SingleLetterTests::Bound,
                                SingleLetterTests::Bound
                                );
                            if (success2 && (resRight.maxDepth > 0)
                                // Also make sure that if we had a tiny opening on the left, that the one on the right is 3x bigger
                                && (!success1 || (resRight.maxDepth >= resLeft.maxDepth * 2.0))) {
                                // If orig char is '3' also test we have two holes
                                bool doit = true;
                                char newCh = 'B';
                                if (r->ch == '3') {
                                    ConnectedComponentList invertCpl = st->getInverseConnectedComponents();
                                    if (invertCpl.size() != 3) {
                                        ReplacingLog("ValidateLine: rule 0254 NOT replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                                        doit = false;
                                    }
                                }
                                if (doit) {
                                    ReplacingLog("ValidateLine: rule 0254 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);					
                                    makeAnotherPass = true;
                                    r = r->next;
                                    continue;
                                }
                            }
                        }
                    
                        delete st;
                    } // st != NULL
                }
            } 
            
            // Short and wide A instead of -
            // [n (0x6e)] at [387,865 - 398,878] [w=12,h=14]
            // [t (0x74)] at [401,865 - 407,881] [w=7,h=17]
            // [A (0x41)] at [411,871 - 416,873] [w=6,h=3]
            // [J (0x4a)] at [420,865 - 430,883] [w=11,h=19]
            if ((r->ch == 'A') && ((statsWithoutCurrent->averageHeightUppercase.count >= 2) || (statsWithoutCurrent->averageHeightUppercase.count >= 2))
                && ((statsWithoutCurrent->averageHeightUppercase.count == 0) || (r->rect.size.height < statsWithoutCurrent->averageHeightUppercase.average * 0.30))
                && ((statsWithoutCurrent->averageHeightNormalLowercase.count == 0) || (r->rect.size.height < statsWithoutCurrent->averageHeightNormalLowercase.average * 0.50))
                && (r->rect.size.width > r->rect.size.height * 1.6))
            {
                char newCh = '-';
                ReplacingLog("ValidateLine: rule 0071 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                makeAnotherPass = true;
            }
                   
                    
            // : instead of . or -
            if (r->ch == ':') {
                wchar_t newCh = '\0';
                CGRect newRect;
                if ((SingleLetterTestAsColumn(r, r->rect, results, newCh, newRect) >= 0.50) && (newCh != '\0') && (newCh != r->ch))
                {
                    ReplacingLog("ValidateLine: rule 0073 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)newCh, toUTF8(r->word->text()).c_str());
                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, newRect);
                    makeAnotherPass = true;
                }
            }
            
            OCRVerboseLog("OCRValidate: about to check rule 0255");
            // Narrow N or W instead of I
            if (((r->ch == 'N') || (r->ch == 'W')) && (r->rect.size.height > r->rect.size.width * 4.4)) {
                char newCh = 'I';
                ReplacingLog("ValidateLine: rule 0255 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                makeAnotherPass = true;
            }
            
            // H instead of K
            if (r->ch == 'H') {
                wchar_t newCh = '\0';
                if ((SingleLetterTestH(r, r->rect, statsWithoutCurrent, results, newCh) >= 0.75) && (newCh != '\0') && (newCh != r->ch)) {
                    ReplacingLog("ValidateLine: rule 0256 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)newCh, toUTF8(r->word->text()).c_str());
                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                }
            }
            
#if DEBUG
            if ((r->ch =='5') && (r->next != NULL) && (r->next->ch =='5') && (r->next->next != NULL) && (r->next->next->ch =='3')) {
                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                if (st != NULL) delete st;
                DebugLog("Found it in [%s]", toUTF8(r->word->text()).c_str());
                DebugLog("");
            }
#endif
            
            // Solid dot at mid-height - done here + again after spacing adjustments. Reason: adjust stats of bogus 'o'/'0' early for the sake of other letter rules
            // [y (0x79)] at [624,84 - 637,104] [w=14,h=21]
            // [0 (0x30)] at [647,96 - 657,106] [w=11,h=11] - solid dot
            // [F (0x46)] at [669,90 - 683,111] [w=15,h=22]
            // [o (0x6f)] at [684,90 - 697,104] [w=14,h=15]
            if ((!(r->flags5 & FLAGS5_TESTED_AS_SOLID)
                 // Even if we tested this in the main loop, re-test if surrounded by spaces because then we are more liberal
                 || ((r->next != NULL) && (r->next->ch == ' ') && (r->previous != NULL) && (r->previous->ch == ' ')))
                // Test only these for now - need to also accept '.'
                // U+00B0		c2 b0	DEGREE SIGN (accept only if surrounded by spaces
                && ((r->ch == 'o') || (r->ch == 'O') || (r->ch == '0'))
                // Height of solid dot was 73% of lowercase height
                && ((statsWithoutCurrent->averageHeightNormalLowercase.count >= 2) && (r->rect.size.height < statsWithoutCurrent->averageHeightNormalLowercase.average * 0.75))
                // Below may become necessary if we accept all chars one day (incl. dash which must not get replaced by this code)
                // && (r->rect.size.width < r->rect.size.height * 2.0)
                && (glued(r) == 0)
                )
            {
                r->flags5 |= FLAGS5_TESTED_AS_SOLID;
                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results, false, SINGLE_LETTER_VALIDATE_COMP_SIZE|SINGLE_LETTER_VALIDATE_SINGLE_COMP);
                if (st != NULL) {
                    ConnectedComponentList cpl = st->getConnectedComponents();
                    ConnectedComponentList invertCpl = st->getInverseConnectedComponents();
                    DebugLog("Validate: solid dot in [%s]? Area=%d", toUTF8(r->word->text()).c_str(), cpl[1].area);
                    // area=478, h=26, w=23 => 89%, gapabove=0.12, gapbelow=0.18
                    // No holes (i.e. completely filled in)
                    if ((invertCpl.size() < 2)
                        // Round enough that it fills the rect
                        && (cpl[1].area > cpl[1].getHeight() * cpl[1].getWidth() * 0.70)) {
                        float gapAbove = gapAboveBaselinePercent(r, cpl[1], true, true);
                        float gapBelow = gapBelowToplinePercent(r, cpl[1], true, true);
                        if (( ((gapAbove > 0.05) && (gapBelow > 0.05))
                             // If surrounded by spaces, smallish solid pattern is very unlikely to be useful and items left and right are likely to be different items
                             || ((gapAbove > 0.25) && ((r->previous == NULL) || (r->previous->ch == ' ')) && ((r->next == NULL) || (r->next->ch == ' ')))))
                        {
                            ReplacingLog("ValidateLine: rule 0124 replacing solid dot [%c] with [0xA7] in word [%s]", (unsigned short)r->ch, toUTF8(r->word->text()).c_str());
                            // If at the start or end, just eliminate
                            if ((r->previous == NULL) || (r->next == NULL))
                            {
                                SmartPtr<OCRRect> p = r->next;
                                r->word->removeLetter(r);
                                r = p;
                                makeAnotherPass = true;
                                continue;
                            } else if ((r->previous != NULL) && (r->previous->ch == ' ') && (r->previous->previous == NULL) && (r->next != NULL))
                            {
                                // Following start of line + space => remove both
                                SmartPtr<OCRRect> deletePoint = r->previous->previous;
                                SmartPtr<OCRRect> nextR = r->next;
                                // Remove the solid dot
                                nextR->word->removeLetter(nextR->previous);
                                // Remove the space
                                nextR->word->removeLetter(nextR->previous);
                                r = nextR;
                                makeAnotherPass = true;
                                continue;
                            } else if ((r->next != NULL) && (r->next->ch == ' ') && (r->next->next == NULL) && (r->previous != NULL))
                            {
                                // Following is a space then end of line => remove both
                                SmartPtr<OCRRect> nextR = r->previous;
                                // Remove the solid dot
                                nextR->word->removeLetter(nextR->next);
                                // Remove the space
                                nextR->word->removeLetter(nextR->next);
                                r = nextR->next; // Sets it to NULL, we will end this loop
                                continue;
                            } else {
                                wchar_t newCh = 0xa7;
                                r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                                makeAnotherPass = true;
                            }
                        }
                    }
                    delete st;
                }
            }
            
            // Eliminate diminutive blob mid-height before or after a digit. Note: why not do it for letters? Because at this point we don't really care about letters (only found in product abbreviations which we don't really use)
            //      0123456789abcde
            //      ---------------
            //    0|               |
            //    1|        1      |
            //    2|       11111   |
            //    3|      11  111  |
            //    4|     11    11  |
            //    5|    11      11 |
            //    6|    11      11 |
            //    7| 1          11 |
            //    8| 11       111  |
            //    9|   1     1111  |
            //    a|           11  |
            //    b|           111 |
            //    c|            11 |
            //    d|    11      11 |
            //    e|     11     11 |
            //    f|     111   11  |
            //    #|     11111111  |
            //    #|        111    |
            //    #|               |
            //      ---------------
            //      0123456789abcde
            // height = 3 vs digit height 18 (0.17x)
            // spacing = 0 but allow 2 pixel vs digit height 18 (0.11x)
            // WARNING: don't eliminate legit dashes left of a digit as in Home Depot 0000-123-456 products:
            // - quality: 97 [93,36 - 106,38] w=14,h=3]
            // 5 quality: 97 [109,26 - 121,46] w=13,h=21] => total width = 29 versus digit width = 13 (2.2x -> use 1.7x) versus height = 21 (1.38x -> use 0.7x)
            if ((statsWithoutCurrent->averageHeightDigits.count >= 2) && (r->rect.size.height < statsWithoutCurrent->averageHeightDigits.average * 0.20) && (r->next != NULL) && isDigitLookalikeExtended(r->next->ch) && (r->rect.size.height < r->next->rect.size.height * 0.20) && (rectSpaceBetweenRects(r->rect, r->next->rect) < statsWithoutCurrent->averageHeightDigits.average * 0.12)
                && (r->rect.size.width < statsWithoutCurrent->averageHeightDigits.average * 0.40)) {
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                // Just make sure it's not a dot by checking it's too far above the base line
                if ((rectTop(r->rect) < rectBottom(r->next->rect) + r->next->rect.size.height * 0.80)
                    // And make sure it's not a quote
                    && (rectBottom(r->rect) > rectBottom(r->next->rect) + r->next->rect.size.height * 0.15)
                    // Not too wide
                    && ((statsWithoutCurrent->averageHeightDigits.count < 2) || (combinedRect.size.width < statsWithoutCurrent->averageWidthDigits.average * 1.7))) {
                    replaceTwo(r, r->next->ch, "rule 0573");
                    makeAnotherPass = true;
                    continue; // No need to advance r since we removed the next OCRRect, next loop with test the digit
                }
            }
            
            // Eliminate glued quote - but note that most likely we should be mapping the glued letter to something!!!
            if (isQuote(r->ch) && (statsWithoutCurrent->averageSpacing.average > 0)) {
//#if DEBUG
//            if ((r->previous != NULL) && (rectSpaceBetweenRects(r->previous->rect, r->rect) <= 0)
//                && (r->next != NULL) && (rectSpaceBetweenRects(r->rect, r->next->rect) <= 0)) {
//                    ReplacingLog("ValidateLine: replacing ATTENTION quote glued to [%c] and [%c] in word [%s]", (unsigned short)r->previous->ch, (unsigned short)r->next->ch, toUTF8(r->word->text()).c_str());
//            }
//#endif            
                if ((r->previous != NULL) && rectSpaceBetweenRects(r->previous->rect, r->rect) <= 0) {
                    CGRect combinedRect = CreateCombinedRect(r->previous->rect, r->rect);
                    if (CreateSingleLetterTests(combinedRect, results, false, SINGLE_LETTER_VALIDATE_COMP_SIZE|SINGLE_LETTER_VALIDATE_SINGLE_COMP) != NULL) {
                        replaceTwoWithRect(r->previous, r->previous->ch, combinedRect, "rule 0095");
                        makeAnotherPass = true;
                        r = r->next;
                        continue;
                    }
                } else if ((r->next != NULL) && rectSpaceBetweenRects(r->rect, r->next->rect) <= 0) {
                    CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                    SingleLetterTests * st = CreateSingleLetterTests(combinedRect, results, false, SINGLE_LETTER_VALIDATE_COMP_SIZE|SINGLE_LETTER_VALIDATE_SINGLE_COMP);
                    if (st != NULL) {
                        char newCh = r->next->ch;
                        // [A (0x41)] at [166,240 - 190,268] [w=25,h=29]
                        // [' (0x27)] at [194,240 - 199,268] [w=6,h=29]
                        // [- (0x2d)] at [197,240 - 211,246] [w=15,h=7]
                        if ((isDash(r->next->ch) || (r->next->ch == '_')) && tallHeightTest(statsWithoutCurrentAndNext.getPtr(), combinedRect.size.height, '\0', false, 1, true) == 1) {
                                // 2nd char at the bottom
                            if ((rectBottom(r->next->rect) > combinedRect.size.height * 0.75)
                                // 1st char on left side
                                && (rectRight(r->rect) - rectLeft(combinedRect) + 1 < combinedRect.size.width * 0.40)) {
                                // One more test: verify mid-height horizontal segment ends before mid-point (i.e. we do have a tall vertical left side, even if at an angle
                                SegmentList slMidHeight = st->getHorizontalSegments(0.50, 0.00);
                                if ((slMidHeight.size() == 1) && (slMidHeight[0].endPos - rectLeft(combinedRect) + 1 < combinedRect.size.width * 0.40)) {
                                    newCh = 'L';
                                }
                            }
                        }
                        delete st;
                        replaceTwoWithRect(r, newCh, combinedRect, "rule 0095");
                        makeAnotherPass = true;
                    } // st != NULL
                }
            }
            
            // H instead of 11 ... test down below so that by now left & right are determined possibly as digits and we know what to replace with
            if ((r->ch == 'H') && results->imageTests && !(r->flags2 & FLAGS2_TESTED)) {
                r->flags2 |= FLAGS2_TESTED;
                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                if (st != 0) {
                    ConnectedComponentList cpl = st->getConnectedComponents();
                    if ((cpl.size() >= 3) && (cpl[2].area > cpl[1].area * 0.80) && (cpl[2].getHeight() > cpl[1].getHeight() * (1 - OCR_ACCEPTABLE_ERROR_LOWHURDLE))) {
                        ConnectedComponent first, second;
                        if (cpl[2].xmin > cpl[1].xmin) {
                            first = cpl[1];
                            second = cpl[2];
                        } else {
                            first = cpl[2];
                            second = cpl[1];
                        }
                        // One more test: look for absence of horizontal segments
                        SegmentList sl = st->getVerticalSegments(0.50, 0.10);
                        if (sl.size() == 0) {
                            // One more test, in case bar in the middle was only partially erased but sides almost touch
                            SegmentList slTop = st->getHorizontalSegments(0.16, 0.32);
                            SegmentList slMiddle = st->getHorizontalSegments(0.50, 0.32);
                            SegmentList slBottom = st->getHorizontalSegments(0.84, 0.32);
                            if ((slTop.size() == 2) && (slMiddle.size() == 2) && (slBottom.size() == 2)) {
                                float topGap = slTop[1].startPos - slTop[0].endPos - 1;
                                float middleGap = slMiddle[1].startPos - slMiddle[0].endPos - 1;
                                float bottomGap = slBottom[1].startPos - slBottom[0].endPos - 1;
                                if ((topGap < middleGap * 1.5) && (bottomGap < middleGap * 1.5)) {
                                    char newCh1 = 'I';
                                    char newCh2 = 'I';
                                    if (((r->previous != NULL) && isDigit(r->previous->ch)) || ((r->next != NULL) && isDigit(r->next->ch))) {
                                        newCh1 = newCh2 = '1';
                                    }
                                    CGRect newRect1 (rectLeft(r->rect) + first.xmin,
                                        rectBottom(r->rect) + first.ymin,
                                        first.getWidth(),
                                        first.getHeight());
                                    CGRect newRect2 (rectRight(r->rect) - second.getWidth() + 1,
                                        rectBottom(r->rect) + second.ymin,
                                        second.getWidth(),
                                        second.getHeight());                                
                                    ReplacingLog("ValidateLine: rule 0257 replacing [%c] with [%c%c] in word [%s]", (unsigned short)r->ch, newCh1, newCh2, toUTF8(r->word->text()).c_str());
                                    r->word->updateLetterWithNewCharAndNewRect(r, newCh1, newRect1);
                                    r->word->addLetterWithRectConfidenceAfterRect(newCh2, newRect2, r->confidence, r);
                                    r = r->next->next;					
                                    makeAnotherPass = true;
                                    delete st;
                                    continue;
                                } // middle gap much smaller than top & bottom?
                            } // valid top/mid/bottom segments
                        } // no horizontal segments
                    }
                    
                    // If we are here the first H case did not catch
                    // H instead of R
                    if ((cpl.size() == 2) || ((cpl.size() == 3) && (cpl[2].area < cpl[1].area * 0.04))) {
                        OpeningsTestResults topOpening;
                        bool success = st->getOpenings(topOpening, 
                            SingleLetterTests::Top, 
                            0.10,      // Start of range to search (top/left)
                            1.00,      // End of range to search (bottom/right)
                            SingleLetterTests::Bound,   // Require start (top/left) bound
                            SingleLetterTests::Bound  // Require end (bottom/right) bound
                            );

                        if (!success || (topOpening.maxDepth < r->rect.size.height * 0.10)) {
                            char newCh = 'R';
                            SegmentList slTop = st->getHorizontalSegments(0.025, 0.05);
                            // Margin left & right?
                            if ((slTop.size() == 1) && (slTop[0].startPos > r->rect.size.width * 0.15) && (slTop[0].endPos < r->rect.size.width * 0.85))
                            {
                                OpeningsTestResults rightOpening;
                                bool success = st->getOpenings(rightOpening, 
                                    SingleLetterTests::Right, 
                                    0.10,      // Start of range to search (top/left)
                                    0.70,      // End of range to search (bottom/right)
                                    SingleLetterTests::Bound,   // Require start (top/left) bound
                                    SingleLetterTests::Bound  // Require end (bottom/right) bound
                                    );
                                if (!success) {
                                    newCh = 'A';
                                }
                            }
                            ReplacingLog("ValidateLine: rule 0258 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                            r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                            r = r->next;					
                            makeAnotherPass = true;
                            delete st;
                            continue;
                        }
                    } // one component
                    delete st;
                } // st != NULL
            }
            
            // 'S' instead of '5' after lowercase letters and before digits
            if ((r->ch == 'S') && (r->next != NULL) && isDigit(r->next->ch) 
                // Add below test just to make sure the next char is really a digit (and not a 'o' mapped as '0' by mistake)
                && (r->next->rect.size.height > r->word->averageHeightDigits.average * (1 - OCR_ACCEPTABLE_ERROR))
                && (r->previous != NULL) && !isUpper(r->previous->ch)) 
            {
                // Now test that we have only lowercase letters in the word until current position
                bool allLowerInCurrentWordUntilNow = true;
                bool foundLower = false;
                SmartPtr<OCRRect> p = r->previous;
                while ((p != NULL) && !isDelimiter(p->ch)) {
                    if (isUpper(p->ch)) {
                        allLowerInCurrentWordUntilNow = false;
                        break;
                    } else if (!foundLower && isLower(p->ch)) {
                        foundLower = true;
                    }
                    p = p->previous;
                }
                if (allLowerInCurrentWordUntilNow && foundLower) {
                    char newCh = '5';
                    ReplacingLog("ValidateLine: rule 0259 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                    makeAnotherPass = true;
                }
            }

            // V instead of Y
            if ((r->ch == 'V')  && results->imageTests && !(r->flags5 & FLAGS5_TESTED_AS_v))
            {
                wchar_t newCh = '\0';
                CGRect newRect = r->rect;
                if (SingleLetterTestAsV(r, r->rect, statsWithoutCurrentAndNext, results, newCh, NULL, &newRect) && (newCh != '\0') && (newCh != r->ch))
                {
                    ReplacingLog("ValidateLine: rule 0101 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)newCh, toUTF8(r->word->text()).c_str());
                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, newRect);
                }
            }

            // narrow = actually a :
            // [= (0x3d)] at [299,89 - 306,111] [w=8,h=23]
            if ((r->ch == '=') && (r->rect.size.height > r->rect.size.width)) {
                char newCh = ':';
                ReplacingLog("ValidateLine: rule 0260 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                makeAnotherPass = true;
            }
            // Very narrow J next to lowercase letters
            else if ((r->ch == 'J') && (r->previous != NULL) && isLower(r->previous->ch))
            {
                // First check for "." subsumed
                CGRect rect1, rect2;
                wchar_t newCh1, newCh2;
                // Accept only if the dot is found before (to be on the safe side)
                if (needToInsertDot (r, statsWithoutCurrent, results, rect1, rect2, newCh1, newCh2) && ((newCh1 == '.') || (newCh1 == ','))) 
                {
                    ReplacingLog("ValidateLine: rule 0261 replacing [%c] with [%c%c] in word [%s]", (unsigned short)r->ch, (unsigned short)newCh1, (unsigned short)newCh2, toUTF8(r->word->text()).c_str());
                    line->addLetterWithRectConfidenceAfterRect(newCh2, rect2, r->confidence, r);
                    r->word->updateLetterWithNewCharAndNewRect(r, newCh1, rect1);
                    makeAnotherPass = true;                                  
                    r = r->next; // Point to the 'J', to let the code below test it for a possible 'l'
                } 
                if ((statsWithoutCurrent->averageWidthNormalLowercase.count >= 2) && (r->rect.size.width < statsWithoutCurrent->averageWidthNormalLowercase.average * 0.60) 
                    && ((statsWithoutCurrent->averageWidthNarrowChars.count == 0) || (r->rect.size.width < statsWithoutCurrent->averageWidthNarrowChars.average * (1 + OCR_ACCEPTABLE_ERROR_LOWHURDLE)))) 
                {
                    wchar_t newChar = 'l';
                    bool doit = false;
                    // Narrow J but still could be a 'j'
                    float gapBefore = -1000;
                    if (!isTallBelow(r->previous->ch))
                        gapBefore = gapBelowBaselinePercent(r, r->rect, true, true);
                    if ((gapBefore != -1000) && (gapBefore > 0.20)) {
                        // Can't be a 'l', could be a 'j'
                        // Test 'l' - if 'i' is suggested assume this is a 'j'!
                        float iBodyHeight = 0;
                        wchar_t newCh = OCRUtilsSuggestLetterReplacement(r->rect, 'l',
                                                    (((line->averageHeightNormalLowercase.count > 2) && (r->rect.size.height > line->averageHeightNormalLowercase.average * 1.36))? 0:maxHeightForSingleLetter),
                                                    results,
                                                    false, // Don't force replace
                                                    &iBodyHeight
                                                    );
                        if (newCh == 'i') {
                            newChar = 'j';
                            doit = true;
                        } else {
                            doit = false; // Narrow 'J' but below baseline so can't be a 'l' ... leave it alone
                        }
                    } else {
                        newChar = 'l';
                        doit = true;
                    }
                    if (doit) {
                        ReplacingLog("ValidateLine: rule 0262 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newChar, toUTF8(r->word->text()).c_str());
                        r->word->updateLetterWithNewCharAndNewRect(r, newChar, r->rect);
                        makeAnotherPass = true;
                        r->confidence += 500; // Force inspection
                    }
                }
            }
            
            if ((r->ch == '4') && (results->imageTests) && !(r->flags2 & FLAGS2_TESTED_AS_DASH)
                     && (r->rect.size.width > results->globalStats.averageWidthDigits.average * 1.3)) {
                r->flags2 |= FLAGS2_TESTED_AS_DASH;
                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                if (st != NULL) {
                    bool doit = false;
                    CGRect newRect1; CGRect newRect2;
                    ConnectedComponentList cpl = st->getConnectedComponents();
                    if (cpl.size() > 2) {
                        ConnectedComponent mainCC = cpl[1];
                        ConnectedComponent dashCC = cpl[2];
                        if ((dashCC.xmin < mainCC.xmin)
                            && (dashCC.xmax - mainCC.xmin < mainCC.getWidth() * 0.15)
                            && (dashCC.getWidth() > dashCC.getHeight() * 2.0)) {
                            doit = true;
                            newRect1 = CGRect (dashCC.xmin + rectLeft(r->rect), rectBottom(r->rect) + dashCC.ymin, dashCC.getWidth(), dashCC.getHeight());
                            newRect2 = CGRect (mainCC.xmin + rectLeft(r->rect), rectBottom(r->rect) + mainCC.ymin, mainCC.getWidth(), mainCC.getHeight());
                        }
                    } else if (cpl.size() == 2) {
                        // Connected - test using segments
                        SegmentList leftSL = st->getVerticalSegments(0.025, 0.05);
                        SegmentList leftMiddleSL = st->getVerticalSegments(0.225, 0.05);
#if DEBUG
                        SingleLetterPrint (leftSL, r->rect.size.height);
                        SingleLetterPrint (leftMiddleSL, r->rect.size.height);
#endif
                        if ((leftMiddleSL.size() == 1) && (leftSL.size() == 1)
                            && (leftMiddleSL[0].startPos > r->rect.size.height * 0.25)
                            && (leftSL[0].startPos > r->rect.size.height * 0.25)
                            && (leftMiddleSL[0].endPos < r->rect.size.height * 0.78)
                            && (leftSL[0].endPos < r->rect.size.height * 0.78)) {
                            doit = true;
                            float newBottom1 = MIN(leftMiddleSL[0].startPos, leftSL[0].startPos) + rectBottom(r->rect);
                            float newTop1 = MAX(leftMiddleSL[0].endPos, leftSL[0].endPos) + rectBottom(r->rect);
                            newRect1 = CGRect(rectLeft(r->rect), newBottom1, r->rect.size.width * 0.30, newTop1 - newBottom1 + 1);
                            newRect2 = CGRect(rectRight(newRect1)+1, rectBottom(r->rect), r->rect.size.width - newRect1.size.width, r->rect.size.height);
                        }
                    }
                    
                    if (doit) {
                        char newCh1 = '-';
                        char newCh2 = '4';
                        ReplacingLog("Validate: rule 0037 replacing [%c] with [%c%c] in word [%s]",
                                     (unsigned short)r->ch, (unsigned short)newCh1, (unsigned short)newCh2, toUTF8(r->word->text()).c_str());
                        r->word->updateLetterWithNewCharAndNewRect(r, newCh1, newRect1);
                        line->addLetterWithRectConfidenceAfterRect(newCh2, newRect2, r->confidence, r);
                        // Don't skip the '4', could combine with another char
                        r = r->next;
                        makeAnotherPass = true;
                        continue;
                    }
                    delete st;
                } // st != NULL
            }
  
#if DEBUG
            if ((r->ch =='6') && (r->next != NULL) && (r->next->ch =='.') && (r->next->next != NULL) && (r->next->next->ch =='9')) {
                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results); if (st != NULL) delete st;
                DebugLog("Found in [%s]", toUTF8(r->word->text()).c_str());
                DebugLog("Found");
            }
#endif

            //  ------------
            //0|            |
            //1|  11111111  |
            //2| 111111111  |
            //3|  11111111  |
            //4|  111       |
            //5|  11        |
            //6|  11        |
            //7|  1111111   |
            //8|  11111111  |
            //9|  111111111 |
            //a|  111   111 |
            //b|  11     11 |
            //c|  11     11 |
            //d|  11     11 |
            //e|  111   111 |
            //f|  111111111 |
            //#|   11111111 |
            //#|   1111111  |
            //#|            |
            //  ------------
            // For Walmart the above is actually a '5' - not so much with other retailers, and in fact the below rule misfires for Target (see "26 frames" example) so we are conditionning this rule with having sloped '6's for now

            // '6' instead of '5'
            if ((r->ch == '6') && results->imageTests && results->retailerParams.hasSloped6 && !(r->flags & FLAGS_TESTED_AS_5)
                && (((statsWithoutCurrent->averageWidthDigits.count > 0) && (r->rect.size.width > statsWithoutCurrent->averageWidthDigits.average * 0.85) && (r->rect.size.width < statsWithoutCurrent->averageWidthDigits.average * 1.15))
                   || ((r->rect.size.width > results->globalStats.averageWidthDigits.average * 0.85) && (r->rect.size.width < results->globalStats.averageWidthDigits.average * 1.15)))) {
                r->flags |= FLAGS_TESTED_AS_5;
                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                if (st != NULL) {
                    SegmentList slTop = st->getHorizontalSegments(0.05, 0.10);
                    SegmentList slTop20 = st->getHorizontalSegments(0.20, 0.01);
                    if ((slTop.size() == 1) && (slTop20.size() >= 1)) {
                        float topWidth = slTop[0].endPos - slTop[0].startPos + 1;
                        float topLeftMargin = slTop[0].startPos;
                        float top20LeftMargin = slTop20[0].startPos;
                        if ((topWidth - r->rect.size.width * 0.80 > -0.01) && (topLeftMargin < r->rect.size.width * 0.10) && (topLeftMargin - top20LeftMargin < r->rect.size.width * 0.08)) {
                            // Not so fast, this pattern triggered the rule on one of the Walmart frames on https://drive.google.com/open?id=0B4jSQhcYsC9VZDFtUVY1NWdKQUU because 10% of height 14 grabbed 2 lines and width of that slice was 8 (versus width 9)
                            //  -----------
                            //0|           |
                            //1|   11111   |
                            //2| 11111111  |
                            //3| 111       |
                            //4| 11        |
                            //5| 11        |
                            //6| 11111     |
                            //7| 1111111   |
                            //8| 111  11   |
                            //9| 11    11  |
                            //a| 11    111 |
                            //b| 11    11  |
                            //c| 111   11  |
                            //d| 11111111  |
                            //e|  11111    |
                            //f|           |
                            //  -----------
                            // Require that either the very top is wide or that we find an indentation on the left side/bottom half going all the way through into the letter)
                            bool doit = false;
                            SegmentList slTopTop = st->getHorizontalSegments(0.01, 0.01);
                            if ((slTop.size() == 1) && (slTop20.size() >= 1)) {
                                float topTopWidth = slTopTop[0].endPos - slTopTop[0].startPos + 1;
                                if (topTopWidth - r->rect.size.width * 0.80 > -0.01)
                                    doit = true;
                            }
                            if (!doit) {
                                // Try to find an indentation bottom-left
                                CGRect bottomHalfRect (rectLeft(r->rect), rectBottom(r->rect) + r->rect.size.height * 0.50, r->rect.size.width, r->rect.size.height * 0.50);
                                SingleLetterTests *stBottom = CreateSingleLetterTests(bottomHalfRect, results, false, 0, 0.03, true);
                                if (stBottom != NULL) {
                                    OpeningsTestResults resBottom;
                                    bool success = stBottom->getOpenings(resBottom, SingleLetterTests::Left,
                                        0.00,      // Start of range to search (top/left)
                                        1.00,      // End of range to search (bottom/right)
                                        SingleLetterTests::Bound,   // Require start (top/left) bound
                                        SingleLetterTests::Bound,  // Require end (bottom/right) bound
                                        false);
                                    if (success && (resBottom.maxDepth > bottomHalfRect.size.width * 0.20))
                                        doit = true;
                                    if (!doit) {
                                        // Try again without requiring bound above/below, only that opening be deep (coming from left), but require it be found in the center. This to handle this pattern where depth=1 because of disconnect in the middle:
                                        //  -----------
                                        //0|           |
                                        //1|      111  |
                                        //2| 11111111  |
                                        //3| 11111111  |
                                        //4| 11  111   |
                                        //5|  1        |
                                        //6|  1        |
                                        //7| 111       |
                                        //8| 1111 111  |
                                        //9| 1111 1111 |
                                        //a| 111   111 |
                                        //b|  1    111 |
                                        //c|       111 |
                                        //d| 11    111 |
                                        //e| 111   111 |
                                        //f| 111111111 |
                                        //#| 11111111  |
                                        //#|   1       |
                                        //#|           |
                                        //  -----------
                                        success = stBottom->getOpenings(resBottom, SingleLetterTests::Left,
                                            0.25,      // Start of range to search (top/left)
                                            0.50,      // End of range to search (bottom/right)
                                            SingleLetterTests::Any,   // Require start (top/left) bound
                                            SingleLetterTests::Any,  // Require end (bottom/right) bound
                                            false); // Take into account ALL comps
                                        if (success && (resBottom.maxDepth > bottomHalfRect.size.width * 0.20))
                                            doit = true;
                                    }
                                    delete stBottom;
                                }
                            }
                            if (doit) {
                                wchar_t newCh = '5';
                                ReplacingLog("ValidateLine: rule 0603 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                                r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                                makeAnotherPass = true;
                            }
                        }
                    }
                    delete st;
                }
            }
            
            // '6' instead of '8'
            if ((r->ch == '6') && !(r->flags3 & FLAGS3_TESTED_AS_6)) {
                r->flags3 |= FLAGS3_TESTED_AS_6;
                wchar_t newCh = SingleLetterTestSAsDigit(r, r->rect, 0, results);
                if ((newCh != '\0') && (newCh != r->ch)) {
                    ReplacingLog("ValidateLine: rule 0290 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                    makeAnotherPass = true;
                }
            }
            
#if DEBUG
            if ((r->ch =='7') && (r->previous != NULL) && (r->previous->ch =='4') && (r->next != NULL) && ((r->next->ch =='0') || (r->next->ch =='O'))) {
                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results); if (st != NULL) delete st;
                DebugLog("Found in [%s]", toUTF8(r->word->text()).c_str());
                DebugLog("Found");
            }
#endif
            
            
            //  -------
            //0|       |
            //1| 1111  |
            //2| 11111 |
            //3| 1  11 |
            //4|   11  |
            //5|   11  |
            //6|  11   |
            //7| 111   |
            //8| 111   |
            //9| 1111  |
            //a|  11   |
            //b|       |
            //  -------
            // '7' instead of '2'
            if ((r->ch == '7') && (results->imageTests) && !(r->flags & FLAGS2_TESTED_AS_2)) {
                r->flags2 |= FLAGS2_TESTED_AS_2;
                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                bool doit = false;
                if (st != NULL) {
                    SegmentList slTop = st->getHorizontalSegments(0.10, 0.20);
                    SegmentList slBottom = st->getHorizontalSegments(0.90, 0.20);
                    if ((slTop.size() == 1) && (slBottom.size() == 1)) {
                        int topWidth = slTop[0].endPos - slTop[0].startPos + 1;
                        int bottomWidth = slBottom[0].endPos - slBottom[0].startPos + 1;
                        if ((topWidth <= bottomWidth * 1.25) && (bottomWidth <= topWidth * 1.25)) {
                            // Check indentation bottom-right
                            CGRect bottomHalf (rectLeft(r->rect), rectBottom(r->rect) + r->rect.size.height * 0.40, r->rect.size.width, r->rect.size.height * 0.60);
                            SingleLetterTests *stBottom = CreateSingleLetterTests(bottomHalf, results, false, 0, 0.03, true);
                            if (stBottom != NULL) {
                                OpeningsTestResults resBottom;
                                bool success = stBottom->getOpenings(resBottom, SingleLetterTests::Right,
                                    0.00,      // Start of range to search (top/left)
                                    1.00,      // End of range to search (bottom/right)
                                    SingleLetterTests::Bound,   // Require start (top/left) bound
                                    SingleLetterTests::Bound  // Require end (bottom/right) bound
                                    );
                                if (success) {
                                    doit = true;
                                }
                                delete stBottom;
                            }
                        }
                    }
                    delete st;
                }
                if (doit) {
                    char newCh = '2';
                    ReplacingLog("ValidateLine: rule 0593 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                    makeAnotherPass = true;
                }
            }
            
#if DEBUG
            if ((r->ch =='6') && (r->previous != NULL) && (r->previous->ch =='3') && (r->next != NULL) && (r->next->ch =='0')) {
                DebugLog("Found in [%s]", toUTF8(r->word->text()).c_str());
                DebugLog("Found");
            }
#endif
            
            
            // '6' instead of '0'
            if ((r->ch == '6') && !(r->flags2 & FLAGS2_TESTED_AS_DIGIT)) {
                wchar_t newCh = SingleLetterTestAsDigit(r, results, statsWithoutCurrent, false);
                if ((newCh != '\0') && (newCh != r->ch)) {
                    ReplacingLog("ValidateLine: rule 0541 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                    makeAnotherPass = true;
                }
            }
            
            // Very small '4' instead of '.'
            else if (r->ch == '4') {
                float heightRatioWithNormalLowercase = 
                    (((statsWithoutCurrent->averageHeightNormalLowercase.count > 1) && (statsWithoutCurrent->averageHeightNormalLowercase.average > 0))?  r->rect.size.height / statsWithoutCurrent->averageHeightNormalLowercase.average : -1); 
                float heightRatioWithDigits = 
                    (((statsWithoutCurrent->averageHeightDigits.count > 1) && (statsWithoutCurrent->averageHeightDigits.average > 0))?  r->rect.size.height / statsWithoutCurrent->averageHeightDigits.average : -1);  
                float heightRatioWithUppercase = 
                    (((statsWithoutCurrent->averageHeightUppercase.count > 1) && (statsWithoutCurrent->averageHeightUppercase.average > 0))?  r->rect.size.height / statsWithoutCurrent->averageHeightUppercase.average : -1);
                if (((heightRatioWithNormalLowercase == -1) || (heightRatioWithNormalLowercase < 0.30))
                    && ((heightRatioWithUppercase == -1) || (heightRatioWithUppercase < 0.30))
                    && ((heightRatioWithDigits == -1) || (heightRatioWithDigits < 0.30))
                    // Now also check against immediate neigbors
                    && ((r->previous == NULL) || !isLetterOrDigit(r->previous->ch) || (r->rect.size.height < r->previous->rect.size.height * 0.30))
                    && ((r->next == NULL) || !isLetterOrDigit(r->next->ch) || (r->rect.size.height < r->next->rect.size.height * 0.30))) 
                {
                    // TODO check position & aspect ratio to suggest something different than '.'?
                    // Note: we are not checking if this '.' is so small that it needs to be eliminated, that's done right next below
                    char newCh = '.';
                    ReplacingLog("ValidateLine: rule 0091 replacing small [%c] with [.] in word [%s]", (unsigned short)r->ch, toUTF8(r->word->text()).c_str());
                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                    makeAnotherPass = true;
                }
            }
            
            //  instead of B
            // U+00DF		c3 9f	LATIN SMALL LETTER SHARP S
            if ((r->ch == 0xdf)
                && (results->languageCode != LanguageENG)
                && !(r->flags3 & FLAGS3_TESTED_OPENING_BOTTOM_LEFT))
            {
                r->flags3 |= FLAGS3_TESTED_OPENING_BOTTOM_LEFT;
                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                if (st != NULL)
                {
                    ConnectedComponentList cpl = st->getConnectedComponents();
                    if (validateConnectedComponents(cpl, r->rect)) 
                    {
                        bool doit = true;
                        // Require that we have two invert components
                        ConnectedComponentList invertCpl = st->getInverseConnectedComponents(false, 0.024);
                        if (invertCpl.size() != 3) {
#if DEBUG                        
                            DebugLog("Validate: German double-s test, failed to find 2 decent inverted components");
#endif                            
                            doit = false;
                        }
#if DEBUG                        
                        SingleLetterPrint(invertCpl, r->rect);
#endif                         
                        if (doit) {
                            OpeningsTestResults resBottom;
                            bool success = st->getOpenings(resBottom, SingleLetterTests::Bottom, 
                                0.07,      // Start of range to search (top/left)
                                0.50,      // End of range to search (bottom/right)
                                SingleLetterTests::Bound,   // Require start (top/left) bound
                                SingleLetterTests::Bound  // Require end (bottom/right) bound
                                );
                                    
                            if (success && resBottom.maxDepth > r->rect.size.height * 0.15) {
                                // Found opening at bottom, not a B
                                doit = false;
                            }
                        }
                        SegmentList sl = st->getHorizontalSegments(0.95, 0.10);
                        if ((sl.size() > 0) 
                            // Bar on left-bottom starts close to left side
                            && (sl[sl.size() - 1].startPos < r->rect.size.width * 0.10)
                            // Bar not wider than 30% of width
                            && (sl[sl.size() - 1].endPos < r->rect.size.width * 0.30)) {
                            doit = false;
                        }
                        if (doit) {
                            char newCh = 'B';
                            ReplacingLog("ValidateLine: rule 0264 replacing [German double s] with [%c] in word [%s]", newCh, toUTF8(r->word->text()).c_str());
                            r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                        }
                    }
                    delete st;
                } // st != NULL
            }
            
//#if DEBUG
//            if ((r->ch=='r') && (r->next != NULL) && (r->ch == ' ')) {
//                DebugLog("Found");
//            }
//#endif            
            
            if ((r->ch == 'r') && (results->imageTests)) 
            {
                // 'r' instead of 'F'
                // [L (0x4c)] at [167,452 - 182,472] [w=16,h=21]
                // [\n or '  ']  at [183,452 - 183,452] [w=1,h=1]
                // [o (0x6f)] at [195,452 - 215,473] [w=21,h=22]
                // [r (0x72)] at [218,452 - 232,473] [w=15,h=22]
                // [\n or '  ']  at [233,452 - 233,452] [w=1,h=1]
                // [M (0x4d)] at [244,452 - 280,479] [w=37,h=28]
                if (!(r->flags2 & FLAGS2_TESTED_AS_F) && (statsWithoutCurrent->averageHeightUppercase.count > 1) && (r->rect.size.height > (statsWithoutCurrent->averageHeightUppercase.average * (1 - OCR_ACCEPTABLE_ERROR)))) 
                {
                    r->flags2 |= FLAGS2_TESTED_AS_F;
                     
                    SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
        
                    if (st != NULL) {
                
                        OpeningsTestResults RightOpening;
                        bool success = st->getOpenings(RightOpening, 
                                        SingleLetterTests::Right, 
                                        0.0,      // Start of range to search (top/left)
                                        0.50,      // End of range to search (bottom/right)
                                        SingleLetterTests::Bound,   // Require start (top/left) bound
                                        SingleLetterTests::Bound  // Require end (bottom/right) bound
                                        );
                        if (success && (RightOpening.maxDepth > r->rect.size.width * 0.35)) {
                            char newCh = 'F';
                            ReplacingLog("ValidateLine: rule 0265 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                            r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                            makeAnotherPass = true;
                        }
                        
                        delete st;
                    }
                } // 'r' replaced by 'F'
                // Possible 't'
                else if (!(r->flags4 & FLAGS4_TESTED_AS_t) && (tallHeightTest(statsWithoutCurrent.getPtr(), r->rect.size.height, 't', false, 2, true) == 1)) 
                {
                    r->flags4 |= FLAGS4_TESTED_AS_t;
                    SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
        
                    if (st != NULL) {
                        ConnectedComponentList cpl = st->getConnectedComponents();
                        SegmentList sl = st->getHorizontalSegments(0.10, 0.01);
                        if ((cpl.size() >= 2) && (sl.size() == 1)) 
                        {
                            ConnectedComponent mainComp = cpl[1];
                            Segment s = sl[0];
                                // vertical bar at or past center
                            if (((s.startPos + s.endPos) / 2 >= (mainComp.getWidth() - 1) * 0.35) 
                                // vertical bar leaves enough on the right side
                                && (s.endPos < mainComp.getWidth() * 0.85)) 
                            {
                                // Test left side, look for top opening bounded right but not too deep
                                OpeningsTestResults leftOpening;
                                bool success = st->getOpenings(leftOpening, 
                                    SingleLetterTests::Right, 
                                    0.0,      // Start of range to search (top/left)
                                    s.startPos + 1,      // End of range to search (bottom/right)
                                    SingleLetterTests::Unbound,   // Require start (top/left) bound
                                    SingleLetterTests::Bound  // Require end (bottom/right) bound
                                    );
                                if (success && (leftOpening.maxDepth > 0) && (leftOpening.maxDepth < mainComp.getHeight() * 0.40)) 
                                {
                                    // Test right side, look for top opening bounded left but not too deep
                                    OpeningsTestResults rightOpening;
                                    bool success = st->getOpenings(rightOpening, 
                                        SingleLetterTests::Right, 
                                        0.0,      // Start of range to search (top/left)
                                        s.endPos - 1,      // End of range to search (bottom/right)
                                        SingleLetterTests::Bound,   // Require start (top/left) bound
                                        SingleLetterTests::Unbound  // Require end (bottom/right) bound
                                        );
                                    if (success && (rightOpening.maxDepth > 0) && (rightOpening.maxDepth < mainComp.getHeight() * 0.40)) 
                                    {
                                        char newCh = 't';
                                        ReplacingLog("ValidateLine: rule 0266 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                                        r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                                        makeAnotherPass = true;
                                    }
                                } // there is a leftOpening
                            } // found proper segment on top
                        } // got main comp and segment
                        delete st;
                    } // got st
                } // 't' case
            } // all 'r' cases
            
            // Normal dot:
            // [w (0x77)] at [124,47 - 172,76] [w=49,h=30]
            // [. (0x2e)] at [172,47 - 183,59] [w=12,h=13]
            // [k (0x6b)] at [188,47 - 220,87] [w=33,h=41] (spaces = -1 + 4 => 3)
            // Bad comma:
            // [h (0x68)] at [461,49 - 490,88] [w=30,h=40]
            // [, (0x2c)] at [493,50 - 494,52] [w=2,h=3]
            // [o (0x6f)] at [493,49 - 526,78] [w=34,h=30] (space = 2)
            // averageSpacing = 3.7
            if (((r->ch == ',') || (r->ch == '.')) && (r->rect.size.height * r->rect.size.width < statsWithoutCurrent->averageHeight.average * statsWithoutCurrent->averageWidth.average * 0.01)) {
                // We may want to add a test that the spacing is abnormally low - but let's see if this size test is safe enough
                ReplacingLog("ValidateLine: rule 0267 replacing - eliminating small [%c] in word [%s]", (unsigned short)r->ch, toUTF8(r->word->text()).c_str());
                SmartPtr<OCRRect> p = r->next;
                r->word->removeLetter(r);
                r = p;                
                makeAnotherPass = true;
                continue;
            }
            
            // Special pass for phone number with a diminutive smallish letter (likely a prefix)
            // [2 (0x32)] at [31,336 - 37,348] [w=7,h=13]
            // [\n or '  ']  at [38,336 - 38,336] [w=1,h=1]
            // [( (0x28)] at [49,332 - 53,355] [w=5,h=24]
            // [5 (0x35)] at [54,336 - 68,355] [w=15,h=20]
            // av. spacing = 0.429, space with next = 11, av. width digit = 14.5
            if ((r->previous == NULL) && (statsWithoutCurrent->averageHeightDigits.count > 4) && (r->rect.size.height < statsWithoutCurrent->averageHeightDigits.average * 0.70) && (r->next != NULL) && (r->next->ch == ' ') && isDigit(r->ch) && (r->next->next != NULL)) {
                float spaceWithNextAfterSpace = rectSpaceBetweenRects(r->rect, r->next->next->rect);
                if ((spaceWithNextAfterSpace > r->rect.size.width * 1.25) && (spaceWithNextAfterSpace > statsWithoutCurrentAndNextTwo->averageWidthDigits.average * 0.6)) { 
                    // Eliminate, such an isolated leading digit will not help us
                    ReplacingLog("ValidateLine: rule 0268 replacing - eliminating smallish [%c] at start of phone in word [%s]", (unsigned short)r->ch, toUTF8(r->word->text()).c_str());
                    r->word->removeLetter(r->next);
                    SmartPtr<OCRRect> p = r->next;
                    r->word->removeLetter(r);
                    r = p;
                    // May create a situation where r now points to NULL yet the rest of the code really never assumes r is NULL
                    if (r == NULL) continue;
                }
            }
            
            // '1' in the middle of uppercase letters as high as it is tall => Z
            // [O (0x4f)] at [175,137 - 186,147] [w=12,h=11]
            // [1 (0x31)] at [188,137 - 198,147] [w=11,h=11]
            // [A (0x41)] at [200,137 - 211,147] [w=12,h=11]
            // [l (0x6c)] at [214,137 - 217,147] [w=4,h=11]

            if (isVerticalLine(r->ch) && !(r->flags3 & FLAGS3_TESTED_AS_Z)
                && (statsWithoutCurrent->averageHeightUppercase.count >= 1)
                // Tall as a uppercase
                && (r->rect.size.height > statsWithoutCurrent->averageHeightUppercase.average * (1 - OCR_ACCEPTABLE_ERROR))
                // Barely taller than it is wide ('1' is usually 2x taller, like 6:14)
                && (r->rect.size.height < r->rect.size.width * 1.2)
                && (results->imageTests)) {
                r->flags3 |= FLAGS3_TESTED_AS_Z;
                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                if (st != NULL) {
                    OpeningsTestResults topLeft;
                    bool success = st->getOpenings(topLeft, 
                        SingleLetterTests::Left, 
                        0.00,      // Start of range to search (top/left)
                        1.00,      // End of range to search (bottom/right)
                        SingleLetterTests::Bound,   // Require start (top/left) bound
                        SingleLetterTests::Bound  // Require end (bottom/right) bound
                        );
                    // Area = 14 or 12 out of wxh = 11x11 = 121
                    if (success && (topLeft.maxDepth > r->rect.size.width * 0.25) && (topLeft.maxDepthCoord < r->rect.size.height * 0.60) && (topLeft.area > r->rect.size.height * r->rect.size.width * 0.09)) 
                    {
                        // Now expect a larger gap when only requiring top bound
                        bool success = st->getOpenings(topLeft, 
                            SingleLetterTests::Left, 
                            0.00,      // Start of range to search (top/left)
                            1.00,      // End of range to search (bottom/right)
                            SingleLetterTests::Bound,   // Require start (top/left) bound
                            SingleLetterTests::Any  // Require end (bottom/right) bound
                            );
                        if (success && (topLeft.maxDepth > r->rect.size.width * 0.35)) 
                        {
                            OpeningsTestResults bottomRight;
                            bool success = st->getOpenings(bottomRight, 
                                SingleLetterTests::Right, 
                                0.00,      // Start of range to search (top/left)
                                1.00,      // End of range to search (bottom/right)
                                SingleLetterTests::Bound,   // Require start (top/left) bound
                                SingleLetterTests::Bound  // Require end (bottom/right) bound
                                );
                            if (success && (bottomRight.maxDepth > r->rect.size.width * 0.25) && (bottomRight.maxDepthCoord > r->rect.size.height * 0.40) && (bottomRight.area > r->rect.size.height * r->rect.size.width * 0.09)) {
                                bool success = st->getOpenings(bottomRight, 
                                    SingleLetterTests::Right, 
                                    0.00,      // Start of range to search (top/left)
                                    1.00,      // End of range to search (bottom/right)
                                    SingleLetterTests::Any,   // Require start (top/left) bound
                                    SingleLetterTests::Bound  // Require end (bottom/right) bound
                                    );
                                if (success && (bottomRight.maxDepth > r->rect.size.width * 0.35)) {
                                    char newCh = 'Z';
                                    ReplacingLog("ValidateLine: rule 0269 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                                    makeAnotherPass = true; 
                                }
                            }
                        }
                    }
                    delete st;
                }
            }
            
            OCRVerboseLog("OCRValidate: about to check rule 0018");
            // . instead of ,
            if (r->ch == '.') {
                bool dotBefore = (r->previous != NULL) && ((r->previous->ch == '.') || ((r->previous->ch == ' ') && (r->previous->previous != NULL) && (r->previous->previous->ch == '.')));
                if ((((r->rect.size.height > r->rect.size.width * OCR_MAX_H_TO_W_RATIO_DOT_SAFE) || (dotBefore && (r->rect.size.height > r->rect.size.width)))
                    || ((r->rect.size.height >= 6) && (r->rect.size.height >= r->rect.size.width * 1.4)))
                    // Not glued to next
                    && ((r->next == NULL) || (r->next->ch == ' ') || (rectSpaceBetweenRects(r->rect, r->next->rect) > 0)))
                {
                    bool doit = false;
                    // Not glued to prev
                    if ((r->previous == NULL) || (r->previous->ch == ' ') || (rectSpaceBetweenRects(r->previous->rect, r->rect) > 0)) {
                        doit = true;
                    } else if (results->imageTests && !(r->flags5 & FLAGS5_TESTED_AS_DOT)) {
                        // Glued to prev - give it a chance if the ',' and the previous letter are not actually touching, just overlapping in terms of rects
                        r->flags5 |= FLAGS5_TESTED_AS_DOT;
                        CGRect combinedRect = CreateCombinedRect(r->previous->rect, r->rect);
                        SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
                        if (st != NULL) {
                            ConnectedComponentList cpl = st->getConnectedComponents();
                            if (cpl.size() == 3) {
                                ConnectedComponent majorCC = cpl[1];
                                ConnectedComponent minorCC = cpl[2];
                                if ((minorCC.xmin > majorCC.getWidth() * 0.60)
                                    && (minorCC.ymin > majorCC.getHeight() * 0.50)) {
                                    CGRect newRect1 (rectLeft(r->previous->rect) + minorCC.xmin, rectBottom(r->previous->rect) + minorCC.ymin, minorCC.getWidth(), minorCC.getHeight());
                                    r->word->updateLetterWithNewCharAndNewRect(r, r->ch, newRect1);
                                    // Update previous rect while we are at it
                                    CGRect newRect2 (rectLeft(r->previous->rect) + majorCC.xmin, rectBottom(r->previous->rect) + majorCC.ymin, majorCC.getWidth(), majorCC.getHeight());
                                    r->word->updateLetterWithNewCharAndNewRect(r->previous, r->previous->ch, newRect2);
                                    // Re-check proportions
                                    if ((newRect1.size.height > newRect1.size.width * OCR_MAX_H_TO_W_RATIO_DOT_SAFE)
                                        || ((newRect1.size.height >= 6) && (newRect1.size.height >= newRect1.size.width * 1.4)))
                                        doit = true;
                                }
                            }
                            delete st;
                        }
                    }
                    if (doit) {
                        float gap = gapBelow(r,1);
                        // 2 pixels below out of h=6 (33%)
                        if (gap > r->rect.size.height * 0.30) {
                            char newCh = ',';
                            ReplacingLog("ValidateLine: rule 0018 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)newCh, toUTF8(r->word->text()).c_str());
                            r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                            makeAnotherPass = true; 
                        }
                    }
                }
                // Other case: taller than wide (but not by much), dipping below line and bottom part more narrow than width
                else if ((r->rect.size.height >= r->rect.size.width * 1.20) && !(r->flags5 & FLAGS5_TESTED_AS_DOT)) {
                    r->flags5 |= FLAGS5_TESTED_AS_DOT;
                    float gapBelowLine = gapBelow(r, 2);
                    if (gapBelowLine >= r->rect.size.height * 0.33) {
                        int spaceBefore = 10000;
                        if (r->previous != NULL) {
                            if (r->previous->ch != ' ') {
                                spaceBefore = rectSpaceBetweenRects(r->previous->rect, r->rect);
                            } else {
                                if (r->previous->previous != NULL) {
                                    spaceBefore = rectSpaceBetweenRects(r->previous->previous->rect, r->rect);
                                }
                            }
                        }
                        int spaceAfter = 10000;
                        if (r->next != NULL) {
                            if (r->next->ch != ' ') {
                                spaceAfter = rectSpaceBetweenRects(r->rect, r->next->rect);
                            } else {
                                if (r->next->next != NULL) {
                                    spaceAfter = rectSpaceBetweenRects(r->rect, r->next->next->rect);
                                }
                            }
                        }
                        if ((spaceBefore != 10000) && (spaceAfter != 10000) && (spaceBefore < spaceAfter)) {
                            SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                            if (st != NULL) {
                                bool doit = false;
                                SegmentList slBottom = st->getHorizontalSegments(0.85, 0.30);
                                if ((slBottom.size() >= 1) && (slBottom[slBottom.size()-1].endPos - slBottom[0].startPos + 1 <= r->rect.size.width * 0.40)) {
                                    doit = true;
                                }
                                if (doit) {
                                    char newCh = ',';
                                    ReplacingLog("ValidateLine: rule 0284 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)newCh, toUTF8(r->word->text()).c_str());
                                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                                    makeAnotherPass = true;
                                }
                                delete st;
                            }
                        }
                    }
                }
            } // r->ch == '.'
            
            // Smallish '1' with all digits larger
            // [1 (0x31)] at [698,182 - 709,204] [w=12,h=23]
            // [8 (0x38)] at [861,189 - 879,211] [w=19,h=23]
            // [8 (0x38)] at [881,189 - 899,212] [w=19,h=24]
            // [\n or '  ']  at [900,189 - 900,189] [w=1,h=1]
            // [1 (0x31)] at [912,191 - 918,207] [w=7,h=17]
            if (((r->ch == '1') || ((r->ch == 'l') && digitsNearby(r, true)))
                && (statsWithoutCurrent->averageHeightDigits.count > 4) && (r->rect.size.height < statsWithoutCurrent->averageHeightDigits.average * 0.75)) {
                // Because we plan to eliminate this digit, be extra cautious and check that is it 77% smaller than ALL other digits AND 70% narrower
                bool doit = true;
                // Search before
                SmartPtr<OCRRect> p = r->previous;
                while (p != NULL) {
                    if (isDigit(p->ch) && ((r->rect.size.height > p->rect.size.height * 0.77) || (r->rect.size.width > p->rect.size.width * 0.70))) {
                        doit = false;
                        break;
                    }
                    p = p->previous;
                }
                if (doit) {
                    p = r->next;
                    while ((p != NULL) && (p->ch != '\n')) {
                        if (isDigit(p->ch) && ((r->rect.size.height > p->rect.size.height * 0.77) || (r->rect.size.width > p->rect.size.width * 0.70))) {
                            doit = false;
                            break;
                        }
                        p = p->next;
                    }
                }
                if (doit) {
                    // Could be a lowercase letter like 't', 'l' or 'f' - if there are other lowercase letters and if current one is taller
                    if ((statsWithoutCurrent->averageHeightNormalLowercase.count >= 3) && (r->rect.size.height * statsWithoutCurrent->averageHeightNormalLowercase.average * (1 + OCR_ACCEPTABLE_ERROR))) {
                        // Convert to 't' + ask single letter to take a closer look
                        char newCh = 't';
                        ReplacingLog("ValidateLine: rule 0270 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                        r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                        r->confidence += 500;
                        makeAnotherPass = true;   
                    } else {
                        // Eliminate
                        ReplacingLog("ValidateLine: rule 0271 replacing - eliminating smallish digit [%c] phone in word [%s]", (unsigned short)r->ch, toUTF8(r->word->text()).c_str());
                        SmartPtr<OCRRect> p = r->next;
                        r->word->removeLetter(r);
                        r = p;                        
                        // May create a situation where r now points to NULL yet the rest of the code really never assumes r is NULL
                        if (r == NULL) continue;
                    }
                }
            }
            
            // Test '7' width on top, to help decide regarding 1->7 replacements on this line
            if ((r->ch == '7') & (results->imageTests) && !(r->flags3 & FLAGS3_TESTED_AS_7)) {
                // Exclude abnormally wide 7's
                if ((round == 0) && (r->rect.size.width < statsWithoutCurrent->averageWidthDigits.average * 1.15)) {
                    SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                    if (st != NULL) {
                        SegmentList slTop = st->getHorizontalSegments(0.05, 0.10);
                        if (slTop.size() == 1) {
                            float widthTop = slTop[0].endPos - slTop[0].startPos + 1;
                            if (widthTop >= max7TopWidth) {
                                ReplacingLog("ValidateLine: found wide '7' in word [%s], w=%.0f", toUTF8(r->word->text()).c_str(), widthTop);
                                max7TopWidth = widthTop;
                                max7Width = r->rect.size.width;
                                makeAnotherPass = true; // So we can test other 7's
                            }
                        }
                        delete st;
                    }
                } else if ((round == 1) && (max7TopWidth > 0)) {
                    r->flags3 |= FLAGS3_TESTED_AS_7;
                    SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                    if (st != NULL) {
                        SegmentList slTop = st->getHorizontalSegments(0.05, 0.10);
                        if (slTop.size() == 1) {
                            float widthTop = slTop[0].endPos - slTop[0].startPos + 1;
                            if ((widthTop < max7TopWidth * 0.55) || ((widthTop < max7TopWidth) && (r->rect.size.width < max7Width * 0.65))) {
                                char newCh = '1';
                                ReplacingLog("ValidateLine: rule 0293 replacing - INVALID '7' in word [%s], it's a [%c]!!!", toUTF8(r->word->text()).c_str(), (unsigned short)newCh);
                                r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                                makeAnotherPass = true;
                            }
                        }
                        delete st;
                    }
                }
            }
            
            //2015-10-29 17:45:13.363 Windfall[17578:1169940] #680: 1 quality: 83 [348,490 - 354,508] w=6,h=19]
            //...
            //2015-10-29 17:45:13.383 Windfall[17578:1169940] #713: 4 quality: 81 [372,512 - 380,531] w=8,h=20]
            //2015-10-29 17:45:13.383 Windfall[17578:1169940] #714:   quality: 100 [380,512 - 477,531] w=97,h=20]
            //2015-10-29 17:45:13.383 Windfall[17578:1169940] #715: 4 quality: 82 [477,511 - 486,530] w=9,h=20]
            //2015-10-29 17:45:13.383 Windfall[17578:1169940] #716: . quality: 88 [491,525 - 496,529] w=5,h=5]
            //2015-10-29 17:45:13.384 Windfall[17578:1169940] #717: 9 quality: 76 [500,511 - 509,530] w=9,h=20]
            //2015-10-29 17:45:13.384 Windfall[17578:1169940] #718: 1 quality: 77 [511,511 - 520,530] w=9,h=20]

            //  0123456789abcdef########
            //  ------------------------
            //0|                        |
            //1|     1 11    1 11111111 |
            //2|   111 1111  1111111111 |
            //3|  1111  111  11     111 |
            //4|  111        11         |
            //5| 111         11         |
            //6| 11          11 11111   |
            //7| 111         111111111  |
            //8| 11111 111   1111  111  |
            //9| 1111  111   111    111 |
            //a| 111    111          11 |
            //b| 111     11          11 |
            //c| 11      11          11 |
            //d| 111     11          11 |
            //e| 111     11  11     111 |
            //f|  111   111  1111  1111 |
            //#|  1111 1111   11111111  |
            //#|   111 111     1111111  |
            //#|                        |
            //  ------------------------
            //2015-12-16 16:40:15.330 Windfall[12562:448739] #380: C quality: 72 [475,375 - 479,391] w=5,h=17]
            //2015-12-16 16:40:15.330 Windfall[12562:448739] #381: 5 quality: 85 [487,375 - 496,391] w=10,h=17]
            
            // Truncated 'C' instead of '6', see https://www.pivotaltracker.com/story/show/107245684
            if ((r->ch == 'C') && (results->imageTests) && !(r->flags3 & FLAGS3_TESTED_AS_6) && (results->globalStats.averageWidthDigits.count >= 8) && (r->rect.size.width < results->globalStats.averageWidthDigits.average * 0.80)) {
                r->flags3 |= FLAGS3_TESTED_AS_6;
                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                if (st != NULL) {
                    bool doit = true;
                    OpeningsTestResults topRight;
                    bool successTopRight = st->getOpenings(topRight,
                        SingleLetterTests::Right,
                        0.00,      // Start of range to search (top/left)
                        0.50,      // End of range to search (bottom/right)
                        SingleLetterTests::Bound,   // Require start (top/left) bound
                        SingleLetterTests::Bound);  // Require end (bottom/right) bound
                    if (!successTopRight)
                        doit = false;
                    else {
                        OpeningsTestResults bottomRight;
                        bool successBottomRight = st->getOpenings(bottomRight,
                            SingleLetterTests::Right,
                            0.50,      // Start of range to search (top/left)
                            1.00,      // End of range to search (bottom/right)
                            SingleLetterTests::Bound,   // Require start (top/left) bound
                            SingleLetterTests::Bound);  // Require end (bottom/right) bound
                        if (!successBottomRight)
                            doit = false;
                    }
                    CGRect rectOtherHalf;
                    CGRect newRect;
                    if (doit) {
                        // Look for the right side of the '6' belly
                        if ((r->next != NULL) && (r->next->ch != ' ')) {
                            rectOtherHalf = CGRect(rectRight(r->rect)+1, rectBottom(r->rect), rectLeft(r->next->rect) - rectRight(r->rect) - 1, r->rect.size.height);
                        } else {
                            rectOtherHalf = CGRect(rectRight(r->rect)+1, rectBottom(r->rect), r->rect.size.width, r->rect.size.height);
                            if (rectRight(rectOtherHalf) > results->imageRange.size.width)
                                doit = false;
                        }
                        if (rectOtherHalf.size.width < 1)
                            doit = false;
                    }
                    if (doit) {
                        SingleLetterTests *st1 = CreateSingleLetterTests(rectOtherHalf, results);
                        if (st1 != NULL) {
                            OpeningsTestResults bottomLeft;
                            bool successBottomLeft = st1->getOpenings(bottomLeft,
                                SingleLetterTests::Left,
                                0.25,      // Start of range to search (top/left)
                                1.00,      // End of range to search (bottom/right)
                                SingleLetterTests::Bound,   // Require start (top/left) bound
                                SingleLetterTests::Bound);  // Require end (bottom/right) bound
                            if (!successBottomLeft)
                                doit = false;
                            if (doit) {
                                // Determine the right side of the belly, to adjust rect
                                ConnectedComponentList cpl = st1->getConnectedComponents();
                                if (cpl.size() >= 2) {
                                    newRect = CGRect(rectLeft(r->rect), rectBottom(r->rect), rectLeft(rectOtherHalf) + cpl[1].xmax - rectLeft(r->rect) - 1, r->rect.size.height);
                                } else {
                                    newRect = CreateCombinedRect(r->rect, rectOtherHalf);
                                }
                            }
                            delete st1;
                        }
                    }
                    delete st;
                    if (doit) {
                        char newCh = '6';
                        ReplacingLog("ValidateLine: rule 0572 replacing [%c] with [%c] in word [%s]", r->ch, newCh, toUTF8(r->word->text()).c_str());
                        r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                        makeAnotherPass = true;
                    }
                }
            }
            
#if DEBUG
            if ((r->ch == '1') && (r->next != NULL) && (r->next->ch == '1') && (r->previous != NULL) && (r->previous->ch=='9')) {
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
                DebugLog("Found in word [%s]", toUTF8(r->word->text()).c_str());
                if (st != NULL) delete st;
            }
#endif
            
            //  --------------
            //0|              |
            //1|  1        11 |
            //2|  11       11 |
            //3| 111       11 |
            //4| 1111      11 |
            //5| 1111      11 |
            //6| 1111      11 |
            //7| 111       11 |
            //8| 11  1     11 |
            //9| 11  11    11 |
            //a| 11  11    11 |
            //b| 11  111   11 |
            //c| 11   11   11 |
            //d| 11   11   11 |
            //e| 11    1   11 |
            //f| 11    11  11 |
            //#| 11    111111 |
            //#| 11     11111 |
            //#| 11      1111 |
            //#| 11      1111 |
            //#| 11       111 |
            //#| 11        1  |
            //#|              |
            //  --------------

            //  --------------
            //0|              |
            //1| 11       111 |
            //2| 11       111 |
            //3| 111      111 |
            //4| 111      111 |
            //5| 1111     111 |
            //6| 1111     11  |
            //7| 1111     11  |
            //8| 11 1     11  |
            //9| 11       11  |
            //a| 11  11   111 |
            //b| 11   11  111 |
            //c| 11   11  111 |
            //d| 11    11 111 |
            //e| 11     11111 |
            //f| 11     11111 |
            //#| 11      1111 |
            //#| 11      1111 |
            //#| 11      1111 |
            //#| 111      111 |
            //#| 11        1  |
            //#|              |
            //  --------------

            
            // "11" instead of 'N' //PQ911
            if (isVerticalLine(r->ch) && (r->next != NULL) && isVerticalLine(r->next->ch) && (results->imageTests) && !(r->flags6 & FLAGS6_TESTED_AS_N) &&(rectSpaceBetweenRects(r->rect, r->next->rect) <= r->rect.size.height *0.05) && (rectRight(r->next->rect) - rectLeft(r->rect) + 1 > results->globalStats.averageWidthDigits.average * 0.85) && (rectRight(r->next->rect) - rectLeft(r->rect) + 1 < results->globalStats.averageWidthDigits.average * 1.15)) {
                r->flags6 |= FLAGS6_TESTED_AS_N;
                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
                if (st != NULL) {
                    SegmentList slTop = st->getHorizontalSegments(0.125, 0.25);
                    SegmentList slBottom = st->getHorizontalSegments(0.875, 0.25);
                    if ((slTop.size() == 2) && (slBottom.size() == 2)
                        && (slTop[0].endPos - slTop[0].startPos > slTop[1].endPos - slTop[1].startPos)
                        && (slBottom[1].endPos - slBottom[1].startPos > slBottom[0].endPos - slBottom[0].startPos)) {
                        bool doit = true;
                        float sumIndentations = 0;
                        // Careful not to just take 50% of height, to make sure we don't trucate one of the gaps, see https://drive.google.com/open?id=0B4jSQhcYsC9VMkZRdzctN3V0WWs
                        CGRect topHalfRect = CGRect(rectLeft(combinedRect), rectBottom(combinedRect), r->rect.size.width, combinedRect.size.height * 0.60);
                        CGRect bottomHalfRect = CGRect(rectLeft(r->next->rect), rectBottom(combinedRect) + combinedRect.size.height * 0.40, r->next->rect.size.width, combinedRect.size.height * 0.60);
                        SingleLetterTests *stTopHalf = CreateSingleLetterTests(topHalfRect, results);
                        if (stTopHalf == NULL)
                            doit = false;
                        else {
                            OpeningsTestResults topUp;
                            bool successTopUp = stTopHalf->getOpenings(topUp,
                                SingleLetterTests::Bottom,
                                0.00,      // Start of range to search (top/left)
                                1.00,      // End of range to search (bottom/right)
                                SingleLetterTests::Bound,   // Require start (top/left) bound
                                SingleLetterTests::Bound);  // Require end (bottom/right) bound
                            if (successTopUp)
                                sumIndentations += topUp.maxDepth;
                            delete stTopHalf;
                        }
                        if (doit) {
                            SingleLetterTests *stBottomHalf = CreateSingleLetterTests(bottomHalfRect, results);
                            if (stBottomHalf == NULL)
                                doit = false;
                            else {
                                OpeningsTestResults bottomDown;
                                bool successBottomDown = stBottomHalf->getOpenings(bottomDown,
                                    SingleLetterTests::Top,
                                    0.00,      // Start of range to search (top/left)
                                    1.00,      // End of range to search (bottom/right)
                                    SingleLetterTests::Bound,   // Require start (top/left) bound
                                    SingleLetterTests::Bound);  // Require end (bottom/right) bound
                                if (successBottomDown)
                                    sumIndentations += bottomDown.maxDepth;
                                delete stBottomHalf;
                            }
                        }
                        if (doit && (sumIndentations >= combinedRect.size.height * 0.25)) {
                            replaceTwo(r, 'N', "rule 0573");
                            makeAnotherPass = true;
                        }
                    } // segments top/bottom make sense
                    delete st;
                } // st != NULL
            }


//  0123456789ab
//  ------------
//0|            |
//1|  111111    |
//2| 1111111    |
//3| 111111  1  |
//4| 111     1  |
//5| 111     1  |
//6|  1     11  |
//7|        111 |
//8|      1 11  |
//9|      11 1  |
//a|     111    |
//b|     111    |
//c|     111    |
//d|     111    |
//e|     11     |
//f|     11     |
//#|  11 1      |
//#|  11 1      |
//#| 111111     |
//#| 1111111 11 |
//#| 1111111 11 |
//#| 111111  1  |
//#|            |
//  ------------
//  0123456789ab
//2015-12-15 18:57:52.528 Windfall[7206:216538] #240: I quality: 70 [532,175 - 535,195] w=4,h=21]
//2015-12-15 18:57:52.528 Windfall[7206:216538] #241: Z quality: 73 [535,175 - 541,195] w=7,h=21]
//2015-12-15 18:57:52.528 Windfall[7206:216538] #242: . quality: 92 [549,190 - 553,195] w=5,h=6]
//2015-12-15 18:57:52.528 Windfall[7206:216538] #243: 5 quality: 81 [560,173 - 570,194] w=11,h=22]
//2015-12-15 18:57:52.528 Windfall[7206:216538] #244: 3 quality: 68 [578,173 - 584,194] w=7,h=22]

    // "IZ" instead of 'Z'
    if ((r->ch == 'I') && (r->next != NULL) && (r->next->ch == 'Z') && (rectSpaceBetweenRects(r->rect, r->next->rect) <= 0) && (results->imageTests) && !(r->flags3 & FLAGS3_TESTED_AS_Z)) {
        CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
        if ((results->globalStats.averageWidthDigits.count >= 8) && (combinedRect.size.width > results->globalStats.averageWidthDigits.average * 0.85)) {
            r->flags3 |= FLAGS3_TESTED_AS_Z;
            SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
            if (st != NULL) {
                SegmentList slLeftSide = st->getVerticalSegments(0.10, 0.10);
                SegmentList slTop = st->getHorizontalSegments(0.20, 0.01);
                SegmentList slBottom = st->getHorizontalSegments(0.80, 0.01);
                if ((slLeftSide.size() == 2) && (slTop.size() >= 1) && (slBottom.size() >= 1)
                    && (slLeftSide[1].startPos - slLeftSide[0].endPos > combinedRect.size.height * 0.20)
                    && (slTop[slTop.size()-1].endPos - slBottom[slTop.size()-1].endPos > combinedRect.size.width * 0.15)) {
                    replaceTwo(r, 'Z', "rule 0571");
					makeAnotherPass = true;
                }
                delete st;
            }
        }
    }


//2015-12-15 16:18:05.957 Windfall[3785:143974] #450: 1 quality: 85 [541,428 - 549,446] w=9,h=19]
//2015-12-15 16:18:05.957 Windfall[3785:143974] #451: 4 quality: 77 [553,427 - 564,446] w=12,h=20]
//2015-12-15 16:18:05.957 Windfall[3785:143974] #452: / quality: 72 [570,426 - 576,446] w=7,h=21]
//  0123456
//  -------
//0|       |
//1|     1 |
//2|     1 |
//3|    11 |
//4|   111 |
//5|  111  |
//6|  111  |
//7|  111  |
//8|  11   |
//9|  11   |
//a|  11   |
//b|       |
//c|       |
//d|       |
//e|    1  |
//f|  111  |
//#| 1111  |
//#| 111   |
//#|       |
//  -------
//  0123456
// TO BE DONE - see https://www.pivotaltracker.com/story/show/110198074


//#if DEBUG
//            // 6715971
//            if ((r->ch=='1') && (r->previous != NULL) && (r->previous->ch=='1') && (r->previous->previous != NULL) && (r->previous->previous->ch == '3')) {
//                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results); if (st != NULL) delete st;
//                DebugLog("Found in word [%s]!", toUTF8(r->word->text()).c_str());
//                DebugLog("");
//            }
//#endif
            if (isVerticalLine(r->ch)
                && ((r->next == NULL)
                    || ((r->next->ch != ' ') && (rectRight(r->next->rect) - rectLeft(r->rect) > results->globalStats.averageWidthDigits.average * 1.15))
                    || ((r->next->ch == ' ') && ((r->next->next == NULL)
                                                || ((rectRight(r->next->next->rect) - rectLeft(r->rect) > results->globalStats.averageWidthDigits.average * 1.15)))))
                    && (results->imageTests) && !(r->flags4 & FLAGS4_TESTED_AS_DISCONNECTED_DIGIT7)) {
                r->flags4 |= FLAGS4_TESTED_AS_DISCONNECTED_DIGIT7;
                // Grab possible pixels to the right
                CGRect largerRect = r->rect;
                float highestX = 0;
                if (r->next != NULL) {
                    if (r->next->ch != ' ')
                        highestX = rectLeft(r->next->rect) - 1;
                    else if ((r->next->next != NULL) && (r->next->next->ch != ' '))
                        highestX = rectLeft(r->next->next->rect) - 1;
                }
                if (highestX > 0) {
                    float newWidth = highestX - rectLeft(largerRect) + 1;
                    if (newWidth > results->globalStats.averageWidthDigits.average * 1.15)
                        largerRect.size.width = results->globalStats.averageWidthDigits.average * 1.15;
                    else
                        largerRect.size.width = newWidth;
                } else {
                    largerRect.size.width = results->globalStats.averageWidthDigits.average * 1.15;
                    if (rectRight(largerRect) > rectRight(results->imageRange))
                        largerRect.size.width = rectRight(results->imageRange) - rectLeft(largerRect) + 1;
                }
                if (largerRect.size.width > results->globalStats.averageWidthDigits.average * 0.85) {
                    CGRect trimmedRect = computeTrimmedRect(largerRect, results);
                    if (trimmedRect.size.width > results->globalStats.averageWidthDigits.average * 0.85) {
                        wchar_t newCh = testAsDisconnectedDigit(r, trimmedRect, statsWithoutCurrent, results, '7', '\0', true);
                        if (newCh != '\0') {
                            ReplacingLog("ValidateLine: rule 0606 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)newCh, toUTF8(r->word->text()).c_str());
                            r->word->updateLetterWithNewCharAndNewRect(r, newCh, trimmedRect);
                            makeAnotherPass = true;
                        }
                    }
                }
            }
      
            // '1' instead of '7' - a common mistake.
            if ((r->ch == '1') & (results->imageTests) && !(r->flags3 & FLAGS3_TESTED_AS_7)
                // Test only '1' that are too wide relative to height to really be a '1'
                // Walmart receipt 1/22/2016 where bad '1' had w=5/h=11
                && ((r->rect.size.width > r->rect.size.height * 0.45)
                  || ((results->globalStats.averageWidthDigit1.count > 2) && (results->globalStats.averageWidthDigits.count > 2) && (results->globalStats.averageWidthDigits.average > results->globalStats.averageWidthDigit1.average * 1.40) && (statsWithoutCurrent->averageWidthDigits.count >= 2) && (r->rect.size.width > statsWithoutCurrent->averageWidthDigits.average * 0.85)))) {
                if (round == 0) {
                    makeAnotherPass = true;
                } else {
                    r->flags3 |= FLAGS3_TESTED_AS_7;
                    SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                    if (st != NULL) {
                    
                        bool doit = true;
                    
                        // Leave it alone is top is much narrower than a '7' on this line
                        if (max7TopWidth > 0) {
                            SegmentList slTop = st->getHorizontalSegments(0.05, 0.10);
                            if (slTop.size() == 1) {
                                float widthTop = slTop[0].endPos - slTop[0].startPos + 1;
                                if (widthTop < max7TopWidth * 0.50) {
                                    // Abort!
                                    doit = false;
                                }
                            }
                        }
                    
                        //  -------
                        //0|       |
                        //1|  1111 |
                        //2| 11111 |
                        //3|    11 |
                        //4|    11 |
                        //5|    11 |
                        //6|   11  |
                        //7|   11  |
                        //8|   11  |
                        //9|   11  |
                        //a|   11  |
                        //b|   11  |
                        //c|       |
                        //  -------
                        if (doit) {
                            // Adjusting 0.90 to 0.80 because of pattern above
                            bool hasTop = st->getSide(SingleLetterTests::Top, 0.79, true);
                            if (hasTop) {
                                // Also verify that the bottom part is not aligned right
                                SegmentList slBottom = st->getHorizontalSegments(0.95, 0.10);
                                if (slBottom.size() >= 1) {
                                    Segment lastSegment = slBottom[slBottom.size() - 1];
                                    if (lastSegment.endPos < r->rect.size.width * 0.80) {
                                        char newCh = '7';
                                        
                                        // One more check! 1 instead of T - check that top/right is narrow (i.e. there is a right branch like a T)
                                        SegmentList stTopRight = st->getVerticalSegments(0.95, 0.01);
                                        if ((stTopRight.size() == 1) && (stTopRight[0].endPos - stTopRight[0].startPos < r->rect.size.height * 0.20)) {
                                            // Now check if we have an intersection in the middle along 3 points => vertical bar of the T
                                            float bottomMidpoint = (lastSegment.startPos + lastSegment.endPos) / 2;
                                            float minX = r->rect.size.width * 0.35;
                                            float maxX = r->rect.size.width * 0.65;
                                            if ((bottomMidpoint > minX) && (bottomMidpoint < maxX)) {
                                                SegmentList slTop = st->getHorizontalSegments(0.20, 0.01);
                                                SegmentList slMiddle = st->getHorizontalSegments(0.50, 0.01);
                                                if ((slTop.size() == 1) && (slMiddle.size() == 1)) {
                                                    // If middle segment is more or less same left alignment as bottom. Shifted 3 pixels right out of width 14 (21%) for a '7'
                                                    float shiftRight = slMiddle[0].startPos - lastSegment.startPos;
                                                    if (shiftRight <= r->rect.size.width * 0.18) {
                                                        float topMidpoint = (slTop[0].startPos + slTop[0].endPos) / 2;
                                                        float middleMidpoint = (slMiddle[0].startPos + slMiddle[0].endPos) / 2;
                                                        if ((topMidpoint > minX) && (topMidpoint < maxX) && (middleMidpoint > minX) && (middleMidpoint < maxX)) {
                                                            newCh = 'T';
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        ReplacingLog("ValidateLine: rule 0272 replacing - INVALID '1' in word [%s], it's a [%c]!!!", toUTF8(r->word->text()).c_str(), (unsigned short)newCh);
                                        r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                                        makeAnotherPass = true;
                                    }
                                }
                            } // hasTop
                        } // doit
                        delete st;
                    }
                } // 2nd pass
            }
            
            // '1' instead of '4', see https://www.pivotaltracker.com/n/projects/1118860/stories/110006454
            
            //  0123456789ab
            //  ------------
            //0|            |
            //1|         11 |
            //2|        111 |
            //3|       1111 |
            //4|      11111 |
            //5|    1111111 |
            //6|   1111  11 |
            //7|  111    11 |
            //8| 1111    11 |
            //9| 111     11 |
            //a| 111     11 |
            //b| 11111  111 |
            //c| 1111111111 |
            //d| 11   11111 |
            //e|        111 |
            //f|        111 |
            //#|        111 |
            //#|         11 |
            //#|        111 |
            //#|        111 |
            //#|         11 |
            //#|         11 |
            //#|         11 |
            //#|            |
            //  ------------
            //  0123456789ab
            //2015-12-12 10:32:28.658 Windfall[39096:9311214] #88: 2 quality: 92 [623,169 - 636,192] w=14,h=24]
            //2015-12-12 10:32:28.658 Windfall[39096:9311214] #89: 1 quality: 70 [640,171 - 649,192] w=10,h=22]
            //2015-12-12 10:32:28.658 Windfall[39096:9311214] #90: . quality: 87 [659,191 - 661,194] w=3,h=4]
            //2015-12-12 10:32:28.659 Windfall[39096:9311214] #91: 9 quality: 83 [669,173 - 680,195] w=12,h=23]
            //2015-12-12 10:32:28.659 Windfall[39096:9311214] #92: 9 quality: 66 [685,174 - 696,196] w=12,h=23]
            
            //  ----------
            //0|          |
            //1|      111 |
            //2|     1111 |
            //3|    11111 |
            //4|   111111 |
            //5|  1111111 |
            //6| 1111  11 |
            //7| 1111  11 |
            //8| 11111111 |
            //9| 11111111 |
            //a|  1   111 |
            //b|      111 |
            //c|      111 |
            //d|      111 |
            //e|      111 |
            //f|      111 |
            //#|       1  |
            //#|          |
            //  ----------
            // See https://drive.google.com/open?id=0B4jSQhcYsC9VcTZUWG53MXdfODQ Walmart for multiple examples
            
#if DEBUG
            if ((r->ch=='1') && (r->next != NULL) && (r->next->ch=='7') && (r->previous != NULL) && (r->previous->ch == '.')) {
                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results); if (st != NULL) delete st;
                DebugLog("Found in word [%s]!", toUTF8(r->word->text()).c_str());
                DebugLog("");
            }
#endif
            
            //  ---------
            //0|         |
            //1|      11 |
            //2|      11 |
            //3|     111 |
            //4|    1111 |
            //5|  111 11 |
            //6|  11  11 |
            //7| 11   11 |
            //8| 111 111 |
            //9| 1111111 |
            //a|      11 |
            //b|      11 |
            //c|      11 |
            //d|      11 |
            //e|      11 |
            //f|      11 |
            //#|         |
            //  ---------
            // width = 7 vs average 8.49 (82%) so lowering usual 85% req to 80%, see https://drive.google.com/open?id=0B4jSQhcYsC9VTlJaWkFyRFlRQ00
            if ((r->ch == '1') && (results->imageTests) && !(r->flags2 & FLAGS2_TESTED_AS_4)) {
                CGRect rect;
                bool proceedWithTest = false;
                if ((results->globalStats.averageWidthDigit1.count > 4) && (r->rect.size.width > results->globalStats.averageWidthDigit1.average * 1.15) && ((r->rect.size.width > results->globalStats.averageWidthDigits.average * 0.80))) {
                    rect = r->rect; proceedWithTest = true;
                } else {
                    rect = computeCapturingRectLeft(r, statsWithoutCurrent, results);
                    if ((rect.size.width > r->rect.size.width) && (results->globalStats.averageWidthDigit1.count > 4) && (rect.size.width > results->globalStats.averageWidthDigit1.average * 1.15)
                        // Use lower threshhold because the fact that we got a new rect indicates something is fishy
                        && ((rect.size.width > results->globalStats.averageWidthDigits.average * 0.75))) {
                        proceedWithTest = true;
                    }
                }
                if (proceedWithTest) {
                    r->flags2 |= FLAGS2_TESTED_AS_4;
                    SingleLetterTests *st = CreateSingleLetterTests(rect, results);
                    if (st != NULL) {
                        //  ----------
                        //0|          |
                        //1|      11  |
                        //2|     1111 |
                        //3|    11111 |
                        //4|   111111 |
                        //5|  1111111 |
                        //6| 1111 111 |
                        //7| 1111 111 |
                        //8| 11111111 |
                        //9| 11111111 |
                        //a|  11 1111 |
                        //b|      111 |
                        //c|      111 |
                        //d|      111 |
                        //e|      111 |
                        //f|      111 |
                        //#|       1  |
                        //#|          |
                        //  ----------
                        // Found in https://drive.google.com/open?id=0B4jSQhcYsC9VcTZUWG53MXdfODQ, first TOTINOS product
                        // Reducing size requirement of hole from 0.03 default for the above
                        ConnectedComponentList invertCpl = st->getInverseConnectedComponents(false, 0.015);
                        if (invertCpl.size() == 2) {
                            // The presence of any hole suffices
                            //if (invertCpl[1].getWidth() > r->rect.size.width * 0.25) {
                            // Check much wider at mid-point compared to bottom
                            SegmentList slMiddle = st->getHorizontalSegments(0.40, 0.05);
                            SegmentList slBottom = st->getHorizontalSegments(0.95, 0.05);
                            if ((slMiddle.size() >= 1) && (slBottom.size() == 1)) {
                                float middleWidth = slMiddle[slMiddle.size()-1].endPos - slMiddle[0].startPos + 1;
                                float bottomWidth = slBottom[0].endPos - slBottom[0].startPos + 1;
                                //  -----------
                                //0|           |
                                //1|       11  |
                                //2|      1111 |
                                //3|     1111  |
                                //4|    11111  |
                                //5|   111111  |
                                //6|  1111111  |
                                //7| 1111 111  |
                                //8| 1111 111  |
                                //9| 11111111  |
                                //a| 11111111  |
                                //b| 11111111  |
                                //c|      111  |
                                //d|      111  |
                                //e|      111  |
                                //f|      111  |
                                //#|      111  |
                                //#|      111  |
                                //#|      11   |
                                //#|           |
                                //  -----------
                                // 2016-02-23 accept width=8 versus rect width=9 (see above)
                                if ((middleWidth >= rect.size.width * 0.87) && (middleWidth > bottomWidth * 2)) {
                                    char newCh = '4';
                                    ReplacingLog("ValidateLine: rule 0570 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)newCh, toUTF8(r->word->text()).c_str());
                                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                                    makeAnotherPass = true;
                                }
                            }
                        }
                        delete st;
                    }
                } // proceed with test
            }
            // '1' instead of 'J'
            if ((r->ch == '1') & (results->imageTests) && !(r->flags2 & FLAGS2_TESTED_AS_J)
                // Test only '1' that are too wide relative to height to really be a '1'
                && (r->rect.size.width > r->rect.size.height * 0.30)) {
                if (round == 0) {
                    makeAnotherPass = true;
                } else {
                    r->flags2 |= FLAGS2_TESTED_AS_J;
                    SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                    if (st != NULL) {
                        bool doit = true;
                        
                        // Bottom must be much wider than middle (leg of the 'J')
                        SegmentList slBottom = st->getHorizontalSegments(0.95, 0.10);
                        SegmentList slMiddle = st->getHorizontalSegments(0.50, 0.10);
                        
                        if ((slMiddle.size() != 1) || (slBottom.size() != 1) || (slBottom[0].endPos - slBottom[0].startPos + 1 < (slMiddle[0].endPos - slMiddle[0].startPos + 1) * 2)) {
                            doit = false;
                        }
                        
                        if (doit) {
                            // Test for deep opening bottom left no such thing bottom right
                            OpeningsTestResults bottomLeft;
                            bool successBottomLeft = st->getOpenings(bottomLeft,
                                SingleLetterTests::Left,
                                0.70,      // Start of range to search (top/left)
                                1.00,      // End of range to search (bottom/right)
                                SingleLetterTests::Unbound,   // Require start (top/left) bound
                                SingleLetterTests::Bound);  // Require end (bottom/right) bound
                            if (!successBottomLeft || (bottomLeft.maxDepth < r->rect.size.width * 0.30)) {
                                doit = false;
                            }
                            if (doit) {
                                OpeningsTestResults bottomRight;
                                bool successBottomRight = st->getOpenings(bottomRight,
                                    SingleLetterTests::Right,
                                    0.70,      // Start of range to search (top/left)
                                    1.00,      // End of range to search (bottom/right)
                                    // Important: ask for any bound type above, to catch italic '1' where call would fail if asking unbound on top
                                    SingleLetterTests::Any,   // Require start (top/left) bound
                                    SingleLetterTests::Bound);  // Require end (bottom/right) bound
                                if (successBottomRight
                                        // Either too deep relative to width of rect, or just deeper than 40% of the opening on the left side
                                        && ((bottomRight.maxDepth > r->rect.size.width * 0.10) || (bottomRight.maxDepth > bottomLeft.maxDepth * 0.40))) {
                                    doit = false;
                                }
                            }
                        }
                    
                        if (doit) {
                            char newCh = 'J';
                            ReplacingLog("ValidateLine: rule 0295 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)newCh, toUTF8(r->word->text()).c_str());
                            r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                            makeAnotherPass = true;
                        } // doit
                        delete st;
                    } // st != NULL
                } // 2nd pass
            }
            
            // 'o' instead of 'a'
            if ((r->ch == 'o') && results->imageTests && !(r->flags4 & FLAGS4_TESTED_RIGHT_BAR) && !lineHasRealAs
                && ((r->previous == NULL) || (r->previous->ch == ' ') || (rectSpaceBetweenRects(r->previous->rect, r->rect) > 0)) 
                && ((r->next == NULL) || (r->next->ch == ' ') || (rectSpaceBetweenRects(r->rect, r->next->rect) > 0))) 
            {
                if (round == 0) {
                    makeAnotherPass = true;
                } else {
                    char newCh = SingleLetterTestoAsa(r, results);
                    if ((newCh != 'o') && (newCh != '\0')) {
                        ReplacingLog("ValidateLine: round a replacing [%c] with [%c] in word [%s]!", (char)r->ch, newCh, toUTF8(r->word->text()).c_str());
                        r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                        makeAnotherPass = true;
                    }
                }
            }
            
//#if DEBUG
//            if ((r->ch == 'l') && (r->next != NULL) && (r->next->ch == 'p')) {
//                DebugLog("Found");
//            }
//#endif


            //2015-10-31 20:25:07.965 Windfall[23278:1557259] #179: $ quality: 87 [488,215 - 499,236] w=11,h=22]
            //2015-10-31 20:25:07.965 Windfall[23278:1557259] #180: 2 quality: 87 [501,216 - 512,235] w=11,h=20]
            //2015-10-31 20:25:07.965 Windfall[23278:1557259] #181: / quality: 71 [515,215 - 523,234] w=8,h=20]
            //2015-10-31 20:25:07.965 Windfall[23278:1557259] #182: 9 quality: 78 [526,216 - 536,233] w=10,h=18]
            //2015-10-31 20:25:07.965 Windfall[23278:1557259] #183: 9 quality: 57 [538,214 - 549,232] w=11,h=19]
            //  0123456789
            //  ----------
            //0|          |
            //1|        1 |
            //2|       11 |
            //3|       11 |
            //4|       11 |
            //5|      11  |
            //6|      11  |
            //7|      11  |
            //8|     111  |
            //9|   1111   |
            //a|  1111    |
            //b|  1       |
            //c| 11       |
            //d|          |
            //e|          |
            //f|          |
            //#|          |
            //#|    11    |
            //#|   111    |
            //#|   111    |
            //#|    1     |
            //#|          |
            //  ----------
            //  0123456789
            
//#if DEBUG
//            if ((r->ch == '/') && (r->next != NULL) && (r->next->ch=='9') && (r->previous != NULL) && (r->previous->ch=='2')) {
//                DebugLog("Found in [%s]", toUTF8(line->text()).c_str());
//                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
//                if (st != NULL)
//                    delete st;
//            }
//#endif
            
            // '/' instead of '.' in price
            if ((r->ch == '/') && (!(r->flags5 & FLAGS5_TESTED_AS_DOT)) && (r->next != NULL) && isDigitLookalikeExtended(r->next->ch) && (r->next->next != NULL) && isDigitLookalikeExtended(r->next->next->ch)) {
                // Also check that to the left of the suspected dot we have only digits - and before that a $ if retailer has them
                bool foundOneDigit = false;
                bool doit = true;
                OCRRectPtr p = r->previous;
                while (p != NULL) {
                    if (!isDigitLookalikeExtended(p->ch)) {
                        if (p->ch == '$') {
                            if (results->retailerParams.pricesHaveDollar) {
                                if (!((p->previous == NULL) || (p->previous->ch == ' ')))
                                    doit = false;
                            } else
                                doit = false;
                            break;
                        } else if (p->ch == ' ') {
                            if (!foundOneDigit)
                                doit = false;
                            break;
                        } else {
                            doit = false;
                            break;
                        }
                    } else {
                        foundOneDigit = true;
                    }
                    p = p->previous;
                }
                if (doit) {
                    // Check if the dash is composed of multiple connected comps, one of which a possible dot
                    CGRect refRect = r->next->rect;
                    r->flags5 |= FLAGS5_TESTED_AS_DOT;
                    SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                    if (st != NULL) {
                        ConnectedComponentList cl = st->getConnectedComponents();
                        if (cl.size() >= 3) {
                            bool gotDot = false;
                            CGRect dotRect;
                            for (int i=1; i<cl.size(); i++) {
                                ConnectedComponent cc = cl[i];
                                dotRect.origin.x = rectLeft(r->rect) + cc.xmin;
                                dotRect.origin.y = rectBottom(r->rect) + cc.ymin;
                                dotRect.size.width = cc.getWidth();
                                dotRect.size.height = cc.getHeight();
                                // Check dot is wide enough, not too wide and start past the 60% mark of ref rect (next digit)
                                if ((dotRect.size.width > refRect.size.width * 0.15) && (dotRect.size.width < refRect.size.width * 0.60) && (rectBottom(dotRect) > (rectBottom(refRect) + refRect.size.height * 0.60))) {
                                    gotDot = true;
                                    break;
                                }
                            }
                            if (gotDot) {
                                char newCh = '.';
                                ReplacingLog("ValidateLine: rule 0562 replacing [%c] with [%c] in word [%s]", r->ch, newCh, toUTF8(r->word->text()).c_str());
                                r->word->updateLetterWithNewCharAndNewRect(r, newCh, dotRect);
                                makeAnotherPass = true;
                                delete st;
                                r = r->next; continue;
                            }
                        }
                        delete st;
                    }
                }
            }
            
            //2015-10-31 21:06:41.414 Windfall[23802:1577107] #275: $ quality: 88 [490,305 - 501,326] w=11,h=22]
            //2015-10-31 21:06:41.414 Windfall[23802:1577107] #276: 2 quality: 86 [504,306 - 514,324] w=10,h=19]
            //2015-10-31 21:06:41.414 Windfall[23802:1577107] #277: . quality: 85 [520,321 - 523,325] w=3,h=5]
            //2015-10-31 21:06:41.414 Windfall[23802:1577107] #278: / quality: 48 [528,310 - 533,319] w=5,h=10]
            //2015-10-31 21:06:41.414 Windfall[23802:1577107] #279: 1 quality: 75 [535,306 - 539,324] w=4,h=19]
            //2015-10-31 21:06:41.415 Windfall[23802:1577107] #280: 9 quality: 89 [541,306 - 551,324] w=10,h=19]
            
//#if DEBUG
//            if ((r->ch == '/') && (r->next != NULL) && (r->next->ch=='1') && (r->previous != NULL) && (r->previous->ch=='.')) {
//                DebugLog("Found in [%s]", toUTF8(line->text()).c_str());
//                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
//                if (st != NULL)
//                    delete st;
//                CGRect combinedRect = CreateCombinedRect(r->rect, r->next->rect);
//                st = CreateSingleLetterTests(combinedRect, results);
//                if (st != NULL)
//                    delete st;
//            }
//#endif
        
        
            OCRVerboseLog("OCRValidate: about to check rule 0019");
            // Testing diminutive 'l' or 'l' with a dot in the rect returned (and diminutive stem).
            if ((r->ch == 'l') && (results->imageTests) && !(r->flags & FLAGS6_TESTED_AS_i)) {
                r->flags6 |= FLAGS6_TESTED_AS_i;
                
                CGRect actualRect = r->rect;
                // If 'l' is abnormally low, augment the rect we are going to use to test, to capture a possible lost dot above
                if ((tallHeightTest(statsWithoutCurrent.getPtr(), r->rect.size.height, 0, false, 3, true) == 0)
                    && (maxHeightForSingleLetter > r->rect.size.height)) {
                    actualRect.origin.y = rectTop(r->rect) - maxHeightForSingleLetter + 1;
                    actualRect.size.height = maxHeightForSingleLetter;
                }
                
                wchar_t newCh = SingleLetterTestAsi(r, actualRect, statsWithoutCurrent, results);
                
                if (newCh == 'i') {
                    if (newCh != r->ch) {
                        ReplacingLog("ValidateLine: rule 0019 replacing [%c] with [%c] in word [%s]!", (char)r->ch, newCh, toUTF8(r->word->text()).c_str());
                        r->word->updateLetterWithNewCharAndNewRect(r, newCh, actualRect);
                        makeAnotherPass = true;
                    }
                    r->confidence = 0; // Protect it from single-letter testing
                }
            }
            
            // '~' instead of '-'
            else if ((r->ch == '~') && (results->imageTests) && (round == 0))
            {
                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results, true, SINGLE_LETTER_VALIDATE_COMP_SIZE | SINGLE_LETTER_VALIDATE_SINGLE_COMP);
                if (st != NULL) {
                    bool validTilde = false;
                    // Require a little notch below-left and above-right
                    OpeningsTestResults bottom;
                    bool success = st->getOpenings(bottom, 
                        SingleLetterTests::Bottom, 
                        0.00,      // Start of range to search (top/left)
                        0.50,      // End of range to search (bottom/right)
                        SingleLetterTests::Bound,   // Require start (top/left) bound
                        SingleLetterTests::Bound);  // Require end (bottom/right) bound
                    if (success && (bottom.maxDepth > r->rect.size.height * 0.20)) {
                        // Require a little notch above-right
                        OpeningsTestResults top;
                        bool success = st->getOpenings(top, 
                            SingleLetterTests::Top, 
                            0.50,      // Start of range to search (top/left)
                            1.00,      // End of range to search (bottom/right)
                            SingleLetterTests::Bound,   // Require start (top/left) bound
                            SingleLetterTests::Bound);  // Require end (bottom/right) bound
                        if (success && (top.maxDepth > r->rect.size.height * 0.20)) {
                            validTilde = true;
                        }
                    }
                    delete st;
                            
                    if (!validTilde) {
                        char newCh = '-';
                        ReplacingLog("ValidateLine: rule 0072 replacing [%c] with [%c] in word [%s]!", (char)r->ch, newCh, toUTF8(r->word->text()).c_str());
                        r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                        makeAnotherPass = true;
                    }
                } // st != NULL
            }
            // * instead of -
            // [* (0x2a)] at [317,83 - 329,91] [w=13,h=9]
            else if ((r->ch == '*') && (r->rect.size.width > r->rect.size.height * 1.35) && (results->imageTests) && (round == 0))
            {
                bool doit = true;
                float gap = gapAboveToplineOfNeighbors(r, -1, false, true);
                // A dash must be at least 20% below top of neigboring letters
                if ((gap > -900) && (gap > - 0.20)) {
                    doit = false;
                }
                if (doit) {
                    SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                    if (st != NULL) {
                        // Require a little notch below and above
                        OpeningsTestResults bottom;
                        bool success = st->getOpenings(bottom, 
                            SingleLetterTests::Bottom, 
                            0.10,      // Start of range to search (top/left)
                            0.90,      // End of range to search (bottom/right)
                            SingleLetterTests::Bound,   // Require start (top/left) bound
                            SingleLetterTests::Bound);  // Require end (bottom/right) bound
                        if (success && (bottom.maxDepth > r->rect.size.height * 0.20)) {
                            doit = false;
                        }
                        if (doit) {
                            // Require a little notch abovet
                            OpeningsTestResults top;
                            bool success = st->getOpenings(top, 
                                SingleLetterTests::Top, 
                                0.10,      // Start of range to search (top/left)
                                0.90,      // End of range to search (bottom/right)
                                SingleLetterTests::Bound,   // Require start (top/left) bound
                                SingleLetterTests::Bound);  // Require end (bottom/right) bound
                            if (!success && (top.maxDepth > r->rect.size.height * 0.20)) {
                                doit = false;
                            }
                        }
                        delete st;
                                
                        if (doit) {
                            char newCh = '-';
                            ReplacingLog("ValidateLine: rule 0074 replacing [%c] with [%c] in word [%s]!", (char)r->ch, newCh, toUTF8(r->word->text()).c_str());
                            r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                            makeAnotherPass = true;
                        }
                    } // st != NULL
                } // doit
            } // false '*'

            // end of huge validate loop

			if (r != NULL) r = r->next;
		}
		if (statsWithoutCurrent != NULL)
			statsWithoutCurrent.setNull();
		if (statsWithoutCurrentAndNextTwo != NULL)
			statsWithoutCurrentAndNextTwo.setNull();
	} // for round

	if (line->letters.size() < 1)
		return;
	r = line->letters[0];
    
    // Test for situations where a space is obviously MISSING
    
	if (line->letters.size() < 1)
		return;
    
    // Special detection for lines where all letters are spaced
    r = line->letters[0];
    r = r->next;
    bool spacedLine = false;
    float minSpace = 10000;
    int countSpacingBetweenLetters = 0;
    if (line->averageHeight.count >= 3) {
        while ((r != NULL) && (r->ch != '\n')) {
            // Look ahead to determine if we are in a digits sequence, as determined by at least 2 consecutive digits
            if (!digitsOnly && ((r->previous == NULL) || ((r->previous->ch == ' ') || (r->previous->ch == '\t') || (r->previous->ch == '\n')))) {
                SmartPtr<OCRRect> p = r;
                int countDigits = 0;
                while ((p != NULL) && (p->ch != ' ') && (p->ch != '\t') && (p->ch != '\n')) {
                    if (isDigit(p->ch))
                        countDigits++;
                    else
                        countDigits = 0;
                    countCharsInCurrentWord++;
                    p = p->next;
                }
                if (countDigits >= 2)
                    digitsOnly = true;
            } else if (digitsOnly && ((r->ch == ' ') || (r->ch == '\t'))) {
                // Space ends the sequence of touching letters with 2+ digits in them
                digitsOnly = false;
                countCharsInCurrentWord = 0;
            }

            if (digitsOnly && (countCharsInCurrentWord == results->retailerParams.productNumberLen)) {
                // We have a complete product number, do NOT dare insert spaces in it!
                r = r->next;
                continue;
            }

            float gap = -1;
            if (isLetterOrDigit(r->ch) && (r->previous != NULL)) {
                if (isLetterOrDigit(r->previous->ch)) {
                    gap = rectSpaceBetweenRects(r->previous->rect, r->rect);
                    countSpacingBetweenLetters++;
                } else if ((r->previous->ch == ' ') && (r->previous->previous != NULL) && (isLetterOrDigit(r->previous->previous->ch))) {
                    gap = rectSpaceBetweenRects(r->previous->previous->rect, r->rect);
                    countSpacingBetweenLetters++;
                }
            }
            if ((gap > 0) & (gap < minSpace)) {
                minSpace = gap;
                if (minSpace <= line->averageHeight.average * 0.75)
                    break; // no spaced line
            }
            r = r->next;
        }
    }
    // At least 3 letters, all spaced.
    if ((countSpacingBetweenLetters >= 2) && (minSpace > line->averageHeight.average * 0.75)) {
        spacedLine = true;
    }
    
    // Check for missing spaces which should be added
    OCRValidateCheckMissingSpaces(line, results);
    
    // Single-letter testing pass
    // Single-letter testing simply doesn't work w/o image preprocessing!
    
    // Update referenceHeight after Validate fixes
    referenceHeight = maxApplicableHeight(line);
    if (referenceHeight != 0) {
        maxHeightForSingleLetter = MIN(referenceHeight, maxHeightForSingleLetter);
    }
    
    DebugLog("Validate: single-letter, reference heights: maxHeight [%f], uppercase [%f], tallLowercase [%f], digits [%f], lowercase*1.36 [%f] => referenceHeight [%f] => maxHeightForSingleLetter=%f",
             maxCharHeight, line->averageHeightUppercase.average,
             line->averageHeightTallLowercase.average, line->averageHeightDigits.average, line->averageHeightNormalLowercase.average * 1.36,
             referenceHeight, maxHeightForSingleLetter);
    
    if (results->imageTests) {
        tmpR = line->letters[0];
        int index = 0;
        while ((tmpR != NULL) && (tmpR->ch != '\n')) {
            ++index;
#if OCR_VERBOSE_LOG			
			char msg[1024];
			memset(msg, ' ', sizeof(msg));
			strcpy(msg+index-1, "^");
			OCRVerboseLog("### %s", toUTF8(line->text()).c_str());
			OCRVerboseLog("### %s", msg);
            if ((tmpR->previous != NULL) && (tmpR->previous->ch == 's') && (tmpR->ch =='f')) {
                DebugLog("Found");
            }
#endif		
            float forceReplace = false;
			
			if (tmpR->confidence == 0) {
                ReplacingLog("Validate: MM not testing [%c] in [%s] protected by cost=0",(unsigned short)tmpR->ch, toUTF8(line->text()).c_str());
				tmpR = tmpR->next;
				continue;
			}
        
            bool isLineItalic = false;
            // Skip single-letter when not using image processing, it just doesn't work
            // If only one lowercase letter can't be a real italic line, and may be a spurious lowercase letter on the line
            if (!line->isItalic() || (line->nLowercase <= 1))
                isLineItalic = false;
            else {
                isLineItalic = true;
                ReplacingLog(">>> Line is italic (isItalic = %d)", line->isItalic());
            }
            
            // Did we mark this letter for single-letter testing no matter what (by adding +500 to costs)?
            bool forceTestSingleLetter = false;
            if ((tmpR->confidence > 500) && (tmpR->confidence < 1000)) {
                // Remember that fact
                forceTestSingleLetter = true;
                // Remove the marker
                tmpR->confidence -= 500;
            } else if ((tmpR->ch == '!') && (tmpR->next != NULL)) {
                forceTestSingleLetter = true;
            }
        
            bool gluedToPrevious = false;
            if ((tmpR->previous != NULL) && (tmpR->previous->ch != ' ') && (rectSpaceBetweenRects(tmpR->previous->rect, tmpR->rect) <= 0))
                gluedToPrevious = true;
            
            bool gluedToNext = false;
            float spaceWithNext = 1000.0;
            if ((tmpR->next != NULL) && (tmpR->next->ch != ' ')) {
                spaceWithNext = rectSpaceBetweenRects(tmpR->rect, tmpR->next->rect);
                if (spaceWithNext <= 0)
                    gluedToNext = true;
            }

//#if DEBUG
//            if ((tmpR->previous != NULL) && ((tmpR->previous->ch =='5') || (tmpR->previous->ch == ' ')) && (tmpR->previous->previous != NULL) && ((tmpR->previous->previous->ch == '5') || (tmpR->previous->previous->ch == ' ')) && (tmpR->previous->previous->previous != NULL) && ((tmpR->previous->previous->previous->ch =='5') || (tmpR->previous->previous->previous->ch == ' ')))
//            {
//                //&& (tmpR->next->next != NULL) && (tmpR->next->next->ch == 'd')) {
//                DebugLog("Found it");
//            }
//#endif
            
            // Avoid single-letter testing for characters glued to previous or next
            // OK to test '1' even if glued (we only consider '7' based on a bar across all width which should not happen even when glued)
            if (!forceTestSingleLetter && (tmpR->ch != '1') && gluedToPrevious) {
                if (isLineItalic) {
                    //ReplacingLog("Validate: MM not trying to replace [%c] in [%s] overlaps with previous char [%c] AND line is italic",(unsigned short)tmpR->ch, toUTF8(line->text()).c_str(), (unsigned short)tmpR->previous->ch);
                                    tmpR = tmpR->next;
                                    continue; 
                } else {
                    //ReplacingLog("Validate: MM warning testing [%c] in [%s] even though overlaps with previous char [%C]", (unsigned short)tmpR->ch, toUTF8(line->text()).c_str(), tmpR->previous->ch);
                }
            }

            if (!forceTestSingleLetter && (tmpR->ch != '1') && gluedToNext) {
                if (isLineItalic) {
                    ReplacingLog("Validate: MM not testing - not trying to replace [%c] in [%s] overlaps with next char [%c] AND line is italic",(unsigned short)tmpR->ch, toUTF8(line->text()).c_str(), (unsigned short)tmpR->next->ch);
                    tmpR = tmpR->next;
                    continue;
                } else {
                    //ReplacingLog("Validate: MM warning testing [%C] in [%s] even though overlaps with next char [%C]", tmpR->ch, toUTF8(line->text()).c_str(), tmpR->next->ch);
                }
			}
            
			wchar_t originalCh = '\0';
			wchar_t oldCh = tmpR->ch;
			// Don't 2nd guess letters we confirmed explictly
			if ((oldCh != 'l') && (oldCh != 'i') && (oldCh != '|') && (oldCh != '!') && (oldCh != '\\') && (oldCh != 'I') && (oldCh != 't') && (oldCh != 'f')
			&& (oldCh != 'c') && (oldCh != 'C')
            && (oldCh != 'o') && (oldCh != 'O') // Including only for the purpose of detecting a 'c', if result is a 'a' we will ignore
            //&& !((oldCh == '(') && (tmpR->confidence > 500) && (tmpR->confidence < 1000))
            // '1' no longer handled by single-letter loop, done earlier
            // && (oldCh != '1')
				) {
				if (originalCh != '\0') {
					tmpR->ch = originalCh;
				}
				tmpR = tmpR->next;
				continue;
			}
			
#if (! DEBUG_SINGLELETTER)	
			// 2nd i surrounded by consonants, don't even think of changing it to a 'l' ...
			if ((oldCh == 'i') && (countConsonnantsAround(tmpR) > 3)) {
				if (originalCh != '\0') {
					tmpR->ch = originalCh;
				}
				tmpR = tmpR->next;
				continue;
			}
            
            // Require that '1' be wide enough to possibly be a '7'
            // [1 (0x31)] at [333,206 - 353,235] [w=21,h=30]
            // [1 (0x31)] at [336,102 - 348,126] [w=13,h=25]
            if ((oldCh == '1')
                && (tmpR->rect.size.height > tmpR->rect.size.width * 2.00)) {
                if (originalCh != '\0') {
					tmpR->ch = originalCh;
				}
                tmpR = tmpR->next;
				continue;
            }
			
			// Test 'I' only if not first letter and if next letter is a lowercase, i.e. suspicious
			if (oldCh == 'I') {
			   if ( !(   (tmpR->previous != NULL) 
						 // Follows a lowercase letter => suspect!
			          && (isLower(tmpR->previous->ch)
					       // Or: is not the first letter of the word (this is why we test isUpper, same as testing isLetter here)
						   //     and next letter is lowercase (e.g. CIement)
					       || (isUpper(tmpR->previous->ch) && (tmpR->next != NULL) && isLower(tmpR->next->ch))
						 ) 
					 )
				   // even if the above failed, meaning the I appears to be suspicious, let it be if we have stats for
				   // lowercase letters and it is almost as wide as a normal lowercase (as opposed to lowercase l that are narrow)
				   // Note: in italics lines the width of l will be larger than normal lowercase letters, i.e. we wll not question is
				   // That's fine, it just means we may miss a chance to correct but at least we are not taking risks
				   || (tmpR->rect.size.width > 0.80 * line->averageWidthLowercase.average) 
				 )
				{
					if (originalCh != '\0') {
						tmpR->ch = originalCh;
					}
					tmpR = tmpR->next;
					continue;
				} else {
					if (tmpR->confidence != 0) {
						tmpR->ch = 'l';
					} else {
						ReplacingLog("Validate: MM NOT replacing [%c] with [l] (cost != 0)", (unsigned short)tmpR->ch);
					}
				}
			}
#endif
			if (!forceTestSingleLetter && ((tmpR->ch == 'i') || (tmpR->ch == 't') || (tmpR->ch == 'f') || (tmpR->ch == 'l')))   
			{
                // Make an exception and test even if glued to next - if the next character is lower (i.e. not expected to interfere). Add requirement for a certain height
                if (!gluedToPrevious && (tmpR -> next != NULL) && (rectDeltaBetweenBottoms(tmpR->rect, tmpR->next->rect) > tmpR->rect.size.height * 0.22) && (tmpR->rect.size.height > 26)) {
                    // Do nothing, i.e. allow single letter to take place
                } else {
                    // Avoid single-letter when touching previous or next, screws up the components detections and other stuff
                    if (gluedToPrevious || gluedToNext) {
                        ReplacingLog("Validate: MM not testing - not trying to replace [%c] in [%s] overlaps with next  [%d] or previous [%d]",(unsigned short)tmpR->ch, toUTF8(line->text()).c_str(), gluedToPrevious, gluedToNext);
                        if (originalCh != '\0') {
                            tmpR->ch = originalCh;
                        }
                        tmpR = tmpR->next;
                        continue;
                    }
                    if ((tmpR->previous != NULL)
                        && (rectSpaceBetweenRects(tmpR->previous->rect, tmpR->rect) <= 0)
                        && (((tmpR->previous->rect.size.height >  tmpR->rect.size.height * 1.10) || isUpper(tmpR->previous->ch) || isTallLowercase(tmpR->previous->ch))
                             || isLineItalic)) 
                    {
                        ReplacingLog("Validate: MM not testing - not trying to replace [%c] in [%s] because glued to previous tall char [%c]", (unsigned short)tmpR->ch, toUTF8(line->text()).c_str(), (unsigned short)tmpR->previous->ch);
                        if (originalCh != '\0') {
                            tmpR->ch = originalCh;
                        }
                        tmpR = tmpR->next;
                        continue;				
                    }
                }
			}
			if ((tmpR->ch == 't') 
					&& ((tmpR->previous == NULL) || (tmpR->previous->ch == ' '))
					&& (tmpR->next != NULL) && (tmpR->next->ch == 'h')
					&& (tmpR->next->next != NULL) && (tmpR->next->next->ch == 'e')) {
					ReplacingLog("Validate: MM not testing - not trying to replace [%c] in [%s] because part of dictionary [the]", tmpR->ch, toUTF8(line->text()).c_str());
					if (originalCh != '\0') {
						tmpR->ch = originalCh;
					}
					tmpR = tmpR->next;
					continue;
					
			}
			else if ((tmpR->ch == 'f') 
					&& ((tmpR->previous != NULL) && (tmpR->previous->ch == 'o'))
					&& ((tmpR->previous->previous == NULL) || (tmpR->previous->previous->ch == ' '))
					&& ((tmpR->next == NULL) || (tmpR->next->ch == ' '))) {
					ReplacingLog("Validate: MM not testing - not trying to replace [%c] in [%s] because part of dictionary [of]",  tmpR->ch, toUTF8(line->text()).c_str());
					if (originalCh != '\0') {
						tmpR->ch = originalCh;
					}
					tmpR = tmpR->next;
					continue;
					
			} else if ((tmpR->ch == 'f') && (tmpR->next != NULL)) {
				if (((tmpR->next->ch == 'i') || (tmpR->next->ch == 'i')) && (spaceWithNext <= 0)) {
					ReplacingLog("Validate: MM not testing - not trying to replace [%c] in [%s] because glued to next char [%c]",  tmpR->ch, toUTF8(line->text()).c_str(), tmpR->next->ch);
					if (originalCh != '\0') {
						tmpR->ch = originalCh;
					}
					tmpR = tmpR->next;
					continue;
				}
			}
			// Don't try to contradict 'c' glued to next letter - may appear closed by mistake
			if ((tmpR->ch == 'c') && (tmpR->next != NULL) && (tmpR->next->ch != ' ') 
			         && ((rectLeft(tmpR->next->rect) - rectRight(tmpR->rect) - 1) <= 0)) {
				ReplacingLog("Validate: MM not testing [%c] in [%s] because glued to next char [%c]", (unsigned short)tmpR->ch, toUTF8(line->text()).c_str(), tmpR->next->ch);
				if (originalCh != '\0') {
					tmpR->ch = originalCh;
				}
				tmpR = tmpR->next;
				continue;				
			}
			// Don't map \ next to digits into t or anything, let the default handling later replace with '1'
			else if ((tmpR->ch == '\\') 
			    && ( ((tmpR->next != NULL) && isDigit(tmpR->next->ch)) || ((tmpR->previous != NULL) && isDigit(tmpR->previous->ch)) )) {
				ReplacingLog("Validate: MM not testing [%c] in [%s] because next to digit(s)", (unsigned short)tmpR->ch, toUTF8(line->text()).c_str());
				if (originalCh != '\0') {
					tmpR->ch = originalCh;
				}
				tmpR = tmpR->next;
				continue;				
			}
            
            // MM code suggested to replace a i with t even though the i had a clear dot above it!
            if ((tmpR->ch == 'i') || (tmpR->ch == 'l') || (tmpR->ch == 'f') || (tmpR->ch == 't') || (tmpR->ch == '1') || (tmpR->ch == '!') || (tmpR->ch == '|')) {
                SingleLetterTests *st = CreateSingleLetterTests(tmpR->rect, results);
                if (st != NULL) {
                    ConnectedComponentList cpl = st->getConnectedComponents();
                    if (cpl.size() >= 3) {
                        ConnectedComponent main = cpl[1];
                        ConnectedComponent minor = cpl[2];
                        bool gotThird = false;
                        ConnectedComponent third;
                        if ((cpl.size() >= 4) && (tmpR->ch == 'i') && (tmpR->previous != NULL) && isConsonant(tmpR->previous->ch) && (tmpR->next != NULL) && isConsonant(tmpR->next->ch)) {
                            third = cpl[3];
                            float thirdMidPoint = (third.xmin + third.xmax) / 2;
                            if ((third.ymin < main.ymin) && (third.ymax >= (main.ymin - 1)) 
                                    && (thirdMidPoint > main.xmin) && (thirdMidPoint < main.xmax)) {
                                gotThird = true;
                                third.ymax = main.ymax;
                                third.area += main.area;
                                third.xmin = MIN(third.xmin, main.xmin);
                                third.xmax = MAX(third.xmax, main.xmax);
                            }
                        }
                            // Dot not too small
                        if (((minor.area > main.area * 0.05) || (gotThird && (minor.area > third.area * 0.05)))
                            // Dot not too big
                            && ((minor.area < main.area * 0.46) || (gotThird && (minor.area < third.area * 0.46)))
                            // Dot above main
                            && (minor.ymax < (main.ymin - 1))
                            && ((main.getHeight() > minor.getHeight() * 2) || (gotThird && (third.getHeight() > minor.getHeight() * 2)))
                            // Between -25% and +25% of X coordinate of main
                            && ((minor.xmin >= (main.xmin - minor.getWidth() * 0.25)) || (gotThird && (minor.xmin >= (third.xmin - minor.getWidth() * 0.20))))
                            && ((minor.xmax <= (main.xmax + minor.getWidth() * 0.25)) || (gotThird && (minor.xmax <= (third.xmax + minor.getWidth() * 0.20)))) 
                            && (((main.ymin - minor.ymax) < main.getHeight()) || (gotThird && ((third.ymin - minor.ymax) < third.getHeight()))))
                        {
                            if ((originalCh == '\0') && (tmpR->ch == 'i')) {
                                ReplacingLog("Validate: MM [%c] confirmed as [i] in [%s] because we found a dot above", (unsigned short)tmpR->ch, toUTF8(line->text()).c_str());
                            } else {
                                ReplacingLog("Validate: MM replacing [%c] with [i] in [%s] because we found a dot above", (unsigned short)tmpR->ch, toUTF8(line->text()).c_str());
                                tmpR->word->updateLetterWithNewCharAndNewRect(tmpR, 'i', tmpR->rect);
                                ReplacingLog("Validate: text after replacement [%s]", toUTF8(line->text()).c_str());
                                originalCh = '\0';  // To remember not to restore below
                            }
                            delete st;
                            tmpR = tmpR->next;
                            continue;				
                        }
                    }
                }
                delete st;
            }
            
            if ((tmpR->ch == '!') && (tmpR->next != NULL) && (tmpR->next->ch != ' '))
                forceReplace = true;
			
            //float iBodyHeight = 0;
			char newCh;
            
#if DEBUG
            if ((tmpR->ch =='i') && (tmpR->next != NULL) && (tmpR->next->ch =='p')) {
                DebugLog("Found it");
            }
#endif            
            
            float iBodyHeight = 0;
            newCh = OCRUtilsSuggestLetterReplacement(tmpR->rect, tmpR->ch,
                                                     (((line->averageHeightNormalLowercase.count > 2) && (tmpR->rect.size.height > line->averageHeightNormalLowercase.average * 1.36))? 0:maxHeightForSingleLetter),
                                                    results,
                                                    forceReplace,
                                                    &iBodyHeight
                                                          );
            
            // 0x0131: // ''
            // If suggestLetter rejected our 'i' proposal but letter is low, go for 'r'
            // Note: this is done only within URL or email for now
            // Note: done even if suggestLetterReplacement failed
            if ((originalCh == 0x0131) && (newCh != 'i') && (line->averageHeightNormalLowercase.count >2) && (tmpR->rect.size.height < line->averageHeightNormalLowercase.average * (1+OCR_ACCEPTABLE_ERROR))) {
                newCh = 'r';
            }
            
            if (newCh == '\0') {
                if (originalCh != '\0') {
                    tmpR->ch = originalCh;
                }
                tmpR = tmpR->next;
                continue;
            }
            
            // 'l' erroneously returned as 'i' even though the presumed dot of the 'i' would have been too high relative to normal lowercase letters (iBodyHeight = 26.5 vs normal lowercase height 21.27 (+24%)
            // I believe we can assume here that the dot of the 'i' touches the body of the letter (because we test for a real disconnected dot earlier)
            if ((newCh == 'i')
                && (line->averageHeightNormalLowercase.count > 1) 
                && (iBodyHeight > line->averageHeightNormalLowercase.average * 1.17))
            {
                ReplacingLog("Validate: MM not replacing - not trying to replace [%c] in [%s] with [i] because the height of the 'i' would be too tall [iBodyHeight=%.0f versus lowercase height=%.0f]",
                             tmpR->ch, toUTF8(line->text()).c_str(), iBodyHeight, line->averageHeightNormalLowercase.average);
                if (originalCh != '\0') {
                    tmpR->ch = originalCh;
                }
                tmpR = tmpR->next;
                continue;
            } 
            
            if ((tmpR->ch == 'o') && (newCh != tmpR->ch) && (newCh != 'c')) {
				// Ignore o -> a replacements (but accept o -> c)
                /* char repCh = SingleLetterTestoAsa(tmpR, results);
                if (repCh == 'a') {
                    ReplacingLog("ValidateLine: MM replacing - validating decision to change [%c], changing to [a] in word [%s]!", (unsigned short)tmpR->ch, toUTF8(tmpR->word->text()).c_str());
                    newCh = 'a';
                } else { */
                    ReplacingLog("Validate: MM NOT replacing [%c] with [%c] in [%s] (tested directly now)", (unsigned short)tmpR->ch, newCh, toUTF8(line->text()).c_str());
                    if (originalCh != '\0') {
                        tmpR->ch = originalCh;
                    }
                    tmpR = tmpR->next;
                    continue;
                //}
            }
            
            // Revisit frequent bad f -> l replacement
            if ((tmpR->ch == 'f') && (newCh == 'l')) {
                SingleLetterTests *st = CreateSingleLetterTests(tmpR->rect, results);
                if (st != NULL) {
                    ConnectedComponentList cpl = st->getConnectedComponents();
                    if (cpl.size() > 1) {
                        OpeningsTestResults resRight;
                        bool success = st->getOpenings(resRight, SingleLetterTests::Right, 
                            0.00,      // Start of range to search (top/left)
                            0.50,    // End of range to search (bottom/right)
                            SingleLetterTests::Bound,   // Require start (top/left) bound
                            SingleLetterTests::Bound  // Require end (bottom/right) bound
                            );
                        if (success && (resRight.maxDepth > cpl[1].getWidth() * 0.15)) {
                            ReplacingLog("Validate: MM NOT replacing [%c] with [%c] in [%s] (double-check failed)", (unsigned short)tmpR->ch, newCh, toUTF8(line->text()).c_str());
                            if (originalCh != '\0') {
                                tmpR->ch = originalCh;
                            }
                            tmpR = tmpR->next;
                            delete st;
                            continue;
                        }
                    }
                    delete st;
                }
            }
            
            // Skip suggestion if it is between l & t & f, but accept from and to i (that one is not too risky)
            if (!forceTestSingleLetter && ((tmpR->rect.size.width < 9) && (tmpR->rect.size.height < 28))
                && (newCh != tmpR->ch) && (((newCh == 't') || (newCh == 'f') || (newCh == 'l')) && (tmpR->ch != 'i'))) {
                ReplacingLog("Validate: MM rejecting suggested replacement of [%c] with [%c] in [%s] because dangerous at that small size [%d, %d]", (unsigned short)tmpR->ch, (unsigned short)newCh, toUTF8(line->text()).c_str(), (int)tmpR->rect.size.width, (int)tmpR->rect.size.height);
                if (originalCh != '\0') {
                    tmpR->ch = originalCh;
                }
                tmpR = tmpR->next;
                continue;
            }
        
            // iBodyHeight was 4
            if ((newCh == 'i') && (iBodyHeight > 0) && (iBodyHeight < tmpR->rect.size.height * 0.42)
                && (((line->averageHeightNormalLowercase.count == 0) && ((tmpR->next == NULL) || (tmpR->next->ch == ' ')))
                    || ((iBodyHeight < line->averageHeightNormalLowercase.average * 0.42) && (tmpR->rect.size.height < line->averageHeightNormalLowercase.average * (1 + OCR_ACCEPTABLE_ERROR))) 
                   )
                ) {
                newCh = ':';
                }              
            
            // Replace l that replaces i with a '1' if next to a digit (for the sake of addresses, phones take care of themselves) 
            // Refrain is there is also an adjacent letter
            if ((newCh == 'l') && (tmpR->ch == 'i')) { 
                bool doit = false;
                // Next to a digit?
                if (((tmpR->previous != NULL) && isDigit(tmpR->previous->ch)) || ((tmpR->next != NULL) && isDigit(tmpR->next->ch)))
                    doit = true;
                if (((tmpR->previous != NULL) && isLetter(tmpR->previous->ch)) || ((tmpR->next != NULL) && isLetter(tmpR->next->ch)))
                    doit = false;
                if (doit)
                    newCh = '1';
            }
                     
            if ((newCh != tmpR->ch) && (newCh != '!')) {
                bool doit = true;
                // When glued to next, we allowed testing if next letter is lower - BUT still reject if the recommendation calls for t or f, because these tests ARE affected by glued stuff below
                // If orig char is '!', replace even if next/previous are glued
                // But accept if we are in a forced validate situation
                if (!forceTestSingleLetter && (tmpR->ch != '!') && ((gluedToNext || gluedToPrevious)) && ((newCh == 't') || (newCh == 'f'))) {
                    ReplacingLog("Validate: MM NOT replacing [%c] with [%c] in [%s] (risky choice when glued to next/previous)", (unsigned short)tmpR->ch, newCh,toUTF8(line->text()).c_str());
                    doit = false;
                }
				// Avoid making a replacement to i if it creates two consecutive i's
				if (newCh == 'i') {
                    if ((tmpR->previous != NULL) && (tmpR->previous->ch == 'i')) {
                        ReplacingLog("Validate: MM NOT replacing [%c] with [%c] in [%s] (following a i)", (unsigned short)tmpR->ch, newCh, toUTF8(line->text()).c_str());
                        doit = false;
                    }
                    // Words ending with 'l' and 't' are frequent (special, international), not so much with 'i'
                    if (((tmpR->ch == 'l') || (tmpR->ch == 't'))
                         && ((tmpR->next == NULL) || isDelimiter(tmpR->next->ch))
                         && ((tmpR->previous != NULL) && isVowel(tmpR->previous->ch))
                        ) {
                        doit = false;
                        ReplacingLog("Validate: MM NOT replacing [%c] with [%c] in [%s] (ai instead of al or it at end of word not likely)", (unsigned short)tmpR->ch, newCh, toUTF8(line->text()).c_str());
                    }
				} else if (newCh == 'l') {
                    if ((tmpR->ch == 't') && (tmpR->next != NULL) && (tmpR->next->ch == 'h')) {
                        ReplacingLog("Validate: MM NOT replacing [%c] with [%c] in [%s] (l before h less likely than t)", (unsigned short)tmpR->ch, newCh, toUTF8(line->text()).c_str());
                        doit = false;   
                    }
                }
				if (doit) {
                    if (tmpR->confidence != 0) {
                        if ((tmpR->ch != 'o') && (newCh == 'o')) {
                            char replaceWith = SingleLetterTestoAsa(tmpR, results);
                            if (replaceWith == 'a') {
                                ReplacingLog("ValidateLine: rule 0274 replacing - overriding MM decision to replace [%c] with [%c], using [%c] instead in word [%s]!", (char)tmpR->ch, newCh, replaceWith, toUTF8(tmpR->word->text()).c_str());
                                newCh = replaceWith;
                            }
                        }
                        ReplacingLog("Validate: rule 0275 MM replacing [%c] with [%c] in [%s]", (char)tmpR->ch, (char)newCh, toUTF8(line->text()).c_str());
                        tmpR->word->updateLetterWithNewCharAndNewRect(tmpR, newCh, tmpR->rect);
                        ReplacingLog("Validate: text after replacement [%s]", toUTF8(line->text()).c_str());
                        originalCh = '\0';  // To remember not to restore below
                    } else {
                        ReplacingLog("Validate: rule 0275 MM NOT replacing [%c] with [%c] in [%s] (cost = 0)", (char)tmpR->ch, (char)newCh, toUTF8(line->text()).c_str());
                    }
                }
			}
			if (originalCh != '\0') {
				tmpR->ch = originalCh;
			}
			tmpR = tmpR->next;
		}
    } // if (results->imageTests)
	//free(uprightGrayscale);

	// Special pass: replacements we do always - done here to allow these chars to combine in more complex replacement patterns
	if (line->letters.size() < 1)
		return;
	r = line->letters[0];
	r = r->next;
	while (r != NULL)
	{
		if (r->ch == '|') {
			// The case of '|' surrounded by uppercase letters (replacing with 'I') is handled specifically in main validate loop
			char newCh = 'l';
			ReplacingLog("ValidateLine: rule 0276 replacing [%c] with [%c] in word [%s]", r->ch, newCh, toUTF8(r->word->text()).c_str());
			r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
		} else if (r->ch == 0x2c7) {
            // little ^ standalone sign
            DebugLog("ValidateLine: rule 0277 replacing, eliminating unwanted unicode char (0x%x) [little ^ standalone sign]", (unsigned short)r->ch);
            SmartPtr<OCRRect> p = r->next;
            r->word->removeLetter(r);
            r = p;
            continue;
        } else if (r->ch == 0x201c) {
            // If the double left quote wasn't replaced in the two passes of validate, let's remove it
            DebugLog("ValidateLine: rule 0538 replacing - skipping unwanted unicode char (0x%x) [left double quotation mark]", (unsigned short)r->ch);
            SmartPtr<OCRRect> p = r->next;
            r->word->removeLetter(r);
            r = p;
            continue;
        }
		r = r->next;
	}
	
	/* Now that we clean-up the various averages while replacing certain characters, check spaces again */

#if OCR_ELIMINATE_NARROW_SPACES
    OCRValidateCheckSpuriousSpaces(line, results);
#endif // OCR_ELIMINATE_NARROW_SPACES

//    // Special check for lines where all letters are separated by a space - eliminate all spaces
//	if (line->letters.size() < 1)
//		return;
//	r = line->letters[0];
//	bool allSpaced = true;
//	bool foundSpace = false;
//	while ((r != NULL) && (r->ch != '\n')) {
//		if ((r->ch != ' ') && (r->next != NULL) && (r->next->ch != '\n') && (r->next->ch != ' ')) {
//			allSpaced = false;
//			break;
//		}
//		if (r->ch == ' ')
//			foundSpace = true;
//		r = r->next;
//	}
//	if (allSpaced && foundSpace) {
//		if (line->letters.size() < 1)
//			return;
//		r = line->letters[0];
//		ReplacingLog("ValidateLine: eliminating all spaces in word [%ls]", r->word->text().c_str());
//		while ((r != NULL) && (r->ch != '\n')) {
//			if (r->ch == ' ') {
//
//                SmartPtr<OCRRect> p = r->next; // Save r->next
//                r->word->removeLetter(r);
//                r = p;
//                continue;
//			} else {
//				r = r->next;
//			}
//		}
//	}
//    // End - Special check for lines where all letters are separated by a space - eliminate all spaces
    
   	if (line->letters.size() < 1)
        return;
    
    // Special pass just for missing dots (done separately because finding dots affects the rule for missing dollars
        // Special pass for checks that depend on correct spacing
    r = line->letters[0];

    while ((r != NULL) && (r->ch != '\n')) {

//#if DEBUG
//        if ((r->ch == ' ') && (r->previous != NULL) && (r->previous->ch=='1') && (r->next != NULL) && (r->next->ch=='7')) {
//            DebugLog("Found in [%s]", toUTF8(r->word->text()).c_str());
//            DebugLog("");
//        }
//#endif
        
        // Check for missing dots in prices
        if ((r->ch == ' ') && (r->next != NULL) && (r->previous != NULL)) {
            int nDigitsLookalikeAfter = countDigitLookalikes(r->next, true, results);
            if (nDigitsLookalikeAfter == 2) {
                int nDigitsLookalikeBefore = countDigitLookalikes(r->previous, false, results);
                if (nDigitsLookalikeBefore >= ((results->retailerParams.pricesHaveDollar)? 2:1)) {
                    // Possible price, search for '.'
                    // Minimum spacing before/after dot, e.g. 3 out of height=18 (17%)
                    CGRect rectBetween;
                    rectBetween.origin.x = rectRight(r->previous->rect) + 1;
                    rectBetween.size.width = rectLeft(r->next->rect) - rectRight(r->previous->rect) - 1;
                    float minY = MIN(rectBottom(r->previous->rect), rectBottom(r->next->rect));
                    float maxY = MAX(rectTop(r->previous->rect), rectTop(r->next->rect));
                    rectBetween.origin.y = minY;
                    rectBetween.size.height = maxY - minY + 1;
                    SingleLetterTests *st = CreateSingleLetterTests(rectBetween, results);
                    if (st != NULL) {
                        ConnectedComponentList cpl = st->getConnectedComponents();
                        if (cpl.size() == 2) {
                            float xMargin = results->globalStats.averageHeightDigits.average * 0.17;
                            ConnectedComponent dotCC = cpl[1];
                            if ((dotCC.getHeight() < rectBetween.size.height * 0.30)
                                && (dotCC.ymin > rectBetween.size.height * 0.70)
                                && (dotCC.getWidth() > results->globalStats.averageHeightDigits.average * 0.12)
                                && (dotCC.getWidth() < results->globalStats.averageHeightDigits.average * 0.30)
                                && (dotCC.xmin > xMargin)
                                && (rectBetween.size.width - dotCC.xmax - 1 >xMargin)) {
                                CGRect newRect (rectLeft(rectBetween) + dotCC.xmin, rectBottom(rectBetween) + dotCC.ymin, dotCC.getWidth(), dotCC.getHeight());
                                ReplacingLog("ValidateLine: rule 0615 inserting missing [.] between [%c] and [%c] in word [%s]", (unsigned short)r->previous->ch, (unsigned short)r->next->ch, toUTF8(r->word->text()).c_str());
                                r->word->updateLetterWithNewCharAndNewRect(r, '.', newRect);
                                r = r->next->next;
                                continue;
                            }
                        }
                        delete st;
                    } // st != NULL
                }
            }
        }
        r = r->next;
    }
    
    // Special pass for checks that depend on correct spacing
    r = line->letters[0];

    bool pricePresentInCurrentWord = false;
    int countDigitsBeforeDecimalPoint = 0;
    while ((r != NULL) && (r->ch != '\n')) {
        
        // Calculate stats
        SmartPtr<OCRWord> statsWithoutCurrent = SmartPtr<OCRWord>(new OCRWord(line));
        // Now remove current char
        if (!(r->flags & FLAGS_OUTLIER)) {
            // Not a outlier we already removed
            statsWithoutCurrent->updateStatsAddOrRemoveLetterAddingSpacingOnly(r, false, false);
        }
        
        SmartPtr<OCRWord> statsWithoutCurrentAndNext = SmartPtr<OCRWord>(new OCRWord(line));
        if (!(r->flags & FLAGS_OUTLIER)) {
            // Not a outlier we already removed
            statsWithoutCurrentAndNext->updateStatsAddOrRemoveLetterAddingSpacingOnly(r, false, false);
        }
        if ((r->next != NULL) && !(r->next->flags & FLAGS_OUTLIER)) {
            // Not a outlier we already removed
            statsWithoutCurrentAndNext->updateStatsAddOrRemoveLetterAddingSpacingOnly(r->next, false, false);
        }
        
        SmartPtr<OCRWord> statsWithoutCurrentAndNextTwo = SmartPtr<OCRWord>(new OCRWord(line));
        if (!(r->flags & FLAGS_OUTLIER)) {
            // Not a outlier we already removed
            statsWithoutCurrentAndNextTwo->updateStatsAddOrRemoveLetterAddingSpacingOnly(r, false, false);
        }
        if ((r->next != NULL) && !(r->next->flags & FLAGS_OUTLIER)) {
            // Not a outlier we already removed
            statsWithoutCurrentAndNextTwo->updateStatsAddOrRemoveLetterAddingSpacingOnly(r->next, false, false);
        }
        if ((r->next != NULL) && (r->next->next != NULL) && !(r->next->next->flags & FLAGS_OUTLIER)) {
            // Not a outlier we already removed
            statsWithoutCurrentAndNextTwo->updateStatsAddOrRemoveLetterAddingSpacingOnly(r->next->next, false, false);
        }
        
//#if DEBUG
//        if ((r->ch=='$') && (r->next != NULL) && (r->next->ch=='3') && (r->next->next != NULL) && (r->next->next->ch=='1') && (r->next->next->next != NULL) && (r->next->next->next->ch=='.')) {
//            DebugLog("Found in [%s]", toUTF8(r->word->text()).c_str());
//            DebugLog("");
//        }
//#endif
        
        SmartPtr<OCRRect> firstPriceRect; // First digit in price in current word
        SmartPtr<OCRRect> lastDigitBeforeDecimalRect;
        SmartPtr<OCRRect> lastPriceRect; // last digit in price in current word
        if (r->ch == ' ') {
            countDigitLookAlikesInCurrentWord = countCharsInCurrentWord = 0;
            pricePresentInCurrentWord = false;
            countDigitsBeforeDecimalPoint = 0;
        } else {
            // Look ahead to count the number of characters until next space + number of digits lookalikes
            if (((r->previous == NULL) || ((r->previous->ch == ' ') || (r->previous->ch == '\t') || (r->previous->ch == '\n')))) {
                SmartPtr<OCRRect> p = r;
                countCharsInCurrentWord = countDigitLookAlikesInCurrentWord = 0;
                pricePresentInCurrentWord = false;
                countDigitsBeforeDecimalPoint = 0;
                while ((p != NULL) && (p->ch != ' ') && (p->ch != '\t') && (p->ch != '\n')) {
                    lastPriceRect = p;
                    if (isDigitLookalikeExtended(p->ch))
                        countDigitLookAlikesInCurrentWord++;
                    countCharsInCurrentWord++;
                    p = p->next;
                }
                // TODO to the extent that at this point we haven't filled-in missing dots, may need to look beyond the space?
                // TODO ignore noise chars at the end of the price
                // TODO allows space between $ and first digit of the price?
                // Now check if we end the current word with a valid price
                if (isDigitLookalikeExtended(lastPriceRect->ch) && (lastPriceRect->previous != NULL) && isDigitLookalikeExtended(lastPriceRect->previous->ch) && (lastPriceRect->previous->previous != NULL) && (lastPriceRect->previous->previous->ch == '.')) {
                    // Now count the number of digits before the decimal point
                    p = lastDigitBeforeDecimalRect = lastPriceRect->previous->previous->previous;
                    countDigitsBeforeDecimalPoint = 0;
                    while (p != NULL) {
                        if (p == r)
                            break;
                        if (isDigitLookalikeExtended(p->ch)) {
                            firstPriceRect = p;
                            pricePresentInCurrentWord = true;
                            countDigitsBeforeDecimalPoint++;
                        } else {
                            break;
                        }
                        p = p->previous;
                    }
                }
                // Disqualify price if it's actually the time part of a date. e.g. 03.37 AM
                if (pricePresentInCurrentWord
                    && (lastPriceRect->next != NULL) && (lastPriceRect->next->ch == ' ')
                    && (lastPriceRect->next->next != NULL) && ((lastPriceRect->next->next->ch == 'A') || (lastPriceRect->next->next->ch == 'P'))
                    && (lastPriceRect->next->next->next != NULL) && (lastPriceRect->next->next->next->ch == 'M')) {
                    pricePresentInCurrentWord = false;
                }
            }
        }
        
        // Test for missed $ signs
        // 01-29-2016 apply even to existing dollar signs, in case OCR erroneously returned digits in the $ pattern - see https://www.pivotaltracker.com/story/show/112726619
        if (results->retailerParams.pricesHaveDollar /*&& (r->ch != '$')*/ && pricePresentInCurrentWord && ((r->previous == NULL) || (r->previous->ch == ' '))) {
#if DEBUG
            // 42.39
            if ((r->ch=='2') && (r->next != NULL) && (r->next->ch=='0') && (r->next->next != NULL) && (r->next->next->ch=='.') && (r->previous != NULL) && (r->previous->ch==' ')) {
                DebugLog("Found in [%s]", toUTF8(r->word->text()).c_str());
                DebugLog("");
            }
#endif
            CGRect combinedRect = r->rect;
            bool foundRectLeft = false;
            // Check if OCR engine missed a $ just to the left of the price (not including current rect)
            if (r->ch != '$') {
                CGRect rectJustLeft = computeCapturingRectLeft(r, statsWithoutCurrent, results, true, false);
                if (rectJustLeft.size.width > 0) {
                    combinedRect = rectJustLeft;
                    foundRectLeft = true;
                }
            }
            SmartPtr<OCRRect> p = r;
            int n = 0;
            float referenceWidth = 0, referenceHeight = 0;
            OCRWordPtr referenceStats;
            while (p != NULL) {
                if (p == lastDigitBeforeDecimalRect)
                    break;
                // Add current rect into combined rect
                CGRect newCombinedRect = combinedRect;
                if (rectRight(p->rect) > rectRight(newCombinedRect))
                    newCombinedRect.size.width = rectRight(p->rect) - rectLeft(combinedRect) + 1;
                if (rectBottom(p->rect) < rectBottom(newCombinedRect)) {
                    float oldTopY = rectBottom(newCombinedRect) + newCombinedRect.size.height - 1;
                    newCombinedRect.origin.y = rectBottom(p->rect);
                    newCombinedRect.size.height = oldTopY - rectBottom(p->rect) + 1;
                }
                if (rectTop(p->rect) > rectTop(newCombinedRect))
                    newCombinedRect.size.height = rectTop(p->rect) - rectBottom(newCombinedRect) + 1;
                if (n == 0) {
                    referenceHeight = statsWithoutCurrent->averageHeightDigits.average;
                    referenceWidth = statsWithoutCurrent->averageWidthDigits.average;
                    referenceStats = statsWithoutCurrent;
                } else if (n == 1) {
                    referenceHeight = statsWithoutCurrentAndNext->averageHeightDigits.average;
                    referenceWidth = statsWithoutCurrentAndNext->averageWidthDigits.average;
                    referenceStats = statsWithoutCurrentAndNext;
                } else if (n >= 2) {
                    referenceHeight = statsWithoutCurrentAndNextTwo->averageHeightDigits.average;
                    referenceWidth = statsWithoutCurrentAndNextTwo->averageWidthDigits.average;
                    referenceStats = statsWithoutCurrentAndNextTwo;
                }
                if ((newCombinedRect.size.width < referenceWidth * 1.15)
                    // Or, if current rect is suspiciously narrow, accept combined rect a bit larger than +15%
                    || ((p->rect.size.width < referenceWidth * 0.85) && ((newCombinedRect.size.width < referenceWidth * 1.20)))) {
                    n++;
                    combinedRect = newCombinedRect;
                } else
                    break;
                p = p->next;
            }
            if ((n > 0) || foundRectLeft) {
#if DEBUG
                wstring dollarText, priceText;
                p = r;
                for (int k=0; k<n; k++) {
                    dollarText += p->ch;
                    p = p->next;
                }
                while (true) {
                    priceText += p->ch;
                    if (p == lastPriceRect)
                        break;
                    p = p->next;
                }
                DebugLog("OCRValidate: found possible $ [%s] before price [%s] in word [%s]", toUTF8(dollarText).c_str(), toUTF8(priceText).c_str(), toUTF8(r->word->text()).c_str());
//                if ((dollarText == L"0") && (priceText == L"1.32"))
//                    DebugLog("");
#endif
                bool doit = false;
                    // Pattern taller than other letters/digits
                    // (r->ch == '$') || (r->ch == 'S'))
                if ((((r->ch == '$') || (r->ch == 'S')) && (combinedRect.size.height >= referenceHeight))
                    || ((combinedRect.size.height > referenceHeight)
                        // Test that pattern extends below and above the price digits
                        && ((rectBottom(combinedRect) < rectBottom(lastDigitBeforeDecimalRect->rect))
                           || (rectTop(combinedRect) > rectTop(lastDigitBeforeDecimalRect->rect))))) {
                    doit = true;
                } else {
                    // Give the pattern one more chance via visually testing it for likely '$'
                    //  --------------
                    //0|              |
                    //1|     11       |
                    //2|    111 111   |
                    //3|  11111  111  |
                    //4| 111111   111 |
                    //5| 111  1   111 |
                    //6| 11   1    11 |
                    //7| 11           |
                    //8| 111          |
                    //9| 111111       |
                    //a|  11111       |
                    //b|    111 111   |
                    //c|     11  111  |
                    //d|      1  1111 |
                    //e| 1        111 |
                    //f| 11        11 |
                    //#| 111      111 |
                    //#| 1111    1111 |
                    //#|  11111  111  |
                    //#|   1111 1111  |
                    //#|              |
                    //  --------------
                    // Note: this pattern fails to test > referenceHeight because a vertical line chops off the little thingy at the bottom
                    SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
                    if (st != NULL) {
                        if (!(r->flags & FLAGS_TESTED_AS_DISCONNECTED_DIGITDOLLAR)) {
                            r->flags |=FLAGS_TESTED_AS_DISCONNECTED_DIGITDOLLAR;
                            // May need to extend rect down
                            CGRect closestDigit = findClosestDigitLookAlike(firstPriceRect, referenceStats, results, true);
                            if (closestDigit.size.height > 0) {
                                if (rectTop(closestDigit) > rectTop(combinedRect))
                                    combinedRect.size.height = rectTop(closestDigit) - rectBottom(combinedRect) + 1;
                                else if (rectBottom(closestDigit) < rectBottom(combinedRect)) {
                                    float newHeight = rectTop(combinedRect) - rectBottom(closestDigit) + 1;
                                    combinedRect.origin.y = rectBottom(closestDigit);
                                    combinedRect.size.height = newHeight;
                                }
                            }
                            wchar_t newCh = testAsDisconnectedDigit(r, combinedRect, statsWithoutCurrent, results, '$', '\0', true);
                            if (newCh == '$')
                                doit = true;
                        }
                        delete st;
                    }
                }
                if (doit) {
                    if (n > 0) {
                        ReplacingLog("Validate: rule 0597 replacing [%s] with [$] in word [%s]", toUTF8(dollarText).c_str(), toUTF8(r->word->text()).c_str());
                        if ((r->ch != '$') || (n > 1))
                            r->word->updateLetterWithNewCharAndNewRect(r, '$', combinedRect);
                        for (int k=0; k<n-1; k++) {
                            r->word->removeLetter(r->next);
                        }
                    } else {
                        ReplacingLog("Validate: rule 0597 replacing [%s] with [$] in word [%s] (based on finding a pattern on the left)", toUTF8(dollarText).c_str(), toUTF8(r->word->text()).c_str());
                        // This is the case where we discovered Need to create a new rect PQ911
                        line->addLetterWithRectConfidenceAfterRect(r->ch, r->rect, r->confidence, r);
                        r->word->updateLetterWithNewCharAndNewRect(r, '$', combinedRect);
                        
                    }
                }
            } // replacing with $
        }
        
        // Test for sequences that almost make up a product number, except for one 'C' -> turn into '0'. Note: not done at the Regex level so that we can control this only applying one time per number
        if (r->ch == 'C') {
            int nDigitsLookalikesBefore = countDigitLookalikes(r->previous, false, results);
            int nDigitsLookalikesAfter = countDigitLookalikes(r->next, true, results);
            if (nDigitsLookalikesBefore + nDigitsLookalikesAfter == results->retailerParams.productNumberLen - 1) {
                wchar_t newCh = '0';
                ReplacingLog("Validate: rule 0610 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)newCh, toUTF8(r->word->text()).c_str());
                r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
            }
        }
        
        // Eliminate spurious dots after digits - see https://drive.google.com/open?id=0B4jSQhcYsC9VZWlxQkxvSWgtRkk
        if (isDigitLookalikeExtended(r->ch) && !isVerticalLine(r->ch) && (r->next != NULL) && (r->next->ch == '.') && (statsWithoutCurrentAndNext->averageWidthDigits.count > 0) && (rectRight(r->next->rect) - rectLeft(r->rect) + 1 < statsWithoutCurrentAndNext->averageWidthDigits.average * 1.15) && (rectRight(r->next->rect) - rectLeft(r->rect) + 1 < results->globalStats.averageWidthDigits.average * 1.15) && (rectSpaceBetweenRects(r->rect, r->next->rect) < statsWithoutCurrentAndNext->averageSpacing.average)) {
            float gapBetween = rectLeft(r->next->rect) - rectRight(r->rect) - 1;
            if ((gapBetween < r->rect.size.height * 0.15) && (gapBetween < results->globalStats.averageHeightDigits.average * 0.15)) {
                replaceTwo(r, r->ch, "rule 0612");
                DebugLog("");
            }
        }
        
        // Test for possible UPC sequence where we have 12 digit lookalikes, NOT matching UPC test but one of them marked as suspect or '$' (in which case we will only accept 5 or 6)
        // WARNING: this code is also in the main "round" loop above, should only be done right here (after spacing)
        if (results->retailerParams.productNumberUPC
            && ((r->flags & FLAGS_SUSPECT)
                || (r->ch == '$')
                || ((r->ch == '3') && ((r->previous == NULL) || (r->previous->ch == ' ') || (rectSpaceBetweenRects(r->previous->rect, r->rect) > statsWithoutCurrentAndNext->averageSpacing.average * 1.15)) && (r->rect.size.width < statsWithoutCurrent->averageWidthDigits.average * 0.85)))
            && (countCharsInCurrentWord == results->retailerParams.productNumberLen) && (countDigitLookAlikesInCurrentWord == 12)) {
            DebugLog("OCRValidate(): trying to find missing UPC digit in [%s]", toUTF8(r->word->text()).c_str());
            wstring productText;
            OCRRectPtr p = r->previous;
            OCRRectPtr lastDigitR = r;
            int previousDigits = 0;
            bool abort = false;
            bool weCareAboutOtherSuspect = (r->ch != '$');
#if DEBUG
            if (r->ch == '$') {
                DebugLog("");
            }
#endif
            while ((p != NULL) && isDigitLookalikeExtended(p->ch)) {
                productText = p->ch + productText;
                previousDigits++;
                if (weCareAboutOtherSuspect && (p->flags & FLAGS_SUSPECT)) {
                    // We can't risk replacing one suspect digit if another is tagged as suspect too!
                    DebugLog("OCRValidate(): aborting UPC fix, 2nd suspect digit [%c] left of [%c] in [%s]", (unsigned short)p->ch, (unsigned short)r->ch, toUTF8(r->word->text()).c_str());
                    abort = true;
                    break;
                }
                p = p->previous;
            }
            if (!abort) {
                productText = productText + r->ch;
                p = r->next;
                while ((p != NULL) && isDigitLookalikeExtended(p->ch)) {
                    productText = productText + p->ch;
                    lastDigitR = p;
                    if (weCareAboutOtherSuspect && (p->flags & FLAGS_SUSPECT)) {
                        // We can't risk replacing one suspect digit if another is tagged as suspect too!
                        DebugLog("OCRValidate(): aborting UPC fix, 2nd suspect digit [%c] right of [%c] in [%s]", (unsigned short)p->ch, (unsigned short)r->ch, toUTF8(r->word->text()).c_str());
                        abort = true;
                        break;
                    }
                    p = p->next;
                }
            }
            if (!abort && (productText.length() == 12)) {
                productText = convertDigitsLookalikesToDigits(productText);
                if (!RegexUtilsValidateUPCCode(productText)) {
                    wchar_t validChForUPC = RegexUtilsDetermineMissingUPCDigits(productText, previousDigits);
                    // Accept suggested alternate digit if flagged as suspect or was a '3' that's actually '9' or '8' (3 being the possible right side of these digits)
                    if (validChForUPC != '\0') {
                        if ((r->flags & FLAGS_SUSPECT)
                            || ((r->ch == '3') && ((validChForUPC == '9') || (validChForUPC == '8')))
                            || (((r->ch == '5') || (r->ch == '$')) && (validChForUPC == '6'))
                            || (((r->ch == '6') || (r->ch == '$')) && (validChForUPC == '5'))) {
                            ReplacingLog("Validate: rule 0571 replacing [%c] with [%c] in word [%s] to make it a valid UPC code", (unsigned short)r->ch, (unsigned short)validChForUPC, toUTF8(r->word->text()).c_str());
                            r->word->updateLetterWithNewCharAndNewRect(r, validChForUPC, r->rect);
                            makeAnotherPass = true;
                            r = lastDigitR->next;
                            if (r == NULL) break; // Entire item is the product number, which is perfect - stop testing
                            continue;
                        }
#if DEBUG               
                        else {
                            ReplacingLog("Validate: rule 0571 NOT replacing [%c] with [%c] in word [%s] to make it a valid UPC code", (unsigned short)r->ch, (unsigned short)validChForUPC, toUTF8(r->word->text()).c_str());
                        }
#endif
                    }
                }
            }
        } // Test for possible UPC sequence where we have 12 digit lookalikes, NOT matching UPC test
        

#if DEBUG
        if ((r->ch=='J') && (r->next != NULL) && ((r->next->ch=='O') || (r->next->ch=='0')) && (r->previous != NULL) && (r->previous->ch==' ')) {
            SingleLetterTests *st1 = CreateSingleLetterTests(r->rect, results); if (st1 != NULL) delete st1;
//            CGRect newRect = computeCapturingRectLeft(r, statsWithoutCurrent, results);
//            SingleLetterTests *st = CreateSingleLetterTests(newRect, results); if (st != NULL) delete st;
            DebugLog("Found it in [%s]", toUTF8(r->word->text()).c_str());
            DebugLog("");
        }
#endif
        //  ------------
        //0|            |
        //1|        11  |
        //2|       111  |
        //3|      1111  |
        //4|     11111  |
        //5|       111  |
        //6|        11  |
        //7|        11  |
        //8|        11  |
        //9|        11  |
        //a|        11  |
        //b|        11  |
        //c|        11  |
        //d|        11  |
        //e|        11  |
        //f|        11  |
        //#|        11  |
        //#|       111  |
        //#|      1111  |
        //#|      1111  |
        //#|        1   |
        //#|            |
        //  ------------
        // w=6, h=20 but when checking actual becomes w=4, h=20!
        //  --------
        //0|        |
        //1|    111 |
        //2|    111 |
        //3|  11111 |
        //4| 111111 |
        //5| 111111 |
        //6| 111111 |
        //7| 1 1111 |
        //8|    111 |
        //9|   1111 |
        //a|    111 |
        //b|    111 |
        //c|    111 |
        //d|    111 |
        //e|    11  |
        //f|    11  |
        //#|    111 |
        //#|    11  |
        //#|    11  |
        //#|    11  |
        //#|    11  |
        //#|   111  |
        //#|   111  |
        //#|   111  |
        //#|   111  |
        //#|    11  |
        //#|    11  |
        //#|    1   |
        //#|        |
        //  --------
        // 'J' instead of '1'
        if ((r->ch == 'J') && (r->rect.size.height >= r->rect.size.width * 3) && (r->rect.size.width < results->globalStats.averageWidthDigits.average * 0.60) && (results->imageTests)) {
            bool doit = false;
//            int nDigitLookAlikesBefore = countDigitLookalikes(r->previous, false, results, true);
//            int nDigitLookAlikesAfter = countDigitLookalikes(r->next, true, results, true);
//            if (nDigitLookAlikesBefore + nDigitLookAlikesAfter >= 2) {
                CGRect newRect = computeCapturingRectLeft(r, statsWithoutCurrent, results);
                if (newRect.size.height >= newRect.size.width * 3.3) {
                    // Make sure base is no wider than top AND midddle/bottom are more aligned right than left AND bottom part is less than 1/6th wider than middle
                    SingleLetterTests *st = CreateSingleLetterTests(newRect, results);
                    if (st != NULL) {
                        SegmentList slTop = st->getHorizontalSegments(0.125, 0.25);
                        SegmentList slMiddle = st->getHorizontalSegments(0.50, 0.10);
                        SegmentList slBottom = st->getHorizontalSegments(0.90, 0.20);
                        if ((slTop.size() == 1) && (slBottom.size() == 1) && (slMiddle.size() == 1)
                            // Top wider
                            && (slBottom[0].endPos - slBottom[0].startPos + 1 <= slTop[0].endPos - slTop[0].startPos + 1)
                            // Bottom not wider than 1/6th of width
                            && (slBottom[0].endPos - slBottom[0].startPos - (slMiddle[0].endPos - slMiddle[0].startPos) < r->rect.size.width * 0.17)
                            // Middle section more aligned right
                            && (slMiddle[0].startPos > r->rect.size.width - slMiddle[0].endPos - 1)
                            // Bottom section more aligned right
                            && (slBottom[0].startPos > r->rect.size.width - slBottom[0].endPos - 1)
                            )
                            doit = true;
                        delete st;
                    }
                }
                if (doit) {
                    char newCh = '1';
                    ReplacingLog("ValidateLine: rule 0621 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, newRect);
                }
//            } // around digits
        }
        
        //  --------------
        //0|              |
        //1|      111     |
        //2|    1  11     |
        //3|   11    111  |
        //4|   11     11  |
        //5|   1       1  |
        //6|           11 |
        //7|           11 |
        //8|   1       11 |
        //9|   11      11 |
        //a|   11    1111 |
        //b|      1   111 |
        //c|           11 |
        //d|           11 |
        //e|           1  |
        //f|          11  |
        //#|    1    111  |
        //#|   11    11   |
        //#|    1 1111    |
        //#|              |
        //  --------------
        // '3' instead of '9'

        if ((r->ch == '3') && !(r->flags7 & FLAGS7_TESTED_AS_DISCONNECTED_DIGIT_LEFT3) && (results->imageTests)) {
            r->flags7 |= FLAGS7_TESTED_AS_DISCONNECTED_DIGIT_LEFT3;
            CGRect newRect = computeCapturingRectLeft(r, statsWithoutCurrent, results);
            wchar_t newCh = testAsDisconnectedDigit(r, newRect, statsWithoutCurrent, results, '9', '\0', true, 0, true);
            if (newCh != '\0') {
                ReplacingLog("ValidateLine: rule 0622 replacing [%c] with [%c] in word [%ls]", (unsigned short)r->ch, newCh, r->word->text().c_str());
                r->word->updateLetterWithNewCharAndNewRect(r, newCh, newRect);
            }
        }

//#if DEBUG
//        if ((r->ch=='1') && (r->previous != NULL) && (r->previous->ch=='5') && (r->next != NULL) && (r->next->ch==' ') && (r->next->next != NULL) && (r->next->next->ch=='/')) {
//            CGRect newRect = computeCapturingRectRight(r, statsWithoutCurrent, results);
//            SingleLetterTests *st = CreateSingleLetterTests(newRect, results); if (st != NULL) delete st;
//            DebugLog("Found it in [%s]", toUTF8(r->word->text()).c_str());
//            DebugLog("");
//        }
//#endif

        // Vertical line adjacent to digits whereby the gap with the next character is such that there is room for a normal/wide letter => test for other digits
        if ((isVerticalLine(r->ch) && (r->ch != '/'))
            && ((r->previous == NULL) || (r->previous->ch == ' ') || isDigitLookalikeExtended(r->previous->ch))
            && (r->next != NULL) && (((r->next->ch != ' ') && isDigitLookalikeExtended(r->next->ch))
                                    || ((r->next->ch == ' ') && (r->next->next != NULL) &&isDigitLookalikeExtended(r->next->next->ch)))
            && (!(r->flags5 & FLAGS5_TESTED_AS_DISCONNECTED_DIGIT2) || !(r->flags3 & FLAGS3_TESTED_AS_DISCONNECTED_DIGIT4) || !(r->flags4 & FLAGS4_TESTED_AS_DISCONNECTED_DIGIT7) || !(r->flags7 & FLAGS7_TESTED_AS_DISCONNECTED_RIGHTRECT_DIGIT8))
            && (statsWithoutCurrent->averageWidthDigits.count >= 3)) {
            bool spacePresent = (r->next->ch == ' ');
            float totalWidth = (spacePresent? rectLeft(r->next->next->rect) - rectLeft(r->rect) + 1:rectLeft(r->next->rect) - rectLeft(r->rect) + 1);
            // There is room for a full digits (wider than '1') until the next char
            if (totalWidth > (statsWithoutCurrent->averageWidthDigits.average + statsWithoutCurrent->averageSpacing.average) * 0.85) {
                CGRect newRect = computeCapturingRectRight(r, statsWithoutCurrent, results);
                if (((newRect.size.width > r->rect.size.width) || (newRect.size.width > results->globalStats.averageWidthDigit1.average * 1.20)) && ((newRect.size.width > statsWithoutCurrent->averageWidthDigits.average * 0.82) || (newRect.size.width > results->globalStats.averageWidthDigits.average * 0.82))) {
                    r->flags5 |= FLAGS5_TESTED_AS_DISCONNECTED_DIGIT2;
                    wchar_t newCh = testAsDisconnectedDigit(r, newRect, statsWithoutCurrent, results, '2', '\0', true, 0, true);
                    if ((newCh == '\0') && !(r->flags3 & FLAGS3_TESTED_AS_DISCONNECTED_DIGIT4)) {
                        r->flags3 |= FLAGS3_TESTED_AS_DISCONNECTED_DIGIT4;
                        newCh = testAsDisconnectedDigit(r, newRect, statsWithoutCurrent, results, '4', '\0', true, 0, true);
                    }
                    if ((newCh == '\0') && !(r->flags4 & FLAGS4_TESTED_AS_DISCONNECTED_DIGIT7)) {
                        r->flags4 |= FLAGS4_TESTED_AS_DISCONNECTED_DIGIT7;
                        newCh = testAsDisconnectedDigit(r, newRect, statsWithoutCurrent, results, '7', '\0', true, 0, true);
                    }
                    if ((newCh == '\0') && !(r->flags7 & FLAGS7_TESTED_AS_DISCONNECTED_RIGHTRECT_DIGIT8)) {
                        r->flags7 |= FLAGS7_TESTED_AS_DISCONNECTED_RIGHTRECT_DIGIT8;
                        newCh = testAsDisconnectedDigit(r, newRect, statsWithoutCurrent, results, '8', '\0', true, 0, true);
                    }
                    if (newCh != '\0') {
                        ReplacingLog("ValidateLine: rule 0620 replacing [%c] with [%c] in word [%ls]", (unsigned short)r->ch, newCh, r->word->text().c_str());
                        if (spacePresent)
                            replaceTwoWithRect(r, newCh, newRect);
                        else
                            r->word->updateLetterWithNewCharAndNewRect(r, newCh, newRect);
                    }
#if DEBUG
                    else {
                        DebugLog("");
                    }
#endif
                }
            } // width fits
        }
        
        // Vertical line as first char or after a space, check for possible '4'
        if (isVerticalLine(r->ch) && (r->ch != '/') && ((r->previous == NULL) || (r->previous->ch == ' '))
            && !(r->flags3 & FLAGS3_TESTED_AS_DISCONNECTED_DIGIT4)
            && (statsWithoutCurrent->averageWidthDigits.count >= 3)) {
            char newCh = '\0';
            CGRect newRect = computeCapturingRectLeft(r, statsWithoutCurrent, results);
            if (((newRect.size.width > r->rect.size.width) || (newRect.size.width > results->globalStats.averageWidthDigit1.average * 1.20)) && ((newRect.size.width > statsWithoutCurrent->averageWidthDigits.average * 0.82) || (newRect.size.width > results->globalStats.averageWidthDigits.average * 0.82))) {
                r->flags3 |= FLAGS3_TESTED_AS_DISCONNECTED_DIGIT4;
                newCh = testAsDisconnectedDigit(r, newRect, statsWithoutCurrent, results, '4', '\0', true, 0, true);
                if (newCh != '\0') {
                    ReplacingLog("ValidateLine: rule 0621 replacing [%c] with [%c] in word [%ls]", (unsigned short)r->ch, newCh, r->word->text().c_str());
                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, newRect);
                }
            } // width fits
        }
        
        // 'I' and '|' around digits -> '1'. Note: only apply when absolutely certain, because within prices there is NO need, regex will accept I for 1, so replacing within text will just hurt us
        if ((r->ch != '1') && isLike1(r->ch)) {
            bool doit = false;
            SingleLetterTests *st = CreateSingleLetterTests(r->rect, results, false, SINGLE_LETTER_VALIDATE_COMP_SIZE|SINGLE_LETTER_VALIDATE_SINGLE_COMP);
            if (st != NULL) {
            
                //  ----------
                //0|          |
                //1|    1111  |
                //2| 11111111 |
                //3| 11111  1 |
                //4|    11    |
                //5|    11    |
                //6|    11    |
                //7|    11    |
                //8|   111    |
                //9|    11    |
                //a|    11    |
                //b|    11    |
                //c|    11    |
                //d|    11    |
                //e|    11    |
                //f|    11    |
                //#|    11    |
                //#|    11    |
                //#|    11    |
                //#|   111    |
                //#| 11111111 |
                //#| 11111111 |
                //#|    11    |
                //#|    1     |
                //#|          |
                //  ----------
                // Note: grab 20% on top / bottom to make sure we are not hurt by a little spike at bottom of above pattern, see "CAULIFLOWER" in https://drive.google.com/open?id=0B4jSQhcYsC9Vc0NETnUxQ1l5QWc
                SegmentList topSl = st->getHorizontalSegments(0.10, 0.20);
                SegmentList bottomSl = st->getHorizontalSegments(0.90, 0.20);
                // Wider on top than bottom by at least 50%
                if ((topSl.size() == 1) && (bottomSl.size() == 1) && (topSl[0].endPos - topSl[0].startPos + 1 > (bottomSl[0].endPos - bottomSl[0].startPos + 1) * ((bottomSl[0].endPos - bottomSl[0].startPos + 1 >= 3)? 1.50:1.70))) {
                    // Make sure extra width on top comes on the left side
                    CGRect topQuarter (rectLeft(r->rect), rectBottom(r->rect), r->rect.size.width, r->rect.size.height * 0.25);
                    SingleLetterTests *stTop = CreateSingleLetterTests(topQuarter, results, false, SINGLE_LETTER_VALIDATE_COMP_SIZE|SINGLE_LETTER_VALIDATE_SINGLE_COMP);
                    if (stTop != NULL) {
                        OpeningsTestResults resTop;
                        bool success = stTop->getOpenings(resTop, SingleLetterTests::Left,
                            0.00,
                            1.00,
                            SingleLetterTests::Bound,
                            SingleLetterTests::Unbound);
                        if (success && (resTop.maxDepth > 1)) {
                            // Means there is a "roof" on top
                            doit = true;
                        }
                        delete stTop;
                    }
                } // top wider than bottom
                else {
                    // Top not wider than bottom but one more chance if straight vertical line only touching digits and separators but no letters
                    // Check that bottom is not much wider than middle
                    SegmentList middleSl = st->getHorizontalSegments(0.50, 0.05);
                    if ((topSl.size() == 1) && (bottomSl.size() == 1) && (middleSl.size() == 1)
                        && (bottomSl[0].endPos - bottomSl[0].startPos + 1 < (middleSl[0].endPos - middleSl[0].startPos + 1) * 1.34)) {
                        bool onlyTouchingDigits = true;
                        bool foundRealDigits = false;
                        int foundI = 0;
                        bool atLineEnd = false; // Does the word end the line? If so we should be more agressive in replacing 'I' with '1' because it can't be something like "Field Engineer II"
                        bool atLineStart = false;
                        // Look before
                        SmartPtr<OCRRect> p = r->previous;
                        // Stop at space or start of line
                        while (p != NULL) {
                            if (p->ch == ' ')
                                break;
                            else if (isLetter(p->ch) && (p->ch != 'O') && (p->ch != 'I')) {
                                onlyTouchingDigits = false;
                                break;
                            } else if (!foundRealDigits && (isDigit(p->ch) || (p->ch == 'O'))) {
                                foundRealDigits = true;
                            } else if (p->ch == 'I') {
                                foundI++;
                            }
                            p = p->previous;
                        } // Look before
                        if (p == NULL) {
                            atLineStart = true;
                        }
                        if (onlyTouchingDigits) {
                            // Look after
                            SmartPtr<OCRRect> p = r->next;
                            // Stop at space or end of line
                            while (p != NULL) {
                                if (p->ch == ' ')
                                    break;
                                else if (isLetter(p->ch) && (p->ch != 'O') && (p->ch != 'I')) {
                                    onlyTouchingDigits = false;
                                    break;
                                } else if (!foundRealDigits && (isDigit(p->ch) || (p->ch == 'O'))) {
                                    foundRealDigits = true;
                                } else if (p->ch == 'I') {
                                    foundI++;
                                }
                                p = p->next;
                            } // Look after
                            if (p == NULL) {
                                atLineEnd = true;
                            }
                        }
                        if (onlyTouchingDigits && foundRealDigits) {
                            doit = true;
                        }
                        // I or II or III etc (but not at end of line where it might be a Roman numeral thing at the end of a title or name)
                        else if (onlyTouchingDigits && (foundI > 0)) {
                            if (!atLineEnd || (foundI > 2)) {
                                doit = true; // Can't be a Roman numeral at start of line or middle or line, or if more than 3 total 'I's (including the one we are looking at)
                            } else {
                                // Here we are at line end, and with one, two or three I's
                                // At end of line: leave as Roman numerals - unless we find digits ANYWHERE on the line (implies address line like 342 5th avenue, Suite 11)
                                bool foundDigitsAnywhere = false;
                                SmartPtr<OCRRect> p = r->previous;
                                while (p != NULL) {
                                    if (isDigit(p->ch)) {
                                        foundDigitsAnywhere = true;
                                        break;
                                    }
                                    p = p->previous;
                                }
                                if (!foundDigitsAnywhere) {
                                    SmartPtr<OCRRect> p = r->next;
                                    while (p != NULL) {
                                        if (isDigit(p->ch)) {
                                            foundDigitsAnywhere = true;
                                            break;
                                        }
                                        p = p->next;
                                    }
                                }
                                if (foundDigitsAnywhere) {
                                    doit = true;
                                }
                            }
                        } // found I's
                    } // Has middle segment
                }
                delete st;
            }
            if (doit) {
                char newCh = '1';
                ReplacingLog("ValidateLine: rule 0184 replacing [%c] with [%c] in word [%ls]", (unsigned short)r->ch, newCh, r->word->text().c_str());
                r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                if ((r->next != NULL) && (r->next->ch == ' ')) // Only if followed by space because in the context of a product number that fact makes this digit suspect (possible erasure of the rest of non-1 digit)
                    r->flags |= FLAGS_SUSPECT;
            }
        }
        
        // 'O' surrounded by digits -> '0'
        if ((r->ch == 'O') && (((r->next!= NULL) && isDigit(r->next->ch)) || ((r->previous != NULL) && isDigit(r->previous->ch)))) {
            char newCh = '0';
            ReplacingLog("ValidateLine: rule 0185 replacing [%c] with [%c] in word [%ls]", (unsigned short)r->ch, newCh, r->word->text().c_str());
            r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
        }

        // Matching: ')' in the middle of a line (case at start of line was handled in the main validation loop)
        // Replacing with: 'J' or 'j'
        if ((r->ch == ')') && (r->previous != NULL) && !OCRLine::isPresentInLineBeforeRect('(', r) && !OCRLine::isPresentInLineBeforeRect('[', r))
        {
            wchar_t newCh = '\0';
            SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
            if (st != NULL) {
                bool hasDot = false;
                ConnectedComponentList cpl = st->getConnectedComponents();
                if (cpl.size() >= 3) {
                    ConnectedComponent dotCC = cpl[2];
                    ConnectedComponent mainCC = cpl[1];
                    if ((dotCC.area < mainCC.area * 0.10) && (dotCC.ymax < mainCC.ymin)) {
                        hasDot = true;
                    }
                }
                
                float gapB = gapBelow(r);
                
                if (!hasDot && (gapB != -1000) && (gapB > statsWithoutCurrent->averageHeightUppercase.average * 0.18)
                    && (((r->next != NULL) && isUpper(r->next->ch) && (gapBelowToplineOfOtherRect(r, r->next) < statsWithoutCurrent->averageHeightUppercase.average * 0.10))
                        // Or followed by space or delimiter, but preceded by an uppercase + flush with it on top + below its baseline
                        || ((r->next != NULL) && !isLetterOrDigit(r->next->ch) && (r->previous != NULL) && isUpper(r->previous->ch) && (gapBelowToplineOfOtherRect(r, r->previous) < statsWithoutCurrent->averageHeightUppercase.average * 0.10)))) {
                    newCh = 'J';
                }
                
                delete st;
            }
            if (newCh != '\0') {
                ReplacingLog("ValidateLine: rule 0171 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)newCh, toUTF8(r->word->text()).c_str());
                r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                r = r->next;
                continue;	// We don't expect other substitutions
            }
        }
        
        // '0' instead of 'O'
        if ((r->ch == '0') && ((r->previous == NULL) || (!isUpper(r->previous->ch) && !isDigit(r->previous->ch))) && (r->next != NULL) && isLower(r->next->ch)) {
            bool doit = true;
            char newCh = 'O';
            SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
            if (st != NULL) {
                // Check for diagonal accross '0', if found abort replacement
                SegmentList slMiddle = st->getVerticalSegments(0.50, 0.00);
                if ((slMiddle.size() == 3)
                    && (slMiddle[1].startPos > r->rect.size.height * 0.15)
                    && (slMiddle[1].startPos < r->rect.size.height * 0.60)
                    && (slMiddle[1].endPos > r->rect.size.height * 0.40)
                    && (slMiddle[1].endPos < r->rect.size.height * 0.85)) {
                    doit = false;
                    ReplacingLog("ValidateLine: rule 0102 NOT replacing [%c] with [%c] in word [%ls] because found line across", (unsigned short)r->ch, newCh, r->word->text().c_str());
                }
                delete st;
            }
            if (doit) {
                ReplacingLog("ValidateLine: rule 0102 replacing [%c] with [%c] in word [%ls]", (unsigned short)r->ch, newCh, r->word->text().c_str());
                r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
            }
        }
        
        // Better keep this test after upper/lower adjustments because it relies on testing adjacent chars for lower/upper status
        if ((r != NULL) && ((r->ch == 'l') || (r->ch == '|')))
        {
            // Check for lowercase l adjacent to digits, it's usually a '1'
            bool previousIsDigit = false;
            if ((r->previous != NULL) && isDigit(r->previous->ch))
                previousIsDigit = true;
            bool nextIsDigit = false;
            if ((r->next != NULL) && isDigit(r->next->ch))
                nextIsDigit = true;
            // Check for lowercase l adjacent to uppercase letters, it's usually a 'I'
            // Following a uppercase letter
            if (!(isClose(line->averageHeightDigits, r->rect.size.height, 0.08) && (nextIsDigit || previousIsDigit))
                && ( ( ((r->previous != NULL) && isUpper(r->previous->ch))
                       // Or first in line or after a space - but then  only if there are TWO next chars, both uppercase
                       || (((r->previous == NULL) || (r->previous->ch == ' ')) && (r->next != NULL) && isUpper(r->next->ch)
                           && (r->next->next != NULL) && isUpper(r->next->next->ch))
                       )
                     // Double 'I' is virtually non-existent, more likely to be ".Il" so leave that 'l' alone if after 'I'
                     && !((r->previous != NULL) && (r->previous->ch == 'I') && (r->previous->previous != NULL) && (r->previous->previous->ch == '.'))
                     && ((r->next == NULL) || isUpper(r->next->ch) || isDelimiter(r->next->ch) || (r->next->ch == '@'))
                     && (tallHeightTest(statsWithoutCurrent.getPtr(), r->rect.size.height, 'I', false, 0, true) == 1)
                    )) {
                char newCh = 'I';
                bool doit =  false;
                // For now ignore cases like "Al" - difficult to tell if that should be corrected to "Al" or left as "AI" (as in "MI" which is a state code).
                if ((!doit) && (r->previous != NULL) && isUpper(r->previous->ch)) {
                    // If all letters before current in word are uppercase AND more than 2 uppercase letters, OK
                    int countUpperBefore = 0, countLowerBefore = 0;
                    SmartPtr<OCRRect> p = r->previous;
                    SmartPtr<OCRRect> wordStart = p;
                    // Stop at start of line of when encoutering a delimiter
                    while ((p != NULL) && !isDelimiter(p->ch) && (p->ch != '@')) {
                        wordStart = p;
                        if (isUpper(p->ch))
                            countUpperBefore++;
                        else if (isLower(p->ch))
                            countLowerBefore++;
                        p = p->previous;
                    }
                    int countUpperAfter = 0, countLowerAfter = 0;
                    p = r->next;
                    // Stop at start of line of when encountering a delimiter
                    while ((p != NULL) && !isDelimiter(p->ch) && (p->ch != '@')) {
                        if (isUpper(p->ch))
                            countUpperAfter++;
                        else if (isLower(p->ch))
                            countLowerAfter++;
                        p = p->next;
                    }
                    // Accept l -> I only if no other lowercase letters period AND at least two uppercase, e.g. GPl -> GPI (NOT Ml -> MI)
                    if ((countUpperBefore + countUpperAfter >= 2) && ((countLowerBefore + countLowerAfter) == 0))
                        doit = true;
                }
                    
                // Still not safe to replace? Seek 'I' confirmation in the form of ledge above and below
                if (!doit) {
                    doit = SingleLetterTestAsI(r, r->rect, results);
                }
                    
                // Oversized 'L' 2x taller than average uppercase letter
                if (   ((statsWithoutCurrent->averageHeightUppercase.count > 2) && (r->rect.size.height > statsWithoutCurrent->averageHeightUppercase.average * 1.5))
                    || ((r->next != NULL) && isVowel(r->next->ch)
                        && (((r->next->next != NULL) && isVowel(r->next->next->ch)) || ((r->previous != NULL) && isVowel(r->previous->ch)))) ) {
                        newCh = 'L';
                        doit = true;
                }
                if (doit) {
                    ReplacingLog("ValidateLine: rule 0053 replacing [%c] with [%c] in word [%ls]", (unsigned short)r->ch, newCh, r->word->text().c_str());
                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                }
            }
            // Possible 'I' instead of 'l'
            // - if isolated among lowercase letters, e.g. abcId
            // - after a uppercase letter but where there are lowercase letters, e.g. McPIace
            // - NOT first letter in word (because then 'I' hypothesis is likely
            // - Avoid also if previous two are uppercase and next
        } else if ((r != NULL) && (r->ch == 'I') && (r->previous != NULL) && !isDelimiter(r->previous->ch)
                   && !(isUpper(r->previous->ch) && (r->previous->previous != NULL) && isUpper(r->previous->previous->ch) && (r->next!= NULL) && isUpper(r->next->ch))
                   && !(isUpper(r->previous->ch) && (r->next!= NULL) && isUpper(r->next->ch) && (r->next->next != NULL) && isUpper(r->next->next->ch)))
        {
            int countUpperBefore = 0, countLowerBefore = 0;
            SmartPtr<OCRRect> p = r->previous;
            SmartPtr<OCRRect> wordStart = p;
            // Stop at start of line of when encoutering a delimiter
            while ((p != NULL) && !isDelimiter(p->ch) && (p->ch != '@')) {
                wordStart = p;
                if (isUpper(p->ch))
                    countUpperBefore++;
                else if (isLower(p->ch))
                    countLowerBefore++;
                p = p->previous;
            }
            int countUpperAfter = 0, countLowerAfter = 0;
            p = r->next;
            // Stop at start of line of when encountering a delimiter
            while ((p != NULL) && !isDelimiter(p->ch) && (p->ch != '@')) {
                if (isUpper(p->ch))
                    countUpperAfter++;
                else if (isLower(p->ch))
                    countLowerAfter++;
                p = p->next;
            }
            int countLower = countLowerBefore + countLowerAfter;
            int countUpper = countUpperBefore + countUpperAfter;
            if ((countLower > 0)
                // Also make sure it's not a word where virtually all letters are uppercase! See case where we got "VITAhIN" (h instead of M)
                && !((countUpper < countLower * 5) || ((countLower == 1) && (countUpper >= 4))))
            {
                // One last test, check if not a perfect 'I' with ledges
                if (!SingleLetterTestAsI(r, r->rect, results)) {
                    char newCh = 'l';
                    ReplacingLog("ValidateLine: rule 0053 replacing [%c] with [%c] in word [%ls]", (unsigned short)r->ch, newCh, r->word->text().c_str());
                    r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                }
            }
        } // I instead of l
        
        // Spacing should be even around '&' sign
        if ((r->previous != NULL) && (r->next != NULL) && ((r->ch == '&') || (r->ch == 0xa3))) {
            if ((r->previous->ch == ' ') && (r->next->ch != ' ')) {
                DebugLog("Validate: rule 1001 spacing - inserting space between [%c] and [%c] in [%s]", (unsigned short)r->ch, (unsigned short)r->next->ch, toUTF8(line->text()).c_str());
                char newCh = ' ';
                float newBottom = (rectTop(r->rect) + rectTop(r->rect)) / 2;
                CGRect newRect(rectRight(r->rect) + 1,
                               newBottom,
                               1,
                               1);
                line->addLetterWithRectConfidenceAfterRect(newCh, newRect, -1, r);
            } else if ((r->next->ch == ' ') && (r->previous->ch != ' ')) {
                DebugLog("Validate: rule 1001 spacing - inserting space between [%c] and [%c] in [%s]", (unsigned short)r->previous->ch, (unsigned short)r->ch, toUTF8(line->text()).c_str());
                char newCh = ' ';
                float newBottom = (rectTop(r->rect) + rectTop(r->rect)) / 2;
                CGRect newRect(rectRight(r->previous->rect) + 1,
                               newBottom,
                               1,
                               1);
                line->addLetterWithRectConfidenceAfterRect(newCh, newRect, -1, r->previous);
                
            }
        }
        // ] instead of l/1/I
        if (r->status == STATUS_SQUARE_BRACKET_NOT_J) {
            wchar_t newCh = '\0';
            if ((r->previous != NULL) && isLower(r->previous->ch))
                newCh = 'l';
            else if ((r->previous != NULL) && isDigit(r->previous->ch))
                newCh = '1';
            else
                newCh = 'I';
            if ((newCh != '\0') && (newCh != r->ch)) {
                ReplacingLog("ValidateLine: rule 0278 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)newCh, toUTF8(r->word->text()).c_str());
                r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                r = r->next;
                continue;
            }
        } 
        else if (r->status == STATUS_c_INSTEADOF_6) {
            // Check if next/previous are a false '0' or 'O'
            if ((r->previous != NULL) && ((r->previous->ch == '0') || (r->previous->ch == 'O')) && (r->previous->rect.size.height < r->rect.size.height * (1 + OCR_ACCEPTABLE_ERROR))) {
                char newCh = 'o';
                ReplacingLog("ValidateLine: rule 0279 replacing [%c] with [%c] in word [%s]!", (char)r->previous->ch, newCh, toUTF8(r->word->text()).c_str());
                r->word->updateLetterWithNewCharAndNewRect(r->previous, newCh, r->rect);
            }
            if ((r->next != NULL) && ((r->next->ch == '0') || (r->next->ch == 'O')) && (r->next->rect.size.height < r->rect.size.height * (1 + OCR_ACCEPTABLE_ERROR))) {
                char newCh = 'o';
                ReplacingLog("ValidateLine: rule 0280 replacing [%c] with [%c] in word [%s]!", (char)r->next->ch, newCh, toUTF8(r->word->text()).c_str());
                r->word->updateLetterWithNewCharAndNewRect(r->next, newCh, r->rect);
            }
        }
        else if (r->ch == '?')
        {
            char newCh = '\0';
            //PQPQDIGITSONLY - when we know zone is all digits, no need to require char should be a digit
            if ((r->next != NULL) && isDigit(r->next->ch)) {
                newCh = SingleLetterTestAsDigit(r, results, statsWithoutCurrent, true);
            }
            if (newCh != '\0') {
                ReplacingLog("ValidateLine: rule 0281 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)newCh, toUTF8(r->word->text()).c_str());
                r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                r = r->next;
                continue;
            }
        }
        // l instead of J
        // Trying isVertical but afraid of '/' being mapped to J
        else if (isVerticalLine(r->ch) // ((r->ch == 'l') || (r->ch == 'I'))
            && ((r->previous == NULL) || (r->previous->ch == ' '))
            && ((r->next != NULL) && isLower(r->next->ch))
            // Requiring tallness eliminate italic cases - we expect an upright J
            && (r->rect.size.height >= r->rect.size.width * 2.4)
            && results->imageTests) 
        {
            float gap = gapBelow(r);
            if (gap > r->rect.size.height * RATIO_J_BELOW) {
                SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
                if (st != NULL) {
                    OpeningsTestResults resLeftBottom;
                    bool successLeftBottom = st->getOpenings(resLeftBottom, SingleLetterTests::Left,
                        0.50,
                        1.00,
                        SingleLetterTests::Unbound,
                        SingleLetterTests::Bound);
                        // If no opening on left bottom, can't be 'J'
                    if (successLeftBottom && (resLeftBottom.maxDepth >= r->rect.size.width * 0.20)) {
                        char newCh = 'J';
                        ReplacingLog("ValidateLine: post-spacing replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                        r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                        r = r->next;
                        continue;
                    }
                    delete st;
                } // st != NULL
            } // large gap below
        }
        
        if ((r->ch == '1') && (r->next != NULL) && isLower(r->next->ch)
            && ((r->previous == NULL) || isLower(r->previous->ch)))
        {
            char newCh = 'l';
            ReplacingLog("ValidateLine: post-spacing replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
            r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
            // Give single-letter a chance (we were not testing '1's above)
            if (!glued(r)) {
            float iBodyHeight = 0;
                wchar_t suggestedCh = OCRUtilsSuggestLetterReplacement(r->rect, r->ch,
                                                       (((line->averageHeightNormalLowercase.count > 2) && (r->rect.size.height > line->averageHeightNormalLowercase.average * 1.36))? 0:maxHeightForSingleLetter),
                                                        results,
                                                        false, // force replace
                                                        &iBodyHeight
                                                          );
                if (suggestedCh != r->ch) {
                    ReplacingLog("ValidateLine: post-spacing MM replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, (unsigned short)suggestedCh, toUTF8(r->word->text()).c_str());
                    r->word->updateLetterWithNewCharAndNewRect(r, suggestedCh, r->rect);
                }
            }
            
        }
        
        // 1 instead of l or "11" instead of l
        if ((r->ch == '1') && (r->next != NULL) 
            // No digits except 1 or 11
            && ((line->averageHeightDigits.count == 1) || ((r->next->ch == '1') && (line->averageHeightDigits.count == 2)))
            && ( ((isLower(r->next->ch) && (r->next->rect.size.height < r->rect.size.height * OCR_TALL_TO_LOWERCASE_RATIO * (1 - OCR_ACCEPTABLE_ERROR))) 
                    || ((r->next->ch != 'l') && isTallAbove(r->next->ch) && (r->rect.size.height > r->next->rect.size.height * (1-OCR_ACCEPTABLE_ERROR))))
                || ((r->next->ch == '1') && (r->next->next != NULL) && isLower(r->next->next->ch) && (r->next->next->rect.size.height < r->rect.size.height * OCR_TALL_TO_LOWERCASE_RATIO * (1 - OCR_ACCEPTABLE_ERROR)) && (r->next->next->rect.size.height < r->next->rect.size.height * OCR_TALL_TO_LOWERCASE_RATIO * (1 - OCR_ACCEPTABLE_ERROR)))
               )
            )
        {
            char newCh = 'l';
            ReplacingLog("ValidateLine: post-spacing replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
            r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
            if (r->next->ch == '1') {
                r->word->updateLetterWithNewCharAndNewRect(r->next, newCh, r->next->rect);
            }
            r = r->next->next;
            continue;
        }
        
        // I instead of /
        if (((r->ch == 'I') || (r->ch == '|') || (r->ch == 'l')) && results->imageTests
            && (r->rect.size.width > r->rect.size.height * 0.44)
            && ((r->previous == NULL) || (r->previous->ch == ' '))
            && ((r->next == NULL) || (r->next->ch == ' '))) 
        {
            bool doit = true;
            SingleLetterTests *st = CreateSingleLetterTests(r->rect, results);
            if (st != NULL) {
                // Check top
                float pos = 0.02;
                if (1/r->rect.size.height > 0.02)
                    pos = 1/r->rect.size.height;
                SegmentList sl = st->getHorizontalSegments(pos, 0.01);
                if (sl.size() != 1) {
                    DebugLog("OCRUtilsValidate: failed to find the proper segment on top, sl.size=%d", (unsigned short)sl.size());
                    doit = false;
                } else {
                    Segment s = sl[0];
                    if ((s.startPos < r->rect.size.width * 0.50) || ((s.endPos + 1) < r->rect.size.width * 0.95)) {
                        DebugLog("OCRUtilsValidate: failed to find a proper segment on top [%d,%d]", s.startPos, s.endPos);
                        doit = false;
                    }
                }
                // Check bottom
                if (doit) {
                    // Using 10% thickness to make sure we catch the part of left side touching the left side
                    SegmentList sl = st->getHorizontalSegments(0.95, 0.10);
                    if (sl.size() != 1) {
                        DebugLog("OCRUtilsValidate: failed to find the proper segment on bottom, sl.size=%d", (unsigned short)sl.size());
                        doit = false;
                    } else {
                        Segment s = sl[0];
                        // Check that bottom segment is glued to left side
                        if ((s.startPos > r->rect.size.width * 0.05) || ((s.endPos + 1) > r->rect.size.width * 0.50)) {
                            DebugLog("OCRUtilsValidate: failed to find a proper segment on top [%d,%d]", s.startPos, s.endPos);
                            doit = false;
                        }
                    }                    
                }
                delete st;
            } // st != NULL
            if (doit) {
                char newCh = '/';
                ReplacingLog("ValidateLine: post-spacing replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
                r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
                r = r->next;
                continue;            
            }
        }

        // Matching: 'I' surrounded by lowercase letters
        // Replacing with: 'l'
        if ( (r->ch == 'I')
             && (  ((r->previous != NULL) 
                        && (isLower(r->previous->ch)
                            || (!isUpper(r->previous->ch) && (r->previous->ch != ' ') && ((r->next == NULL) || !isUpper(r->next->ch)))))
                       // Or if we failed the above and indeed first letter (as opposed to being after a uppercase letter)
                  || ( ((r->previous == NULL) || (r->previous->ch == ' '))
                       // and next is a lowercase
                       && ((r->next != NULL) && isLower(r->next->ch))
                       // and no wider than lowercase letters (unlike a real 'I')
                       && ((line->averageWidthLowercase.count > 3)
                            && (r->rect.size.width < line->averageWidthLowercase.average * 0.22)) )
                )
            ) 
        {
            char newCh = 'l';
            ReplacingLog("ValidateLine: rule 0282 replacing [%c] with [%c] in word [%s]", (unsigned short)r->ch, newCh, toUTF8(r->word->text()).c_str());
            r->word->updateLetterWithNewCharAndNewRect(r, newCh, r->rect);
            r = r->next;
            continue;
        }
        
        r = r->next;
    } // special pass after spacing work
    
    /* Special pass to fix things around prices:
     - extra char after product prices (when applicable to the retailer)
     */
    r = line->letters[0];
    DebugLog("Looking for possible prices in [%s]", toUTF8(r->word->text()).c_str());
    while ((r != NULL) && (r->ch != '\n')) {
        
//#if DEBUG
//        if ((r->ch=='$') && (r->next != NULL) && (r->next->ch=='3') && (r->next->next != NULL) && (r->next->next->ch=='1') && (r->next->next->next != NULL) && (r->next->next->next->ch=='.')) {
//            DebugLog("Found in [%s]", toUTF8(r->word->text()).c_str());
//            DebugLog("");
//        }
//#endif
        
        // Start gathering elements of a possible price while setting various parameters
        bool foundPrice = false;
        bool possiblePrice = false; // Indicate we started a possible price sequence (with or without digits before dot)
        bool foundDecimalPoint = false;
        int countDigitsBeforeDecimalPoint = 0, countDigitsAfterDecimalPoint = 0;
        SmartPtr<OCRRect> firstPriceRect; // First digit in price in current word
        SmartPtr<OCRRect> lastDigitBeforeDecimalRect;
        SmartPtr<OCRRect> decimalRect;
        SmartPtr<OCRRect> lastPriceRect; // last digit in price in current word
        while (!foundPrice && (r != NULL)) {
            if ((r->ch == '.') || (r->ch == ',')) {
                if (foundDecimalPoint) {
                    // We already found a decimal point, after digits, and we don't have a price yet so only hope is if that '.' is part of a missed $ sign
                    if (results->retailerParams.pricesHaveDollar) {
                        // Reset everything
                        countDigitsBeforeDecimalPoint = 0;
                        if (results->retailerParams.noZeroBelowOneDollar) {
                            foundDecimalPoint = true;
                            decimalRect = r;
                            possiblePrice = true;
                        }
                        r = r->next; continue;
                    } // prices have dollar
                    // Prices don't have a dollar, and we didn't find a valid price yet - reset everything
                    countDigitsBeforeDecimalPoint = countDigitsAfterDecimalPoint = 0;
                    foundDecimalPoint = possiblePrice = false;
                    r = r->next; continue;
                } // had a decimal point already
                else {
                    // We didn't have a decimal point yet
                    // Start of a sub $1.00 price (e.g. ".99")?
                    if (((r->previous ==  NULL) || ((r->previous != NULL) && (r->previous->ch == ' '))) && !results->retailerParams.pricesHaveDollar) {
                        foundDecimalPoint = true;
                        firstPriceRect = decimalRect = r;
                        countDigitsAfterDecimalPoint = countDigitsBeforeDecimalPoint = 0;
                        possiblePrice = true;
                        r = r->next; continue;
                    }
                    if (countDigitsBeforeDecimalPoint > 0) {
                        // Found our decimal point!
                        foundDecimalPoint = true;
                        decimalRect = r;
                        countDigitsAfterDecimalPoint = 0;
                        r = r->next; continue;
                    }
                    // No digits before decimal point encountered, and not a sub-$1.00 price - move forward
                    countDigitsBeforeDecimalPoint = countDigitsAfterDecimalPoint = 0;
                    foundDecimalPoint = possiblePrice = false;
                    r = r->next; continue;
                }
            } // dot
            else if (isDigitLookalikeExtended(r->ch)) {
                if (possiblePrice) {
                    if (foundDecimalPoint) {
                        if (countDigitsAfterDecimalPoint == 0) {
                            countDigitsAfterDecimalPoint = 1;
                            r = r->next; continue;
                        } else if (countDigitsAfterDecimalPoint == 1) {
                            // Found a price?
                            // If extra char after price or discount with chars after price then, yes, assume we found a price (later we will test if what follows
                            if (((results->retailerParams.extraCharsAfterPricesRegex != NULL) || (results->retailerParams.discountEndingRegex != NULL))
                                // Otherwise we have a valid end to the price only if end of line or space is next
                                || ((r->next == NULL) || (r->next->ch == ' '))) {
                                countDigitsAfterDecimalPoint = 2;
                                lastPriceRect = r;
                                foundPrice = true; break;
                            }
                            // 2nd digit, had decimal point, but can't declare a price: assume 2 digits were BEFORE the decimal and keep going (if retailer uses $, hoping the decimal point is part of a missed $)
                            if (results->retailerParams.pricesHaveDollar) {
                                firstPriceRect = decimalRect->next;
                                countDigitsBeforeDecimalPoint = 2;
                                foundDecimalPoint = false;
                                possiblePrice = true;
                                r = r->next; continue;
                            }
                            // Can't be the start of a price, keep going
                            possiblePrice = false;
                            countDigitsBeforeDecimalPoint = countDigitsAfterDecimalPoint = 0;
                            foundDecimalPoint = false;
                            r = r->next; continue;
                        } // had 1 digit after decimal
                    } else {
                        countDigitsBeforeDecimalPoint++;
                        r = r->next; continue;
                    }
                } // within a possible price
                // Not within a possible price yet. Start of one?
                if (((r->previous == NULL) || ((r->previous->ch == ' ')))
                    // There is a dash before (and nothing before that) and retailer has discount prefixes
                    || ((results->retailerParams.discountStartingRegex != NULL) && (r->previous != NULL) && (r->previous->ch == '-') && ((r->previous->previous == NULL) || (r->previous->previous->ch == ' ')))
                    // There is something to the left and retailer uses $
                    || (results->retailerParams.pricesHaveDollar && (r->previous != NULL) && (r->previous->ch != ' '))) {
                    firstPriceRect = r;
                    possiblePrice = true;
                    countDigitsBeforeDecimalPoint = 1;
                    countDigitsAfterDecimalPoint = 0;
                    foundDecimalPoint = false;
                    r = r->next; continue;
                }
                // Can't start a price with it; just keep going
                r = r->next; continue;
            } // found a digit

            // Reset everything
            possiblePrice = false;
            countDigitsBeforeDecimalPoint = countDigitsAfterDecimalPoint = 0;
            foundDecimalPoint = false;
            r = r->next; continue;
        } // looking for possible price
        
        if (!foundPrice) {
            // Price finder loop already moves on when it can't find a price so if we leave the loop without finding a price, that's it, quit looking on that line
            break;
        }

        // Found a possible price!
#if DEBUG
        wstring priceText;
        SmartPtr<OCRRect> p = firstPriceRect;
        while (p != NULL) {
            priceText += p->ch;
            if (p == lastPriceRect)
                break;
            p = p->next;
        }
        DebugLog("OCRValidate: found possible price [%s] in word [%s]", toUTF8(priceText).c_str(), toUTF8(r->word->text()).c_str());
#endif

        // Do we need to fix a comma into a dot?
        if ((decimalRect != NULL) && (decimalRect->ch == ',')) {
#if DEBUG
            SingleLetterTests *st = CreateSingleLetterTests(decimalRect->rect, results);
            if (st != NULL) delete st;
#endif
                // Aspect ratio OK
            if ((decimalRect->rect.size.width >= decimalRect->rect.size.height * 0.65)
                // And space around dot makes sense
                    // Because we don't have metrics on spacing around dots
                && ((results->retailerParams.minSpaceAroundDotsAsPercentOfWidth <= 0)
                    // Or OK left & right
                        // Left space OK
                    || ((((decimalRect->previous != NULL) && (decimalRect->previous->ch != ' ') && (rectSpaceBetweenRects(decimalRect->previous->rect, decimalRect->rect) > results->retailerParams.minSpaceAroundDotsAsPercentOfWidth * results->globalStats.averageWidthDigits.average * 0.85))
                        // Or no need for left space
                        || (results->retailerParams.noZeroBelowOneDollar && ((decimalRect->previous == NULL) || (decimalRect->previous->ch == ' '))))
                        // And right side OK
                        && ((decimalRect->next != NULL) && (decimalRect->next->ch != ' ') && (rectSpaceBetweenRects(decimalRect->rect, decimalRect->next->rect) > results->retailerParams.minSpaceAroundDotsAsPercentOfWidth * results->globalStats.averageWidthDigits.average * 0.85)))
                    )) {
                DebugLog("OCRValidate: fixing [%c] to [.] in word [%s]", (unsigned short)decimalRect->ch, toUTF8(r->word->text()).c_str());
                r->word->updateLetterWithNewCharAndNewRect(decimalRect, '.', r->rect);
            } // dot dimension or spacing make sense
            else {
                DebugLog("OCRValidate: NOT fixing [%c] to [.] in word [%s]", (unsigned short)decimalRect->ch, toUTF8(r->word->text()).c_str());
            }
        }

        // For now, only try to fix what follows product prices when retailer has extra char after price, to detect situations where several chars were returned instead of 1. In that case, just replace with 'N' (we don't care about this char for now, it's absorbed as part of matching a price)
        if ((results->retailerParams.extraCharsAfterPricesRegex != NULL)
            && (lastPriceRect->next != NULL) && (lastPriceRect->next->ch != ' ')
            && (lastPriceRect->next->next != NULL) && (lastPriceRect->next->next->ch != ' ')) {
            SmartPtr<OCRRect> p = lastPriceRect->next;
            SmartPtr<OCRRect> lastExtraP = p;
            int countExtra = 0;
            float xMin = 30000, xMax = 0, yMin = 30000, yMax = 0;
            // Keep going until we find a space or end of line or we passed the max width of a single char
            bool possibleSingleChar = true;
            while ((p != NULL) && (p->ch != ' ')) {
                lastExtraP = p;
                if (rectLeft(p->rect) < xMin)
                    xMin = rectLeft(p->rect);
                if (rectRight(p->rect) > xMax)
                    xMax = rectRight(p->rect);
                if (rectBottom(p->rect) < yMin)
                    yMin = rectBottom(p->rect);
                if (rectTop(p->rect) > yMax)
                    yMax = rectTop(p->rect);
                if (xMax - xMin + 1 > results->globalStats.averageWidthDigits.average * 1.15) {
                    possibleSingleChar = false;
                    break;
                }
                countExtra++; p = p->next;
            }
            if (possibleSingleChar) {
                CGRect combinedRect(xMin, yMin, xMax - xMin + 1, yMax - yMin + 1);
#if DEBUG
                SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
                if (st != NULL) delete st;
#endif
                DebugLog("Replacing [%c-%c] in [%s] with [N]", (unsigned short)lastPriceRect->next->ch, (unsigned short)lastExtraP->ch, toUTF8(r->word->text()).c_str());
                r->word->updateLetterWithNewCharAndNewRect(lastPriceRect->next, 'N', combinedRect);
                // Remove all others
                for (int i=0; i<countExtra-1; i++) {
                    r->word->removeLetter(lastPriceRect->next->next);
                }
            }
        }

        r = lastPriceRect->next;
        continue;
    } // special pass to find possible prices
    
    /* Special pass to detect product numbers for retailers that accept an extra char after the number, to detect situations where we split that char into two. See first product on https://drive.google.com/open?id=0B4jSQhcYsC9VWXo5YWVReGhRU28 */
    if (!(results->retailerParams.noProductNumbers) && (results->retailerParams.charsToIgnoreAfterProductRegex != NULL)) {
        r = line->letters[0];
        DebugLog("Looking for possible extra char after products in [%s]", toUTF8(r->word->text()).c_str());
        int countDigits = 0, countExtraChars = 0;
        bool foundProduct = false; // Found the digits making up a product
        bool foundProductWithExtraChars = false; // Found one or more extra chars after product part
        SmartPtr<OCRRect> firstProductRect, lastProductRect, lastWordRect;
        while ((r != NULL) && (r->ch != '\n')) {
            
//#if DEBUG
//        if ((r->ch=='$') && (r->next != NULL) && (r->next->ch=='3') && (r->next->next != NULL) && (r->next->next->ch=='1') && (r->next->next->next != NULL) && (r->next->next->next->ch=='.')) {
//            DebugLog("Found in [%s]", toUTF8(r->word->text()).c_str());
//            DebugLog("");
//        }
//#endif
            if (isDigitLookalikeExtended(r->ch) && !foundProduct) {
                countDigits++;
                if (countDigits == 1) {
                    firstProductRect = r;
                    r = r->next; continue;
                } else if (countDigits == results->retailerParams.productNumberLen) {
                    lastProductRect = r;
                    foundProduct = true;
                    countExtraChars = 0;
                    r = r->next; continue; // Now we need to find extra chars
                }
                r = r->next; continue; // Need more digits
            }
            // Not a digit lookalike or we already gathered enough digits so treat this one as an extra char
            if (r->ch == ' ') {
                // That's it, end of word. Is that one we may want to fix?
                if (foundProduct && (countExtraChars > 1)) {
                    foundProductWithExtraChars = true;
                    lastWordRect = r;
                } else {
                    countDigits = countExtraChars = 0;
                    foundProduct = foundProductWithExtraChars = false;
                    r = r->next; continue;
                }
            } else {
                if (foundProduct) {
                    countExtraChars++;
                    if ((countExtraChars > 1) && (r->next == NULL)) {
                        foundProductWithExtraChars = true;
                        lastWordRect = r;
                    } else {
                        r = r->next; continue;
                    }
                } else {
                    // We didn't have enough digits and found non-digit: reset
                    countDigits = countExtraChars = 0;
                    foundProduct = foundProductWithExtraChars = false;
                    r = r->next; continue;
                }
            }
            
            if (foundProductWithExtraChars) {
                DebugLog("OCRValidate: found product with extra chars in word [%s]", toUTF8(r->word->text()).c_str());

                if ((lastProductRect->next != NULL) && (lastWordRect != NULL) && (countExtraChars > 1)) {
                    SmartPtr<OCRRect> p = lastProductRect->next;
                    SmartPtr<OCRRect> lastExtraP = lastWordRect;
                    int countExtra = 0;
                    float xMin = 30000, xMax = 0, yMin = 30000, yMax = 0;
                    bool possibleSingleChar = true;
                    while ((p != NULL) && (p != lastExtraP)) {
                        lastExtraP = p;
                        if (rectLeft(p->rect) < xMin)
                            xMin = rectLeft(p->rect);
                        if (rectRight(p->rect) > xMax)
                            xMax = rectRight(p->rect);
                        if (rectBottom(p->rect) < yMin)
                            yMin = rectBottom(p->rect);
                        if (rectTop(p->rect) > yMax)
                            yMax = rectTop(p->rect);
                        if (xMax - xMin + 1 > results->globalStats.averageWidthDigits.average * 1.15) {
                            possibleSingleChar = false;
                            break;
                        }
                        countExtra++; p = p->next;
                    }
                    if (possibleSingleChar) {
                        CGRect combinedRect(xMin, yMin, xMax - xMin + 1, yMax - yMin + 1);
#if DEBUG
                        SingleLetterTests *st = CreateSingleLetterTests(combinedRect, results);
                        if (st != NULL) delete st;
#endif
                        DebugLog("Replacing extra chars [%c-%c] in [%s] with [H]", (unsigned short)lastProductRect->next->ch, (unsigned short)lastExtraP->ch, toUTF8(r->word->text()).c_str());
                        r->word->updateLetterWithNewCharAndNewRect(lastProductRect->next, 'H', combinedRect);
                        // Remove all others
                        for (int i=0; i<countExtra-1; i++) {
                            r->word->removeLetter(lastProductRect->next->next);
                        }
                    }
                }
                // Even though we expect only one product per line
                countDigits = countExtraChars = 0;
                foundProduct = foundProductWithExtraChars = false;
            } // found product with extra chars

            r = r->next;
            continue;
        } // special pass to find split letter after product number
    } // retailer with ignored char after product number
    
    
    /* Special pass to try to salvage UPC codes where a vertical white line (printer bug) splits a digit in two
       Example from https://drive.google.com/file/d/0B4jSQhcYsC9Vdk1Zd0g4b2d5cFk/view
        073577431/178 (1/ instead of 2) 3.00
        0757200011814 (11 instead of 0) 1.59
        03399103C- 179 (C- instead of 9 - and note the space we have to handle too) 29.99
        
        Strategy:
        - accept spaces less than 9 pixels wide (when digit height is 26)
        - if includes a non-digit lookalike: grab with it neighbor such that together they have normal digit width. Then check if other than these 2 chars we still have 11 digits lookalikes
        - if doesn't include a non-digit lookalike and we have 13: find the closest two digits, where space is 4 or less (relative to height 26)
        - then: eliminate spaces we accepted, test if a digit can make up to a valid UPC code
        TODO check where we already accept one non-digit to replace with fitting UPC code, may want to merge code
    */
    
    
    // Special pass to try to salvage several cases of missed prices - done after spacing work
    
    r = line->letters[0];
	while (r != NULL)
	{
#if DEBUG
        if ((r->ch =='2') && (r->next != NULL) && (r->next->ch =='0') && (r->next->next != NULL) && (r->next->next->ch =='.')) {
                DebugLog("Found in [%s]", toUTF8(r->word->text()).c_str());
                DebugLog("");
        }
#endif
        SmartPtr<OCRRect> lastPriceRect;
        if (((r->previous == NULL) || (r->previous->ch == ' '))
            && ((r->ch == '$') || (isDigitLookalikeExtended(r->ch)))) {
            DebugLog("Testing possible price at [%c] in [%s]", r->ch, toUTF8(r->word->text()).c_str());
            if (possiblePrice(r, &lastPriceRect, line, results)) {
                // Skip to the end of discovered price!
                r = lastPriceRect;
                if ((results->retailerParams.hasDiscounts) && (r != NULL) && (r->next != NULL) && (r->next->ch == ' ') && (r->next->next != NULL)) {
                    DebugLog("");
                    CGRect dashRect;
                    if (findDashBetween(r, r->next->next, line, dashRect, results)) {
                        makeAnotherPass = true;
                        DebugLog("Testing possible price: inserting missing dash between [%c] and [%c] in [%s]", r->ch, r->next->next->ch, toUTF8(r->word->text()).c_str());
                        r->word->updateLetterWithNewCharAndNewRect(r->next, '-', dashRect);
                    }
                }
            }
        }
        r = r->next;
    }

    
    // Special pass: if all words in line start with an uppercase except for one or more starting with 'l', replace that 'l' with 'I'
	if (line->letters.size() < 1)
		return;
	r = line->letters[0];
	bool allWordsStartUppercase = true;
	bool foundl = false;
	while (r != NULL)
	{
		if (((r->previous == NULL) || (r->previous->ch == ' '))
			&& isLetter(r->ch)) {
			if (r->ch == 'l') {
				foundl = true;
				r = r->next;
				continue;
			}
			if (!isUpper(r->ch)) {
				allWordsStartUppercase = false;
				break;
			}
		}
		r = r->next;
	}
    
	if (allWordsStartUppercase && foundl) {
		if (line->letters.size() < 1)
			return;
		r = line->letters[0];
		while (r != NULL)
		{
			if ((r->previous == NULL) || (r->previous->ch == ' ')) 
			{
				if (r->ch == 'l') {
					ReplacingLog("ValidateLine: special pass to replace leading 'l's, replacing [l] with [I] in word [%s]", toUTF8(r->word->text()).c_str());
					r->word->updateLetterWithNewCharAndNewRect(r, 'I', r->rect);			
				}
			}
			r = r->next;
		}	
	}

	// Special check: in lines where there are uppercase letters but no lowercase letters except possibly 'l', convert all 'l's into uppercase I
	if (line->letters.size() < 1)
		return;
	r = line->letters[0];
	bool foundLowercaseLOrBackslash = false;
	bool allUpperExceptLOrBackslash = true;
	while ((r != NULL) && (r->ch != '\n')) {
		if ((r->ch == 'l') || (r->ch == '\\')) {
			foundLowercaseLOrBackslash = true;
		} else if (islower(r->ch)) {
			allUpperExceptLOrBackslash = false;
			break;
		}
		r = r->next;
	}
	if (allUpperExceptLOrBackslash && foundLowercaseLOrBackslash) {
		if (line->letters.size() < 1)
			return;
		r = line->letters[0];
		while ((r != NULL) && (r->ch != '\n')) {
			if (((r->ch == 'l') || (r->ch == '\\')) && isClose(line->averageHeightUppercase, r->rect.size.height, 0.07)) {
				ReplacingLog("ValidateLine: rule 0283 replacing [%c] with [I] in word [%ls] (special check for lowercase l's within uppercase words)", (unsigned short)r->ch, r->word->text().c_str());
				r->word->updateLetterWithNewCharAndNewRect(r, 'I', r->rect);
			}
			r = r->next;
		}
	}
    // End - Special check: in lines where there are uppercase letters but no lowercase letters except possibly 'l', convert all 'l's into uppercase I

	return ;
} // OCRValidate

} // namespace ocrparser
